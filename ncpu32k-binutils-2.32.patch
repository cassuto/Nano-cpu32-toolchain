diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/archures.c binutils-ncpu32k-2.32/bfd/archures.c
--- binutils-2.32/bfd/archures.c	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/archures.c	2019-08-12 18:03:26.089312117 +0800
@@ -542,6 +542,10 @@
 .#define bfd_mach_ck803		5
 .#define bfd_mach_ck807		6
 .#define bfd_mach_ck810		7
+.
+.  bfd_arch_ncpu32k,   {* nano-CPU32k.  *}
+.#define bfd_mach_ncpu32k	1
+.
 .  bfd_arch_last
 .  };
 */
@@ -633,6 +637,7 @@
 extern const bfd_arch_info_type bfd_ft32_arch;
 extern const bfd_arch_info_type bfd_msp430_arch;
 extern const bfd_arch_info_type bfd_mt_arch;
+extern const bfd_arch_info_type bfd_ncpu32k_arch;
 extern const bfd_arch_info_type bfd_nds32_arch;
 extern const bfd_arch_info_type bfd_nfp_arch;
 extern const bfd_arch_info_type bfd_nios2_arch;
@@ -724,6 +729,7 @@
     &bfd_ft32_arch,
     &bfd_msp430_arch,
     &bfd_mt_arch,
+    &bfd_ncpu32k_arch,
     &bfd_nds32_arch,
     &bfd_nfp_arch,
     &bfd_nios2_arch,
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/bfd-in2.h binutils-ncpu32k-2.32/bfd/bfd-in2.h
--- binutils-2.32/bfd/bfd-in2.h	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/bfd-in2.h	2020-02-12 15:18:47.035409673 +0800
@@ -2441,6 +2441,10 @@
 #define bfd_mach_ck803         5
 #define bfd_mach_ck807         6
 #define bfd_mach_ck810         7
+
+  bfd_arch_ncpu32k,   /* nano-CPU32k.  */
+#define bfd_mach_ncpu32k       1
+
   bfd_arch_last
   };
 
@@ -5643,6 +5647,23 @@
   BFD_RELOC_NIOS2_R2_T1X1I6,
   BFD_RELOC_NIOS2_R2_T1X1I6_2,
 
+/* nano-cpu32k Relocations.  */
+  BFD_RELOC_NCPU32K_INSN_LO14,
+  BFD_RELOC_NCPU32K_INSN_HI14,
+  BFD_RELOC_NCPU32K_INSN_LO18,
+  BFD_RELOC_NCPU32K_INSN_HI18,
+  BFD_RELOC_NCPU32K_INSN_REL26,
+  BFD_RELOC_NCPU32K_GLOB_DAT,
+  BFD_RELOC_NCPU32K_JMP_SLOT,
+  BFD_RELOC_NCPU32K_RELATIVE,
+  BFD_RELOC_NCPU32K_COPY,
+  BFD_RELOC_NCPU32K_GOT_PCREL_HI18,
+  BFD_RELOC_NCPU32K_GOT_PCREL_LO14,
+  BFD_RELOC_NCPU32K_PLT_REL26,
+  BFD_RELOC_NCPU32K_GOTOFF_HI18,
+  BFD_RELOC_NCPU32K_GOTOFF_LO14,
+  BFD_RELOC_NCPU32K_GOT14,
+
 /* PRU LDI 16-bit unsigned data-memory relocation.  */
   BFD_RELOC_PRU_U16,
 
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/config.bfd binutils-ncpu32k-2.32/bfd/config.bfd
--- binutils-2.32/bfd/config.bfd	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/config.bfd	2019-07-31 11:43:11.643909611 +0800
@@ -183,6 +183,7 @@
 s12z*)         targ_archs=bfd_s12z_arch ;;
 microblaze*)	 targ_archs=bfd_microblaze_arch ;;
 mips*)		 targ_archs=bfd_mips_arch ;;
+ncpu32k*)	 targ_archs=bfd_ncpu32k_arch ;;
 nds32*)		 targ_archs=bfd_nds32_arch ;;
 nfp)		 targ_archs=bfd_nfp_arch ;;
 nios2*)          targ_archs=bfd_nios2_arch ;;
@@ -987,6 +988,10 @@
     targ_selvecs=msp430_elf32_ti_vec
     ;;
 
+  ncpu32k-*-elf | ncpu32k-*-linux*)
+    targ_defvec=ncpu32k_elf32_vec
+    ;;
+
   nds32*le-*-linux*)
     targ_defvec=nds32_elf32_linux_le_vec
     targ_selvecs=nds32_elf32_linux_be_vec
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/configure binutils-ncpu32k-2.32/bfd/configure
--- binutils-2.32/bfd/configure	2019-02-02 23:47:56.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/configure	2019-08-12 16:28:20.113170635 +0800
@@ -14805,6 +14805,7 @@
     msp430_elf32_vec)		 tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
     msp430_elf32_ti_vec)	 tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
     mt_elf32_vec)		 tb="$tb elf32-mt.lo elf32.lo $elf" ;;
+    ncpu32k_elf32_vec)		 tb="$tb elf32-ncpu32k.lo elf32.lo $elf" ;;
     nds32_elf32_be_vec)		 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_le_vec)		 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_linux_be_vec)	 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/configure.ac binutils-ncpu32k-2.32/bfd/configure.ac
--- binutils-2.32/bfd/configure.ac	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/configure.ac	2019-07-31 11:41:39.743907332 +0800
@@ -573,6 +573,7 @@
     msp430_elf32_vec)		 tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
     msp430_elf32_ti_vec)	 tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
     mt_elf32_vec)		 tb="$tb elf32-mt.lo elf32.lo $elf" ;;
+    ncpu32k_elf32_vec)		 tb="$tb elf32-ncpu32k.lo elf32.lo $elf" ;;
     nds32_elf32_be_vec)		 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_le_vec)		 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_linux_be_vec)	 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/cpu-ncpu32k.c binutils-ncpu32k-2.32/bfd/cpu-ncpu32k.c
--- binutils-2.32/bfd/cpu-ncpu32k.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/cpu-ncpu32k.c	2019-07-30 21:45:04.460689102 +0800
@@ -0,0 +1,39 @@
+/* BFD support for the ncpu32k architecture.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_ncpu32k_arch =
+  {
+    32,		  /* 32 bits in a word.  */
+    32,		  /* 32 bits in an address.  */
+    8,		  /* 8 bits in a byte.  */
+    bfd_arch_ncpu32k,
+    bfd_mach_ncpu32k,
+    "ncpu32k",
+    "ncpu32k",
+    4,
+    TRUE,
+    bfd_default_compatible,
+    bfd_default_scan,
+    bfd_arch_default_fill,
+    NULL
+  };
+
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/elf32-ncpu32k.c binutils-ncpu32k-2.32/bfd/elf32-ncpu32k.c
--- binutils-2.32/bfd/elf32-ncpu32k.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/elf32-ncpu32k.c	2020-02-12 15:44:35.687322547 +0800
@@ -0,0 +1,2466 @@
+/* nano-CPU32k-specific support for 32-bit ELF.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   largely based on elf32-or1k.c elf32-m32r.c and elf32-microblaze.c.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/ncpu32k.h"
+#include "libiberty.h"
+
+#define NCPU32K_NREG_LNK 1
+#define NCPU32K_NREG_RV 10
+#define NCPU32K_NREG_RVH 11
+#define NCPU32K_NREG_GOT 14
+
+#define N_ONES(X)	(((bfd_vma)2 << (X)) - 1)
+
+#define PLT_ENTRY_SIZE 16
+
+#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so.1"
+
+static reloc_howto_type ncpu32k_elf_howto_table[] =
+{
+  /* This reloc does nothing.  */
+  HOWTO (R_NCPU32K_NONE,	/* type */
+	 0,			/* rightshift */
+	 3,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_NONE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_16,
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_8,
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_8",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xff,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_INSN_LO14,
+         0,                     /* rightshift */
+         2,                     /* size (0 = byte, 1 = short, 2 = long) */
+         14,                    /* bitsize */
+         FALSE,                 /* pc_relative */
+         18,                    /* bitpos */
+         complain_overflow_dont, /* complain_on_overflow */
+         bfd_elf_generic_reloc, /* special_function */
+         "R_NCPU32K_INSN_LO14",      /* name */
+         FALSE,                 /* partial_inplace */
+         0,                     /* src_mask */
+         0xfffc0000,            /* dst_mask */
+         FALSE),                /* pcrel_offset */
+
+  HOWTO (R_NCPU32K_INSN_HI14,
+         18,                    /* rightshift */
+         2,                     /* size (0 = byte, 1 = short, 2 = long) */
+         14,                    /* bitsize */
+         FALSE,                 /* pc_relative */
+         18,                    /* bitpos */
+         complain_overflow_dont, /* complain_on_overflow */
+         bfd_elf_generic_reloc, /* special_function */
+         "R_NCPU32K_INSN_HI14",      /* name */
+         FALSE,                 /* partial_inplace */
+         0,                     /* src_mask */
+         0xfffc0000,            /* dst_mask */
+         FALSE),                /* pcrel_offset */
+
+  HOWTO (R_NCPU32K_INSN_LO18,
+         0,                     /* rightshift */
+         2,                     /* size (0 = byte, 1 = short, 2 = long) */
+         18,                    /* bitsize */
+         FALSE,                 /* pc_relative */
+         12,                    /* bitpos */
+         complain_overflow_dont, /* complain_on_overflow */
+         bfd_elf_generic_reloc, /* special_function */
+         "R_NCPU32K_INSN_LO18",      /* name */
+         FALSE,                 /* partial_inplace */
+         0,                     /* src_mask */
+         0x3ffff000,            /* dst_mask */
+         FALSE),                /* pcrel_offset */
+
+  HOWTO (R_NCPU32K_INSN_HI18,
+         14,                    /* rightshift */
+         2,                     /* size (0 = byte, 1 = short, 2 = long) */
+         18,                    /* bitsize */
+         FALSE,                 /* pc_relative */
+         12,                    /* bitpos */
+         complain_overflow_dont, /* complain_on_overflow */
+         bfd_elf_generic_reloc, /* special_function */
+         "R_NCPU32K_INSN_HI18",      /* name */
+         FALSE,                 /* partial_inplace */
+         0,                     /* src_mask */
+         0x3ffff000,            /* dst_mask */
+         FALSE),                /* pcrel_offset */
+
+  /* A PC relative 26 bit relocation, right shifted by 2.  */
+  HOWTO (R_NCPU32K_INSN_REL26, /* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 26,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_INSN_REL26", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffc0,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* GNU extension to record C++ vtable hierarchy.  */
+  HOWTO (R_NCPU32K_GNU_VTINHERIT, /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_NCPU32K_GNU_VTINHERIT", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* GNU extension to record C++ vtable member usage.  */
+  HOWTO (R_NCPU32K_GNU_VTENTRY, /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
+	 "R_NCPU32K_GNU_VTENTRY", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+	 
+  HOWTO (R_NCPU32K_COPY,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_COPY",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_GLOB_DAT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_GLOB_DAT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_JMP_SLOT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_JMP_SLOT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_RELATIVE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_RELATIVE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+	 
+  HOWTO (R_NCPU32K_GOT_PCREL_HI18, /* Type.  */
+	 14,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 18,			/* Bitsize.  */
+	 TRUE,			/* PC_relative.  */
+	 12,			/* Bitpos.  */
+	 complain_overflow_dont, /* Complain on overflow.  */
+	 bfd_elf_generic_reloc, /* Special Function.  */
+	 "R_NCPU32K_GOT_PCREL_HI18",	/* Name.  */
+	 FALSE,		/* Partial Inplace.  */
+	 0,			/* Source Mask.  */
+	 0x3ffff000,		/* Dest Mask.  */
+	 TRUE),			/* PC relative offset?  */
+
+  HOWTO (R_NCPU32K_GOT_PCREL_LO14, /* Type.  */
+	 0,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 14,			/* Bitsize.  */
+	 TRUE,			/* PC_relative.  */
+	 18,			/* Bitpos.  */
+	 complain_overflow_dont, /* Complain on overflow.  */
+	 bfd_elf_generic_reloc, /* Special Function.  */
+	 "R_NCPU32K_GOT_PCREL_LO14",	/* Name.  */
+	 FALSE,		/* Partial Inplace.  */
+	 0,			/* Source Mask.  */
+	 0xfffc0000,		/* Dest Mask.  */
+	 TRUE),			/* PC relative offset?  */
+	 
+  HOWTO (R_NCPU32K_PLT_REL26,	/* Type.  */
+	 2,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 26,			/* Bitsize.  */
+	 TRUE,			/* pc_relative.  */
+	 6,			/* Bitpos.  */
+	 complain_overflow_signed, /* Complain on overflow.  */
+	 bfd_elf_generic_reloc, /* Special Function.  */
+	 "R_NCPU32K_PLT_REL26",	/* Name.  */
+	 FALSE,			/* Partial Inplace.  */
+	 0,			/* Source Mask.  */
+	 0xffffffc0,		/* Dest Mask.  */
+	 TRUE),			/* PC relative offset?  */
+
+  HOWTO (R_NCPU32K_GOTOFF_HI18,	/* type */
+	 14,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 18,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_GOTOFF_HI18", /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0x3ffff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_GOTOFF_LO14,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 14,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 18,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_GOTOFF_LO14", /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xfffc0000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+	 
+  HOWTO (R_NCPU32K_GOT14,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 14,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 18,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_GOT14",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffc0000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+};
+
+/* Map BFD reloc types to ncpu32k ELF reloc types.  */
+
+struct ncpu32k_reloc_map
+{
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned int ncpu32k_reloc_val;
+};
+
+static const struct ncpu32k_reloc_map ncpu32k_reloc_map[] =
+{
+  { BFD_RELOC_NONE,			R_NCPU32K_NONE },
+  { BFD_RELOC_32,			R_NCPU32K_32 },
+  { BFD_RELOC_16,			R_NCPU32K_16 },
+  { BFD_RELOC_8,			R_NCPU32K_8 },
+  { BFD_RELOC_NCPU32K_INSN_LO14,	R_NCPU32K_INSN_LO14 },
+  { BFD_RELOC_NCPU32K_INSN_HI14,	R_NCPU32K_INSN_HI14 },
+  { BFD_RELOC_NCPU32K_INSN_LO18,	R_NCPU32K_INSN_LO18 },
+  { BFD_RELOC_NCPU32K_INSN_HI18,	R_NCPU32K_INSN_HI18 },
+  { BFD_RELOC_NCPU32K_INSN_REL26,	R_NCPU32K_INSN_REL26 },
+  { BFD_RELOC_VTABLE_ENTRY,		R_NCPU32K_GNU_VTENTRY },
+  { BFD_RELOC_VTABLE_INHERIT,		R_NCPU32K_GNU_VTINHERIT },
+  { BFD_RELOC_NCPU32K_GLOB_DAT,		R_NCPU32K_GLOB_DAT },
+  { BFD_RELOC_NCPU32K_COPY,		R_NCPU32K_COPY },
+  { BFD_RELOC_NCPU32K_JMP_SLOT,		R_NCPU32K_JMP_SLOT },
+  { BFD_RELOC_NCPU32K_RELATIVE,		R_NCPU32K_RELATIVE },
+  { BFD_RELOC_NCPU32K_GOT_PCREL_HI18,	R_NCPU32K_GOT_PCREL_HI18 },
+  { BFD_RELOC_NCPU32K_GOT_PCREL_LO14,	R_NCPU32K_GOT_PCREL_LO14 },
+  { BFD_RELOC_NCPU32K_PLT_REL26,	R_NCPU32K_PLT_REL26 },
+  { BFD_RELOC_NCPU32K_GOTOFF_HI18,	R_NCPU32K_GOTOFF_HI18 },
+  { BFD_RELOC_NCPU32K_GOTOFF_LO14,	R_NCPU32K_GOTOFF_LO14 },
+  { BFD_RELOC_NCPU32K_GOT14,		R_NCPU32K_GOT14 },
+};
+
+#define TLS_UNKNOWN    0
+#define TLS_NONE       1
+#define TLS_GD	       2
+#define TLS_LD	       3
+#define TLS_IE	       4
+#define TLS_LE	       5
+
+/* ELF linker hash entry.  */
+struct elf_ncpu32k_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+
+  /* Track dynamic relocs copied for this symbol.  */
+  struct elf_dyn_relocs *dyn_relocs;
+
+  /* Track type of TLS access.  */
+  unsigned char tls_type;
+};
+
+/* ELF object data.  */
+struct elf_ncpu32k_obj_tdata
+{
+  struct elf_obj_tdata root;
+
+  /* tls_type for each local got entry.  */
+  unsigned char *local_tls_type;
+};
+
+#define elf_ncpu32k_tdata(abfd) \
+  ((struct elf_ncpu32k_obj_tdata *) (abfd)->tdata.any)
+
+#define elf_ncpu32k_local_tls_type(abfd) \
+  (elf_ncpu32k_tdata (abfd)->local_tls_type)
+
+/* ELF linker hash table.  */
+struct elf_ncpu32k_link_hash_table
+{
+  struct elf_link_hash_table root;
+
+  /* Small local sym to section mapping cache.  */
+  struct sym_cache sym_sec;
+};
+
+/* Get the ELF linker hash table from a link_info structure.  */
+#define ncpu32k_elf_hash_table(p) \
+  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
+   == NCPU32K_ELF_DATA ? ((struct elf_ncpu32k_link_hash_table *) ((p)->hash)) : NULL)
+
+static bfd_boolean
+elf_ncpu32k_mkobject (bfd *abfd)
+{
+  return bfd_elf_allocate_object (abfd, sizeof (struct elf_ncpu32k_obj_tdata),
+				  NCPU32K_ELF_DATA);
+}
+
+/* Create an entry in an ncpu32k ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+ncpu32k_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
+			    struct bfd_hash_table *table,
+			    const char *string)
+{
+  struct elf_ncpu32k_link_hash_entry *ret =
+    (struct elf_ncpu32k_link_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (ret == NULL)
+    ret = bfd_hash_allocate (table,
+			     sizeof (struct elf_ncpu32k_link_hash_entry));
+  if (ret == NULL)
+    return NULL;
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct elf_ncpu32k_link_hash_entry *)
+	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
+				     table, string));
+  if (ret != NULL)
+    {
+      struct elf_ncpu32k_link_hash_entry *eh;
+
+      eh = (struct elf_ncpu32k_link_hash_entry *) ret;
+      eh->dyn_relocs = NULL;
+      eh->tls_type = TLS_UNKNOWN;
+    }
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+/* Create an ncpu32k ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+ncpu32k_elf_link_hash_table_create (bfd *abfd)
+{
+  struct elf_ncpu32k_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct elf_ncpu32k_link_hash_table);
+
+  ret = bfd_zmalloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
+				      ncpu32k_elf_link_hash_newfunc,
+				      sizeof (struct elf_ncpu32k_link_hash_entry),
+				      NCPU32K_ELF_DATA))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  return &ret->root.root;
+}
+
+static reloc_howto_type *
+ncpu32k_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
+			bfd_reloc_code_real_type bcode)
+{
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (ncpu32k_reloc_map); i++)
+    if (ncpu32k_reloc_map[i].bfd_reloc_val == bcode)
+      {
+	unsigned int ocode = ncpu32k_reloc_map[i].ncpu32k_reloc_val;
+	if (ocode < (unsigned int) R_NCPU32K_max)
+	  return &ncpu32k_elf_howto_table[ocode];
+	else
+	  break;
+      }
+
+  return NULL;
+}
+
+static reloc_howto_type *
+ncpu32k_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < R_NCPU32K_max; i++)
+    if (ncpu32k_elf_howto_table[i].name != NULL
+	&& strcasecmp (ncpu32k_elf_howto_table[i].name, r_name) == 0)
+      return &ncpu32k_elf_howto_table[i];
+
+  return NULL;
+}
+
+/* Set the howto pointer for an ncpu32k ELF reloc.  */
+
+static bfd_boolean
+ncpu32k_info_to_howto_rela (bfd * abfd,
+			 arelent * cache_ptr,
+			 Elf_Internal_Rela * dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  if (r_type >= (unsigned int) R_NCPU32K_max)
+    {
+      /* xgettext:c-format */
+      _bfd_error_handler (_("%pB: unsupported relocation type %#x"),
+			  abfd, r_type);
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }
+  cache_ptr->howto = & ncpu32k_elf_howto_table[r_type];
+  return TRUE;
+}
+
+
+/* Return the relocation value for @tpoff relocations..  */
+static bfd_vma
+tpoff (struct bfd_link_info *info, bfd_vma address)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+
+  /* The thread pointer on ncpu32k stores the address after the TCB where
+     the data is, just compute the difference. No need to compensate
+     for the size of TCB.  */
+  return (address - elf_hash_table (info)->tls_sec->vma);
+}
+
+/* Like _bfd_final_link_relocate, but handles non-contiguous fields.  */
+
+static bfd_reloc_status_type
+ncpu32k_final_link_relocate (reloc_howto_type *howto, bfd *input_bfd,
+			  asection *input_section, bfd_byte *contents,
+			  bfd_vma offset, bfd_vma value)
+{
+  bfd_reloc_status_type status = bfd_reloc_ok;
+  int size = bfd_get_reloc_size (howto);
+  bfd_vma x, place;
+
+  /* Sanity check the address.  */
+  if (offset + size > bfd_get_section_limit_octets (input_bfd, input_section))
+    return bfd_reloc_outofrange;
+
+  place = (input_section->output_section->vma
+	   + input_section->output_offset
+	   + (howto->pcrel_offset ? offset : 0));
+
+  switch (howto->type)
+    {
+    case R_NCPU32K_INSN_REL26:
+      value -= place;
+      /* Diagnose mis-aligned (non 4 byte) branch targets.  */
+      if (value & 0x3)
+	status = bfd_reloc_dangerous;
+      break;
+
+    default:
+      if (howto->pc_relative)
+	value -= place;
+      break;
+    }
+
+  status = bfd_check_overflow (howto->complain_on_overflow,
+			       howto->bitsize,
+			       howto->rightshift,
+			       bfd_arch_bits_per_address (input_bfd),
+			       value);
+  value >>= howto->rightshift;
+
+  /* If we're overwriting the entire destination,
+     then no need to read the current contents.  */
+  if (size == 0 || howto->dst_mask == N_ONES (size))
+    x = 0;
+  else
+    {
+      BFD_ASSERT (size == 4);
+      x = bfd_get_32 (input_bfd, contents + offset);
+    }
+
+  switch (howto->type)
+    {
+    default:
+      {
+	bfd_vma fieldmask = howto->dst_mask;
+	value <<= howto->bitpos;
+	x = (x & ~fieldmask) | (value & fieldmask);
+      }
+      break;
+    }
+
+  /* Put the relocated value back in the object file.  */
+  switch (size)
+    {
+    case 0:
+      break;
+    case 1:
+      bfd_put_8 (input_bfd, x, contents + offset);
+      break;
+    case 2:
+      bfd_put_16 (input_bfd, x, contents + offset);
+      break;
+    case 4:
+      bfd_put_32 (input_bfd, x, contents + offset);
+      break;
+#ifdef BFD64
+    case 8:
+      bfd_put_64 (input_bfd, x, contents + offset);
+      break;
+#endif
+    default:
+      _bfd_error_handler
+	(_("%pB: Cannot handle relocation value size of %d"),
+	 input_bfd, size);
+      abort ();
+    }
+  return status;
+}
+
+/* Relocate an ncpu32k ELF section.
+
+   The RELOCATE_SECTION function is called by the new ELF backend linker
+   to handle the relocations for a section.
+
+   The relocs are always passed as Rela structures; if the section
+   actually uses Rel structures, the r_addend field will always be
+   zero.
+
+   This function is responsible for adjusting the section contents as
+   necessary, and (if using Rela relocs and generating a relocatable
+   output file) adjusting the reloc addend as necessary.
+
+   This function does not have to worry about setting the reloc
+   address or the reloc symbol index.
+
+   LOCAL_SYMS is a pointer to the swapped in local symbols.
+
+   LOCAL_SECTIONS is an array giving the section in the input file
+   corresponding to the st_shndx field of each local symbol.
+
+   The global hash table entry for the global symbols can be found
+   via elf_sym_hashes (input_bfd).
+
+   When generating relocatable output, this function must handle
+   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
+   going to be the section symbol corresponding to the output
+   section, which means that the addend must be adjusted
+   accordingly.  */
+
+static bfd_boolean
+ncpu32k_elf_relocate_section (bfd *output_bfd,
+			   struct bfd_link_info *info,
+			   bfd *input_bfd,
+			   asection *input_section,
+			   bfd_byte *contents,
+			   Elf_Internal_Rela *relocs,
+			   Elf_Internal_Sym *local_syms,
+			   asection **local_sections)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+  struct elf_ncpu32k_link_hash_table *htab = ncpu32k_elf_hash_table (info);
+  bfd *dynobj;
+  asection *sreloc;
+  bfd_vma *local_got_offsets;
+  asection *sgot, *splt;
+  bfd_vma plt_base, got_base, got_sym_value;
+  bfd_boolean ret_val = TRUE;
+
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+  local_got_offsets = elf_local_got_offsets (input_bfd);
+
+  sreloc = elf_section_data (input_section)->sreloc;
+
+  splt = htab->root.splt;
+  plt_base = 0;
+  if (splt != NULL)
+    plt_base = splt->output_section->vma + splt->output_offset;
+
+  sgot = htab->root.sgot;
+  got_sym_value = got_base = 0;
+  if (sgot != NULL)
+    {
+      struct elf_link_hash_entry *hgot = htab->root.hgot;
+      got_sym_value = (hgot->root.u.def.value
+		       + hgot->root.u.def.section->output_section->vma
+		       + hgot->root.u.def.section->output_offset);
+    got_base = sgot->output_section->vma + sgot->output_offset;
+    }
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+  relend = relocs + input_section->reloc_count;
+
+  for (rel = relocs; rel < relend; rel++)
+    {
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      struct elf_link_hash_entry *h;
+      bfd_vma relocation;
+      bfd_reloc_status_type r;
+      const char *name = NULL;
+      int r_type;
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      if (r_type == R_NCPU32K_GNU_VTINHERIT
+	  || r_type == R_NCPU32K_GNU_VTENTRY)
+	continue;
+
+      if (r_type < 0 || r_type >= (int) R_NCPU32K_max)
+	{
+	  _bfd_error_handler
+	    (_("%pB: unknown relocation type %d"),
+	     input_bfd, (int) r_type);
+	  bfd_set_error (bfd_error_bad_value);
+	  ret_val = FALSE;
+	  continue;
+	}
+
+      howto = ncpu32k_elf_howto_table + ELF32_R_TYPE (rel->r_info);
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+
+	  name = bfd_elf_string_from_elf_section
+	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
+	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
+	}
+      else
+	{
+	  bfd_boolean unresolved_reloc, warned, ignored;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned, ignored);
+	  name = h->root.root.string;
+	}
+
+      if (sec != NULL && discarded_section (sec))
+	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+					 rel, 1, relend, howto, 0, contents);
+
+      if (bfd_link_relocatable (info))
+	continue;
+
+      switch (howto->type)
+	{
+	case R_NCPU32K_PLT_REL26:
+	  /* If the call is not local, redirect the branch to the PLT.
+	     Otherwise do nothing to send the branch to the symbol direct.  */
+	  if (!SYMBOL_CALLS_LOCAL (info, h)
+	      && h->plt.offset != (bfd_vma) -1)
+	    relocation = plt_base + h->plt.offset;
+
+	  /* Addend should be zero.  */
+	  if (rel->r_addend != 0)
+	    {
+	      _bfd_error_handler
+		(_("%pB: addend should be zero for plt relocations"),
+		 input_bfd);
+	      bfd_set_error (bfd_error_bad_value);
+	      ret_val = FALSE;
+	    }
+	  break;
+	
+	case R_NCPU32K_GOTOFF_HI18:
+	case R_NCPU32K_GOTOFF_LO14:
+	  /* Relocation is offset from GOT.  */
+	  BFD_ASSERT (sgot != NULL);
+	  if (!SYMBOL_REFERENCES_LOCAL (info, h))
+	    {
+	      _bfd_error_handler
+		(_("%pB: gotoff relocation against dynamic symbol %s"),
+		 input_bfd, h->root.root.string);
+	      ret_val = FALSE;
+	      bfd_set_error (bfd_error_bad_value);
+	    }
+	  relocation -= got_sym_value;
+	  break;
+	  
+	case R_NCPU32K_GOT14:
+	  {
+	    bfd_vma off;
+
+	    /* Relocation is to the entry for this symbol
+	       in the global offset table.  */
+	  BFD_ASSERT (sgot != NULL);
+	  if (h != NULL)
+	    {
+	      bfd_boolean dyn;
+
+	      off = h->got.offset;
+	      BFD_ASSERT (off != (bfd_vma) -1);
+
+	      dyn = htab->root.dynamic_sections_created;
+	      
+	      /* Is this actually a static link, or it is a -Bsymbolic
+	         link and the symbol is defined locally, or the symbol
+	         was forced to be local because of a version file?
+	       */
+	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,
+						     bfd_link_pic (info),
+						     h)
+		  || (bfd_link_pic (info)
+		      && SYMBOL_REFERENCES_LOCAL (info, h)))
+		{
+		    /* 
+		       We must initialize this entry in the GOT.  Since the
+		       offset must always be a multiple of 4, we use the least
+		       significant bit to record whether we have initialized
+		       it already.
+
+		     When doing a dynamic link, we create a .rela.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+		  if ((off & 1) != 0)
+		    off &= ~1;
+		  else
+		    {
+		      /* Write entry in GOT.  */
+		      bfd_put_32 (output_bfd, relocation,
+				  sgot->contents + off);
+		      /* Mark GOT entry as having been written.  */
+		      h->got.offset |= 1;
+		    }
+		}
+	    }
+	  else
+	    {
+	      bfd_byte *loc;
+
+	      BFD_ASSERT (local_got_offsets != NULL
+			  && local_got_offsets[r_symndx] != (bfd_vma) -1);
+
+	      /* Get offset into GOT table.  */
+	      off = local_got_offsets[r_symndx];
+
+	      /* The offset must always be a multiple of 4.  We use
+		 the least significant bit to record whether we have
+		 already processed this entry.  */
+	      if ((off & 1) != 0)
+		off &= ~1;
+	      else
+		{
+		  /* Write entry in GOT.  */
+		  bfd_put_32 (output_bfd, relocation, sgot->contents + off);
+		  if (bfd_link_pic (info))
+		    {
+		      asection *srelgot;
+		      Elf_Internal_Rela outrel;
+
+		      /* We need to generate a R_NCPU32K_RELATIVE reloc
+			 for the dynamic linker.  */
+			srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
+		      BFD_ASSERT (srelgot != NULL);
+
+		      outrel.r_offset = got_base + off;
+		      outrel.r_info = ELF32_R_INFO (0, R_NCPU32K_RELATIVE);
+		      outrel.r_addend = relocation;
+		      loc = srelgot->contents;
+			loc += (srelgot->reloc_count
+				* sizeof (Elf32_External_Rela));
+		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);
+		      ++srelgot->reloc_count;
+		    }
+		  local_got_offsets[r_symndx] |= 1;
+		}
+	    }
+
+	  /* The GOT14 reloc is GOT relative.  */
+	  relocation = got_base + off;
+	  if (r_type == R_NCPU32K_GOT14)
+	    relocation -= got_sym_value;
+
+	  /* Addend should be zero.  */
+	  if (rel->r_addend != 0)
+	    {
+	      _bfd_error_handler
+		(_("%pB: addend should be zero for got relocations"),
+		 input_bfd);
+	      bfd_set_error (bfd_error_bad_value);
+	      ret_val = FALSE;
+	    }
+	  }
+	  break;
+	  
+	case R_NCPU32K_INSN_REL26:
+	  /* For a non-shared link, these will reference either the plt
+	     or a .dynbss copy of the symbol.  */
+	  if (bfd_link_pic (info) && !SYMBOL_REFERENCES_LOCAL (info, h))
+	    {
+	      _bfd_error_handler
+		(_("%pB: pc-relative relocation against dynamic symbol %s"),
+		 input_bfd, name);
+	      ret_val = FALSE;
+	      bfd_set_error (bfd_error_bad_value);
+	    }
+	  break;
+
+	case R_NCPU32K_32:
+	  /* R_NCPU32K_16? */
+	  {
+	    /* r_symndx will be STN_UNDEF (zero) only for relocs against symbols
+	       from removed linkonce sections, or sections discarded by
+	       a linker script.  */
+	    if (r_symndx == STN_UNDEF
+		|| (input_section->flags & SEC_ALLOC) == 0)
+	      break;
+
+	    /* Emit a direct relocation if the symbol is dynamic,
+	       or a RELATIVE reloc for shared objects.  We can omit
+	       RELATIVE relocs to local undefweak symbols.  */
+	    if (bfd_link_pic (info)
+		? (h == NULL
+		     || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
+		     || h->root.type != bfd_link_hash_undefweak)
+		: (h != NULL
+		    && h->dynindx != -1
+		    && !h->non_got_ref
+		   && ((h->def_dynamic && !h->def_regular)
+			|| h->root.type == bfd_link_hash_undefweak
+			|| h->root.type == bfd_link_hash_undefined)))
+	      {
+		Elf_Internal_Rela outrel;
+		bfd_byte *loc;
+		bfd_boolean skip;
+
+		/* When generating a shared object, these relocations
+		   are copied into the output file to be resolved at run
+		   time.  */
+
+		BFD_ASSERT (sreloc != NULL);
+
+		skip = FALSE;
+
+		outrel.r_offset =
+		  _bfd_elf_section_offset (output_bfd, info, input_section,
+					   rel->r_offset);
+		if (outrel.r_offset == (bfd_vma) -1)
+		  skip = TRUE;
+		else if (outrel.r_offset == (bfd_vma) -2)
+		  skip = TRUE;
+		outrel.r_offset += (input_section->output_section->vma
+				    + input_section->output_offset);
+
+		if (skip)
+		  memset (&outrel, 0, sizeof outrel);
+		else if (SYMBOL_REFERENCES_LOCAL (info, h))
+		  {
+		    outrel.r_info = ELF32_R_INFO (0, R_NCPU32K_RELATIVE);
+		    outrel.r_addend = relocation + rel->r_addend;
+		  }
+		else
+		  {
+		    BFD_ASSERT (h->dynindx != -1);
+		    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
+		    outrel.r_addend = rel->r_addend;
+		  }
+
+		loc = sreloc->contents;
+		loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
+		bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
+		break;
+	      }
+	    break;
+	  }
+
+	default:
+	  break;
+	}
+
+      r = ncpu32k_final_link_relocate (howto, input_bfd, input_section, contents,
+				    rel->r_offset, relocation + rel->r_addend);
+
+      if (r != bfd_reloc_ok)
+	{
+	  const char *msg = NULL;
+
+	  switch (r)
+	    {
+	    case bfd_reloc_overflow:
+	      (*info->callbacks->reloc_overflow)
+		(info, (h ? &h->root : NULL), name, howto->name,
+		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
+	      break;
+
+	    case bfd_reloc_undefined:
+	      (*info->callbacks->undefined_symbol)
+		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
+	      break;
+
+	    case bfd_reloc_outofrange:
+	      msg = _("internal error: out of range error");
+	      break;
+
+	    case bfd_reloc_notsupported:
+	      msg = _("internal error: unsupported relocation error");
+	      break;
+
+	    case bfd_reloc_dangerous:
+	      msg = _("internal error: dangerous relocation");
+	      break;
+
+	    default:
+	      msg = _("internal error: unknown error");
+	      break;
+	    }
+
+	  if (msg)
+	    (*info->callbacks->warning) (info, msg, name, input_bfd,
+					 input_section, rel->r_offset);
+	}
+    }
+
+  return ret_val;
+}
+
+/* Return the section that should be marked against GC for a given
+   relocation.  */
+
+static asection *
+ncpu32k_elf_gc_mark_hook (asection *sec,
+		       struct bfd_link_info *info,
+		       Elf_Internal_Rela *rel,
+		       struct elf_link_hash_entry *h,
+		       Elf_Internal_Sym *sym)
+{
+  if (h != NULL)
+    switch (ELF32_R_TYPE (rel->r_info))
+      {
+      case R_NCPU32K_GNU_VTINHERIT:
+      case R_NCPU32K_GNU_VTENTRY:
+	return NULL;
+      }
+
+  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
+}
+
+/* Look through the relocs for a section during the first phase.  */
+
+static bfd_boolean
+ncpu32k_elf_check_relocs (bfd *abfd,
+		       struct bfd_link_info *info,
+		       asection *sec,
+		       const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+
+  const Elf_Internal_Rela *rel_end;
+  struct elf_ncpu32k_link_hash_table *htab;
+  bfd *dynobj;
+  asection *sreloc = NULL;
+
+  if (bfd_link_relocatable (info))
+    return TRUE;
+
+  /* Don't do anything special with non-loaded, non-alloced sections.
+     In particular, any relocs in such sections should not affect GOT
+     and PLT reference counting (ie. we don't allow them to create GOT
+     or PLT entries), there's no possibility or desire to optimize TLS
+     relocs, and there's not much point in propagating relocs to shared
+     libs that the dynamic linker won't relocate.  */
+  if ((sec->flags & SEC_ALLOC) == 0)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      struct elf_link_hash_entry *h;
+      unsigned long r_symndx;
+      unsigned char tls_type;
+      int r_type;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx < symtab_hdr->sh_info)
+	h = NULL;
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      switch (r_type)
+	{
+	default:
+	  tls_type = TLS_NONE;
+	}
+
+      /* Record TLS type.  */
+      if (h != NULL)
+	  ((struct elf_ncpu32k_link_hash_entry *) h)->tls_type = tls_type;
+      else
+	{
+	  unsigned char *local_tls_type;
+
+	  /* This is a TLS type record for a local symbol.  */
+	  local_tls_type = (unsigned char *) elf_ncpu32k_local_tls_type (abfd);
+	  if (local_tls_type == NULL)
+	    {
+	      bfd_size_type size;
+
+	      size = symtab_hdr->sh_info;
+	      local_tls_type = bfd_zalloc (abfd, size);
+	      if (local_tls_type == NULL)
+		return FALSE;
+	      elf_ncpu32k_local_tls_type (abfd) = local_tls_type;
+	    }
+	  local_tls_type[r_symndx] = tls_type;
+	}
+
+      switch (r_type)
+	{
+	  /* This relocation describes the C++ object vtable hierarchy.
+	     Reconstruct it for later use during GC.  */
+	case R_NCPU32K_GNU_VTINHERIT:
+	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	  /* This relocation describes which C++ vtable entries are actually
+	     used.  Record for later use during GC.  */
+	case R_NCPU32K_GNU_VTENTRY:
+	  BFD_ASSERT (h != NULL);
+	  if (h != NULL
+	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+	    return FALSE;
+	  break;
+
+	case R_NCPU32K_INSN_REL26:
+	case R_NCPU32K_32:
+	  {
+	    if (h != NULL && !bfd_link_pic (info))
+	      {
+		/* We may need a copy reloc.  */
+		h->non_got_ref = 1;
+
+		/* We may also need a .plt entry.  */
+		h->plt.refcount += 1;
+		if (r_type != R_NCPU32K_INSN_REL26)
+		  h->pointer_equality_needed = 1;
+	      }
+
+	    /* If we are creating a shared library, and this is a reloc
+	       against a global symbol, or a non PC relative reloc
+	       against a local symbol, then we need to copy the reloc
+	       into the shared library.  However, if we are linking with
+	       -Bsymbolic, we do not need to copy a reloc against a
+	       global symbol which is defined in an object we are
+	       including in the link (i.e., DEF_REGULAR is set).  At
+	       this point we have not seen all the input files, so it is
+	       possible that DEF_REGULAR is not set now but will be set
+	       later (it is never cleared).  In case of a weak definition,
+	       DEF_REGULAR may be cleared later by a strong definition in
+	       a shared library.  We account for that possibility below by
+	       storing information in the relocs_copied field of the hash
+	       table entry.  A similar situation occurs when creating
+	       shared libraries and symbol visibility changes render the
+	       symbol local.
+
+	       If on the other hand, we are creating an executable, we
+	       may need to keep relocations for symbols satisfied by a
+	       dynamic library if we manage to avoid copy relocs for the
+	       symbol.  */
+
+	    if ((bfd_link_pic (info)
+		 && (sec->flags & SEC_ALLOC) != 0
+		 && ((r_type != R_NCPU32K_INSN_REL26)
+		     || (h != NULL
+			 && (!SYMBOLIC_BIND (info, h)
+			     || h->root.type == bfd_link_hash_defweak
+			     || !h->def_regular))))
+		|| (!bfd_link_pic (info)
+		    && (sec->flags & SEC_ALLOC) != 0
+		    && h != NULL
+		    && (h->root.type == bfd_link_hash_defweak
+			|| !h->def_regular)))
+	      {
+		struct elf_dyn_relocs *p;
+		struct elf_dyn_relocs **head;
+
+		/* When creating a shared object, we must copy these
+		   relocs into the output file.  We create a reloc
+		   section in dynobj and make room for the reloc.  */
+		if (sreloc == NULL)
+		  {
+		    const char *name;
+		    unsigned int strndx = elf_elfheader (abfd)->e_shstrndx;
+		    unsigned int shnam = _bfd_elf_single_rel_hdr (sec)->sh_name;
+
+		    name = bfd_elf_string_from_elf_section (abfd, strndx, shnam);
+		    if (name == NULL)
+		      return FALSE;
+
+		    if (strncmp (name, ".rela", 5) != 0
+			|| strcmp (bfd_get_section_name (abfd, sec),
+				   name + 5) != 0)
+		      {
+			_bfd_error_handler
+			  /* xgettext:c-format */
+			  (_("%pB: bad relocation section name `%s\'"),
+			   abfd, name);
+		      }
+
+		    if (htab->root.dynobj == NULL)
+		      htab->root.dynobj = abfd;
+		    dynobj = htab->root.dynobj;
+
+		    sreloc = bfd_get_section_by_name (dynobj, name);
+		    if (sreloc == NULL)
+		      {
+			sreloc = _bfd_elf_make_dynamic_reloc_section
+			  (sec, dynobj, 2, abfd, /*rela?*/ TRUE);
+
+			if (sreloc == NULL)
+			  return FALSE;
+		      }
+		    elf_section_data (sec)->sreloc = sreloc;
+		  }
+
+		/* If this is a global symbol, we count the number of
+		   relocations we need for this symbol.  */
+		if (h != NULL)
+		  head = &((struct elf_ncpu32k_link_hash_entry *) h)->dyn_relocs;
+		else
+		  {
+		    /* Track dynamic relocs needed for local syms too.
+		       We really need local syms available to do this
+		       easily.  Oh well.  */
+
+		    asection *s;
+		    Elf_Internal_Sym *isym;
+		    void *vpp;
+
+		    isym = bfd_sym_from_r_symndx (&htab->sym_sec,
+						  abfd, r_symndx);
+		    if (isym == NULL)
+		      return FALSE;
+
+		    s = bfd_section_from_elf_index (abfd, isym->st_shndx);
+		    if (s == NULL)
+		      return FALSE;
+
+		    vpp = &elf_section_data (s)->local_dynrel;
+		    head = (struct elf_dyn_relocs **) vpp;
+		  }
+
+		p = *head;
+		if (p == NULL || p->sec != sec)
+		  {
+		    bfd_size_type amt = sizeof *p;
+		    p = ((struct elf_dyn_relocs *)
+			 bfd_alloc (htab->root.dynobj, amt));
+		    if (p == NULL)
+		      return FALSE;
+		    p->next = *head;
+		    *head = p;
+		    p->sec = sec;
+		    p->count = 0;
+		    p->pc_count = 0;
+		  }
+
+		p->count += 1;
+		if (r_type == R_NCPU32K_INSN_REL26)
+		  p->pc_count += 1;
+	      }
+	  }
+	  break;
+	  
+	  /* needs plt */
+	case R_NCPU32K_PLT_REL26:
+	  if (h != NULL)
+	    {
+	      h->needs_plt = 1;
+	      h->plt.refcount += 1;
+	    }
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Generate instructions of PLT */
+
+#define NCPU32K_ROP_INSN32(RS2,RS1,RD,OPC)	((OPC) | ((RD) << 6) | ((RS1) << 12) | ((RS2) << 18))
+#define NCPU32K_IMM14_INSN32(IMM,RS1,RD,OPC)	((OPC) | ((RD) << 6) | ((RS1) << 12) | ((IMM) << 18))
+#define NCPU32K_IMM18_INSN32(IMM,RD,OPC)	((OPC) | ((RD) << 6) | ((IMM) << 12))
+#define NCPU32K_REL26_INSN32(REL,OPC)		((OPC) | ((REL) << 6))
+
+#define NCPU32K_MHI(RD,IMM)		NCPU32K_IMM18_INSN32(IMM, RD,0x0000002a)
+#define NCPU32K_LDWU(RD,A,IMM)		NCPU32K_IMM14_INSN32(IMM, A,RD,0x0000000f)
+#define NCPU32K_MOV(RD,IMM)		NCPU32K_IMM14_INSN32(IMM, 0,RD,0x0000001d) /* add.i */
+#define NCPU32K_JMP(RS)			NCPU32K_ROP_INSN32(0, RS, NCPU32K_NREG_LNK,0x000a)
+#define NCPU32K_AND_I(RD,RS1,IMM)	NCPU32K_IMM14_INSN32(IMM, RS1,	RD,0x0001)
+
+/* Finish up the dynamic sections.  */
+
+static bfd_boolean
+ncpu32k_elf_finish_dynamic_sections (bfd *output_bfd,
+				  struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  asection *sdyn, *sgot;
+  struct elf_ncpu32k_link_hash_table *htab;
+
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+
+  sgot = htab->root.sgotplt;
+  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+
+  if (htab->root.dynamic_sections_created)
+    {
+      asection *splt;
+      Elf32_External_Dyn *dyncon, *dynconend;
+
+      BFD_ASSERT (sgot != NULL && sdyn != NULL);
+
+      dyncon = (Elf32_External_Dyn *) sdyn->contents;
+      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
+
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+	  asection *s;
+
+	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      continue;
+
+	    case DT_PLTGOT:
+	      s = htab->root.sgotplt;
+	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	      break;
+
+	    case DT_JMPREL:
+	      s = htab->root.srelplt;
+	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	      break;
+
+	    case DT_PLTRELSZ:
+	      s = htab->root.srelplt;
+	      dyn.d_un.d_val = s->size;
+	      break;
+	    }
+	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+	}
+
+
+      /* Fill in the first entry in the procedure linkage table.  */
+      splt = htab->root.splt;
+      if (splt && splt->size > 0)
+	{
+	  bfd_vma got_addr = sgot->output_section->vma + sgot->output_offset;
+
+	  /* clobber r15 to store the jmp address. */
+
+	  if (bfd_link_pic (info))
+	    {
+	      /* load GOT[2] */
+	      bfd_put_32 (output_bfd, NCPU32K_LDWU(15, NCPU32K_NREG_GOT, 8), splt->contents);
+	      /* load GOT[1] */
+	      bfd_put_32 (output_bfd, NCPU32K_LDWU(NCPU32K_NREG_RVH, NCPU32K_NREG_GOT, 4), splt->contents);
+	    }
+	  else
+	    {
+	      unsigned sh = ((got_addr + 0x2000) >> 14) & 0x3ffff;
+	      unsigned lo = got_addr & 0x3fff;
+	      bfd_put_32 (output_bfd, NCPU32K_MHI(NCPU32K_NREG_RVH, sh), splt->contents);
+	      /* load GOT[2] */
+	      bfd_put_32 (output_bfd, NCPU32K_LDWU(15,NCPU32K_NREG_RVH, lo + 8), splt->contents);
+	      /* load GOT[1] */
+	      bfd_put_32 (output_bfd, NCPU32K_LDWU(NCPU32K_NREG_RVH,NCPU32K_NREG_RVH, lo + 4), splt->contents);
+	    }
+
+	  bfd_put_16 (output_bfd, NCPU32K_JMP(15), splt->contents);
+
+	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;
+	}
+    }
+
+  /* Set the first entry in the global offset table to the address of
+     the dynamic section.  */
+  if (sgot && sgot->size > 0)
+    {
+      if (sdyn == NULL)
+	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
+      else
+	bfd_put_32 (output_bfd,
+		    sdyn->output_section->vma + sdyn->output_offset,
+		    sgot->contents);
+      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
+    }
+
+  if (htab->root.sgot && htab->root.sgot->size > 0)
+    elf_section_data (htab->root.sgot->output_section)->this_hdr.sh_entsize = 4;
+
+  return TRUE;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static bfd_boolean
+ncpu32k_elf_finish_dynamic_symbol (bfd *output_bfd,
+				struct bfd_link_info *info,
+				struct elf_link_hash_entry *h,
+				Elf_Internal_Sym *sym)
+{
+  struct elf_ncpu32k_link_hash_table *htab;
+  bfd_byte *loc;
+
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  if (h->plt.offset != (bfd_vma) -1)
+    {
+      asection *splt;
+      asection *sgot;
+      asection *srela;
+      bfd_vma plt_base_addr;
+      bfd_vma plt_addr;
+      bfd_vma plt_index;
+      bfd_vma plt_reloc;
+      bfd_vma got_base_addr;
+      bfd_vma got_offset;
+      bfd_vma got_addr;
+      Elf_Internal_Rela rela;
+
+      /* This symbol has an entry in the procedure linkage table.  Set
+	 it up.  */
+      BFD_ASSERT (h->dynindx != -1);
+
+      splt = htab->root.splt;
+      sgot = htab->root.sgotplt;
+      srela = htab->root.srelplt;
+      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);
+
+      plt_base_addr = splt->output_section->vma + splt->output_offset;
+      got_base_addr = sgot->output_section->vma + sgot->output_offset;
+
+      /* Get the index in the procedure linkage table which
+	 corresponds to this symbol.  This is the index of this symbol
+	 in all the symbols for which we are making plt entries.  The
+	 first entry in the procedure linkage table is reserved.  */
+      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
+      plt_addr = plt_base_addr + h->plt.offset;
+      plt_reloc = plt_index * sizeof (Elf32_External_Rela);
+
+      /* Get the offset into the .got table of the entry that
+	corresponds to this function.  Each .got entry is 4 bytes.
+	The first three are reserved.  */
+      got_offset = (plt_index + 3) * 4;
+      got_addr = got_base_addr + got_offset;
+
+      /* Fill in the entry in the procedure linkage table.  */
+      if (bfd_link_pic (info))
+	{
+	  bfd_put_32 (output_bfd, NCPU32K_LDWU(NCPU32K_NREG_RVH,NCPU32K_NREG_GOT, got_offset), splt->contents + h->plt.offset);
+	  bfd_put_32 (output_bfd, NCPU32K_MOV(NCPU32K_NREG_RV, plt_reloc), splt->contents + h->plt.offset);
+	}
+      else
+	{
+	  unsigned sh = ((got_addr + 0x2000) >> 14) & 0x3ffff;
+	  unsigned lo = got_addr & 0x3fff;
+	  bfd_put_32 (output_bfd, NCPU32K_MHI(NCPU32K_NREG_RVH, sh), splt->contents + h->plt.offset);
+	  bfd_put_32 (output_bfd, NCPU32K_LDWU(NCPU32K_NREG_RVH,NCPU32K_NREG_RVH,lo), splt->contents + h->plt.offset);
+	  bfd_put_32 (output_bfd, NCPU32K_MOV(NCPU32K_NREG_RV, plt_reloc), splt->contents + h->plt.offset);
+	}
+
+      bfd_put_32 (output_bfd, NCPU32K_JMP(NCPU32K_NREG_RVH), splt->contents + h->plt.offset);
+
+
+      /* Fill in the entry in the global offset table.  */
+      bfd_put_32 (output_bfd, plt_addr, sgot->contents + got_offset);
+
+      /* Fill in the entry in the .rela.plt section.  */
+      rela.r_offset = got_addr;
+      rela.r_info = ELF32_R_INFO (h->dynindx, R_NCPU32K_JMP_SLOT);
+      rela.r_addend = 0;
+      loc = srela->contents;
+      loc += plt_index * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+
+      if (!h->def_regular)
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value alone.  */
+	  sym->st_shndx = SHN_UNDEF;
+	}
+    }
+
+  if (h->got.offset != (bfd_vma) -1
+      && (h->got.offset & 2) == 0) /* Homemade TLS check.  */
+    {
+      asection *sgot;
+      asection *srela;
+      Elf_Internal_Rela rela;
+
+      /* This symbol has an entry in the global offset table.  Set it
+	 up.  */
+      sgot = htab->root.sgot;
+      srela = htab->root.srelgot;
+      BFD_ASSERT (sgot != NULL && srela != NULL);
+
+      rela.r_offset = (sgot->output_section->vma
+		       + sgot->output_offset
+		       + (h->got.offset &~ 1));
+
+      /* If this is a -Bsymbolic link, and the symbol is defined
+	 locally, we just want to emit a RELATIVE reloc.  Likewise if
+	 the symbol was forced to be local because of a version file.
+	 The entry in the global offset table will already have been
+	 initialized in the relocate_section function.  */
+      if (bfd_link_pic (info) && SYMBOL_REFERENCES_LOCAL (info, h))
+	{
+	  rela.r_info = ELF32_R_INFO (0, R_NCPU32K_RELATIVE);
+	  rela.r_addend = (h->root.u.def.value
+			   + h->root.u.def.section->output_section->vma
+			   + h->root.u.def.section->output_offset);
+	}
+      else
+	{
+	  BFD_ASSERT ((h->got.offset & 1) == 0);
+	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
+	  rela.r_info = ELF32_R_INFO (h->dynindx, R_NCPU32K_GLOB_DAT);
+	  rela.r_addend = 0;
+	}
+
+      loc = srela->contents;
+      loc += srela->reloc_count * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+      ++srela->reloc_count;
+    }
+
+  if (h->needs_copy)
+    {
+      asection *s;
+      Elf_Internal_Rela rela;
+
+      /* This symbols needs a copy reloc.  Set it up.  */
+      BFD_ASSERT (h->dynindx != -1
+		  && (h->root.type == bfd_link_hash_defined
+		      || h->root.type == bfd_link_hash_defweak));
+
+      rela.r_offset = (h->root.u.def.value
+		       + h->root.u.def.section->output_section->vma
+		       + h->root.u.def.section->output_offset);
+      rela.r_info = ELF32_R_INFO (h->dynindx, R_NCPU32K_COPY);
+      rela.r_addend = 0;
+      if (h->root.u.def.section == htab->root.sdynrelro)
+	s = htab->root.sreldynrelro;
+      else
+	s = htab->root.srelbss;
+      loc = s->contents + s->reloc_count * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+      ++s->reloc_count;
+    }
+
+  /* Mark some specially defined symbols as absolute.  */
+  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
+      || h == htab->root.hgot)
+    sym->st_shndx = SHN_ABS;
+
+  return TRUE;
+}
+
+static enum elf_reloc_type_class
+ncpu32k_elf_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
+			   const asection *rel_sec ATTRIBUTE_UNUSED,
+			   const Elf_Internal_Rela *rela)
+{
+  switch ((int) ELF32_R_TYPE (rela->r_info))
+    {
+    case R_NCPU32K_RELATIVE:	return reloc_class_relative;
+    case R_NCPU32K_JMP_SLOT:	return reloc_class_plt;
+    case R_NCPU32K_COPY:	return reloc_class_copy;
+    default:			return reloc_class_normal;
+    }
+}
+
+/* Find dynamic relocs for H that apply to read-only sections.  */
+
+static asection *
+readonly_dynrelocs (struct elf_link_hash_entry *h)
+{
+  struct elf_dyn_relocs *p;
+  struct elf_ncpu32k_link_hash_entry *eh = (struct elf_ncpu32k_link_hash_entry *) h;
+
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *s = p->sec->output_section;
+
+      if (s != NULL && (s->flags & SEC_READONLY) != 0)
+	return p->sec;
+    }
+  return NULL;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+ncpu32k_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
+				struct elf_link_hash_entry *h)
+{
+  struct elf_ncpu32k_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s, *srel;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+	      && (h->needs_plt
+		  || h->is_weakalias
+		  || (h->def_dynamic
+		      && h->ref_regular
+		      && !h->def_regular)));
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later,
+     when we know the address of the .got section.  */
+  if (h->type == STT_FUNC
+      || h->needs_plt)
+    {
+      if (! bfd_link_pic (info)
+	  && !h->def_dynamic
+	  && !h->ref_dynamic
+	  && h->root.type != bfd_link_hash_undefweak
+	  && h->root.type != bfd_link_hash_undefined)
+	{
+	  /* This case can occur if we saw a PLT reloc in an input
+	     file, but the symbol was never referred to by a dynamic
+	     object.  In such a case, we don't actually need to build
+	     a procedure linkage table, and we can just do a PCREL
+	     reloc instead.  */
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+
+      return TRUE;
+    }
+  else
+    h->plt.offset = (bfd_vma) -1;
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->is_weakalias)
+    {
+      struct elf_link_hash_entry *def = weakdef (h);
+      BFD_ASSERT (def->root.type == bfd_link_hash_defined);
+      h->root.u.def.section = def->root.u.def.section;
+      h->root.u.def.value = def->root.u.def.value;
+      return TRUE;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (bfd_link_pic (info))
+    return TRUE;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (!h->non_got_ref)
+    return TRUE;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  /* If we don't find any dynamic relocs in read-only sections, then
+     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
+  if (!readonly_dynrelocs (h))
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  /* We must generate a R_NCPU32K_COPY reloc to tell the dynamic linker
+     to copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
+     .rela.bss section we are going to use.  */
+  if ((h->root.u.def.section->flags & SEC_READONLY) != 0)
+    {
+      s = htab->root.sdynrelro;
+      srel = htab->root.sreldynrelro;
+    }
+  else
+    {
+      s = htab->root.sdynbss;
+      srel = htab->root.srelbss;
+    }
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
+    {
+      srel->size += sizeof (Elf32_External_Rela);
+      h->needs_copy = 1;
+    }
+
+  return _bfd_elf_adjust_dynamic_copy (info, h, s);
+}
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   dynamic relocs.  */
+
+static bfd_boolean
+allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
+{
+  struct bfd_link_info *info;
+  struct elf_ncpu32k_link_hash_table *htab;
+  struct elf_ncpu32k_link_hash_entry *eh;
+  struct elf_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  info = (struct bfd_link_info *) inf;
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  eh = (struct elf_ncpu32k_link_hash_entry *) h;
+
+  if (htab->root.dynamic_sections_created
+      && h->plt.refcount > 0)
+    {
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h))
+	{
+	  asection *s = htab->root.splt;
+
+	  /* If this is the first .plt entry, make room for the special
+	     first entry.  */
+	  if (s->size == 0)
+	    s->size = PLT_ENTRY_SIZE;
+
+	  h->plt.offset = s->size;
+
+	  /* If this symbol is not defined in a regular file, and we are
+	     not generating a shared library, then set the symbol to this
+	     location in the .plt.  This is required to make function
+	     pointers compare as equal between the normal executable and
+	     the shared library.  */
+	  if (! bfd_link_pic (info)
+	      && !h->def_regular)
+	    {
+	      h->root.u.def.section = s;
+	      h->root.u.def.value = h->plt.offset;
+	    }
+
+	  /* Make room for this entry.  */
+	  s->size += PLT_ENTRY_SIZE;
+
+	  /* We also need to make an entry in the .got.plt section, which
+	     will be placed in the .got section by the linker script.  */
+	  htab->root.sgotplt->size += 4;
+
+	  /* We also need to make an entry in the .rel.plt section.  */
+	  htab->root.srelplt->size += sizeof (Elf32_External_Rela);
+	}
+      else
+	{
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+    }
+  else
+    {
+      h->plt.offset = (bfd_vma) -1;
+      h->needs_plt = 0;
+    }
+
+  if (h->got.refcount > 0)
+    {
+      asection *s;
+      bfd_boolean dyn;
+      unsigned char tls_type;
+
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      s = htab->root.sgot;
+
+      h->got.offset = s->size;
+
+      tls_type = ((struct elf_ncpu32k_link_hash_entry *) h)->tls_type;
+
+      /* TLS GD requires two GOT and two relocs.  */
+      if (tls_type == TLS_GD)
+	s->size += 8;
+      else
+	s->size += 4;
+      dyn = htab->root.dynamic_sections_created;
+      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h))
+	{
+	  if (tls_type == TLS_GD)
+	    htab->root.srelgot->size += 2 * sizeof (Elf32_External_Rela);
+	  else
+	    htab->root.srelgot->size += sizeof (Elf32_External_Rela);
+	}
+    }
+  else
+    h->got.offset = (bfd_vma) -1;
+
+  if (eh->dyn_relocs == NULL)
+    return TRUE;
+
+  /* In the shared -Bsymbolic case, discard space allocated for
+     dynamic pc-relative relocs against symbols which turn out to be
+     defined in regular objects.  For the normal shared case, discard
+     space for pc-relative relocs that have become local due to symbol
+     visibility changes.  */
+
+  if (bfd_link_pic (info))
+    {
+      if (SYMBOL_CALLS_LOCAL (info, h))
+	{
+	  struct elf_dyn_relocs **pp;
+
+	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)
+	    {
+	      p->count -= p->pc_count;
+	      p->pc_count = 0;
+	      if (p->count == 0)
+		*pp = p->next;
+	      else
+		pp = &p->next;
+	    }
+	}
+
+      /* Also discard relocs on undefined weak syms with non-default
+	 visibility.  */
+      if (eh->dyn_relocs != NULL
+	  && h->root.type == bfd_link_hash_undefweak)
+	{
+	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
+	    eh->dyn_relocs = NULL;
+
+	  /* Make sure undefined weak symbols are output as a dynamic
+	     symbol in PIEs.  */
+	  else if (h->dynindx == -1
+		   && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+	}
+    }
+  else
+    {
+      /* For the non-shared case, discard space for relocs against
+	 symbols which turn out to need copy relocs or are not
+	 dynamic.  */
+
+      if (!h->non_got_ref
+	  && ((h->def_dynamic
+	       && !h->def_regular)
+	      || (htab->root.dynamic_sections_created
+		  && (h->root.type == bfd_link_hash_undefweak
+		      || h->root.type == bfd_link_hash_undefined))))
+	{
+	  /* Make sure this symbol is output as a dynamic symbol.
+	     Undefined weak syms won't yet be marked as dynamic.  */
+	  if (h->dynindx == -1
+	      && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+
+	  /* If that succeeded, we know we'll be keeping all the
+	     relocs.  */
+	  if (h->dynindx != -1)
+	    goto keep;
+	}
+
+      eh->dyn_relocs = NULL;
+
+    keep: ;
+    }
+
+  /* Finally, allocate space.  */
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *sreloc = elf_section_data (p->sec)->sreloc;
+      sreloc->size += p->count * sizeof (Elf32_External_Rela);
+    }
+
+  return TRUE;
+}
+
+/* Set DF_TEXTREL if we find any dynamic relocs that apply to
+   read-only sections.  */
+
+static bfd_boolean
+maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
+{
+  asection *sec;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  sec = readonly_dynrelocs (h);
+  if (sec != NULL)
+    {
+      struct bfd_link_info *info = (struct bfd_link_info *) info_p;
+
+      info->flags |= DF_TEXTREL;
+      info->callbacks->minfo
+	(_("%pB: dynamic relocation against `%pT' in read-only section `%pA'\n"),
+	 sec->owner, h->root.root.string, sec);
+
+      /* Not an error, just cut short the traversal.  */
+      return FALSE;
+    }
+  return TRUE;
+}
+
+/* Set the sizes of the dynamic sections.  */
+
+static bfd_boolean
+ncpu32k_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
+				struct bfd_link_info *info)
+{
+  struct elf_ncpu32k_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd_boolean relocs;
+  bfd *ibfd;
+
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+  BFD_ASSERT (dynobj != NULL);
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (bfd_link_executable (info) && !info->nointerp)
+	{
+	  s = bfd_get_section_by_name (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
+	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
+	}
+    }
+
+  /* Set up .got offsets for local syms, and space for local dynamic
+     relocs.  */
+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link.next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_signed_vma *end_local_got;
+      bfd_size_type locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+      unsigned char *local_tls_type;
+      asection *srel;
+
+      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
+	continue;
+
+      for (s = ibfd->sections; s != NULL; s = s->next)
+	{
+	  struct elf_dyn_relocs *p;
+
+	  for (p = ((struct elf_dyn_relocs *)
+		    elf_section_data (s)->local_dynrel);
+	       p != NULL;
+	       p = p->next)
+	    {
+	      if (! bfd_is_abs_section (p->sec)
+		  && bfd_is_abs_section (p->sec->output_section))
+		{
+		  /* Input section has been discarded, either because
+		     it is a copy of a linkonce section or due to
+		     linker script /DISCARD/, so we'll be discarding
+		     the relocs too.  */
+		}
+	      else if (p->count != 0)
+		{
+		  srel = elf_section_data (p->sec)->sreloc;
+		  srel->size += p->count * sizeof (Elf32_External_Rela);
+		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
+		    info->flags |= DF_TEXTREL;
+		}
+	    }
+	}
+
+      local_got = elf_local_got_refcounts (ibfd);
+      if (!local_got)
+	continue;
+
+      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
+      locsymcount = symtab_hdr->sh_info;
+      end_local_got = local_got + locsymcount;
+      s = htab->root.sgot;
+      srel = htab->root.srelgot;
+      local_tls_type = (unsigned char *) elf_ncpu32k_local_tls_type (ibfd);
+      for (; local_got < end_local_got; ++local_got)
+	{
+	  if (*local_got > 0)
+	    {
+	      *local_got = s->size;
+
+	      /* TLS GD requires two GOT and two relocs.  */
+	      if (local_tls_type != NULL && *local_tls_type == TLS_GD)
+		s->size += 8;
+	      else
+		s->size += 4;
+	      if (bfd_link_pic (info))
+		{
+		  if (local_tls_type != NULL && *local_tls_type == TLS_GD)
+		    srel->size += 2 * sizeof (Elf32_External_Rela);
+		  else
+		    srel->size += sizeof (Elf32_External_Rela);
+		}
+	    }
+	  else
+
+	    *local_got = (bfd_vma) -1;
+
+	  if (local_tls_type)
+	    ++local_tls_type;
+	}
+    }
+
+  /* Allocate global sym .plt and .got entries, and space for global
+     sym dynamic relocs.  */
+  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);
+
+  /* We now have determined the sizes of the various dynamic sections.
+     Allocate memory for them.  */
+  relocs = FALSE;
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      if (s == htab->root.splt
+	  || s == htab->root.sgot
+	  || s == htab->root.sgotplt
+	  || s == htab->root.sdynbss
+	  || s == htab->root.sdynrelro)
+	{
+	  /* Strip this section if we don't need it; see the
+	     comment below.  */
+	}
+      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
+	{
+	  if (s->size != 0 && s != htab->root.srelplt)
+	    relocs = TRUE;
+
+	  /* We use the reloc_count field as a counter if we need
+	     to copy relocs into the output file.  */
+	  s->reloc_count = 0;
+	}
+      else
+	/* It's not one of our sections, so don't allocate space.  */
+	continue;
+
+      if (s->size == 0)
+	{
+	  /* If we don't need this section, strip it from the
+	     output file.  This is mostly to handle .rela.bss and
+	     .rela.plt.  We must create both sections in
+	     create_dynamic_sections, because they must be created
+	     before the linker maps input sections to output
+	     sections.  The linker does that before
+	     adjust_dynamic_symbol is called, and it is that
+	     function which decides whether anything needs to go
+	     into these sections.  */
+	  s->flags |= SEC_EXCLUDE;
+	  continue;
+	}
+
+      if ((s->flags & SEC_HAS_CONTENTS) == 0)
+	continue;
+
+      /* Allocate memory for the section contents.  We use bfd_zalloc
+	 here in case unused entries are not reclaimed before the
+	 section's contents are written out.  This should not happen,
+	 but this way if it does, we get a R_NCPU32K_NONE reloc instead
+	 of garbage.  */
+      s->contents = bfd_zalloc (dynobj, s->size);
+
+      if (s->contents == NULL)
+	return FALSE;
+    }
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in ncpu32k_elf_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) \
+  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
+
+     if (bfd_link_executable (info))
+       {
+	 if (! add_dynamic_entry (DT_DEBUG, 0))
+	   return FALSE;
+       }
+
+     if (htab->root.splt->size != 0)
+       {
+	 if (! add_dynamic_entry (DT_PLTGOT, 0)
+	     || ! add_dynamic_entry (DT_PLTRELSZ, 0)
+	     || ! add_dynamic_entry (DT_PLTREL, DT_RELA)
+	     || ! add_dynamic_entry (DT_JMPREL, 0))
+	   return FALSE;
+	}
+
+     if (relocs)
+       {
+	 if (! add_dynamic_entry (DT_RELA, 0)
+	     || ! add_dynamic_entry (DT_RELASZ, 0)
+	     || ! add_dynamic_entry (DT_RELAENT,
+				     sizeof (Elf32_External_Rela)))
+	   return FALSE;
+
+	 /* If any dynamic relocs apply to a read-only section,
+	    then we need a DT_TEXTREL entry.  */
+	 if ((info->flags & DF_TEXTREL) == 0)
+	   elf_link_hash_traverse (&htab->root, maybe_set_textrel, info);
+
+	 if ((info->flags & DF_TEXTREL) != 0)
+	   {
+	     if (! add_dynamic_entry (DT_TEXTREL, 0))
+	       return FALSE;
+	   }
+       }
+    }
+
+#undef add_dynamic_entry
+  return TRUE;
+}
+
+/* Copy the extra info we tack onto an elf_link_hash_entry.  */
+
+static void
+ncpu32k_elf_copy_indirect_symbol (struct bfd_link_info *info,
+			       struct elf_link_hash_entry *dir,
+			       struct elf_link_hash_entry *ind)
+{
+  struct elf_ncpu32k_link_hash_entry * edir;
+  struct elf_ncpu32k_link_hash_entry * eind;
+
+  edir = (struct elf_ncpu32k_link_hash_entry *) dir;
+  eind = (struct elf_ncpu32k_link_hash_entry *) ind;
+
+  if (eind->dyn_relocs != NULL)
+    {
+      if (edir->dyn_relocs != NULL)
+	{
+	  struct elf_dyn_relocs **pp;
+	  struct elf_dyn_relocs *p;
+
+	  /* Add reloc counts against the indirect sym to the direct sym
+	     list.  Merge any entries against the same section.  */
+	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)
+	    {
+	      struct elf_dyn_relocs *q;
+
+	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
+		if (q->sec == p->sec)
+		  {
+		    q->pc_count += p->pc_count;
+		    q->count += p->count;
+		    *pp = p->next;
+		    break;
+		  }
+	      if (q == NULL)
+		pp = &p->next;
+	    }
+	  *pp = edir->dyn_relocs;
+	}
+
+      edir->dyn_relocs = eind->dyn_relocs;
+      eind->dyn_relocs = NULL;
+    }
+
+  if (ind->root.type == bfd_link_hash_indirect)
+    {
+      if (dir->got.refcount <= 0)
+	{
+	  edir->tls_type = eind->tls_type;
+	  eind->tls_type = TLS_UNKNOWN;
+	}
+    }
+
+  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+}
+
+/* Set the right machine number.  */
+
+static bfd_boolean
+ncpu32k_elf_object_p (bfd *abfd)
+{
+  unsigned long mach = bfd_mach_ncpu32k;
+  return bfd_default_set_arch_mach (abfd, bfd_arch_ncpu32k, mach);
+}
+
+/* Store the machine number in the flags field.  */
+
+static void
+ncpu32k_elf_final_write_processing (bfd *abfd,
+				 bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  switch (bfd_get_mach (abfd))
+    {
+    default:
+    case bfd_mach_ncpu32k:
+      break;
+    }
+}
+
+static bfd_boolean
+ncpu32k_elf_set_private_flags (bfd *abfd, flagword flags)
+{
+  BFD_ASSERT (!elf_flags_init (abfd)
+	      || elf_elfheader (abfd)->e_flags == flags);
+
+  elf_elfheader (abfd)->e_flags = flags;
+  elf_flags_init (abfd) = TRUE;
+  return TRUE;
+}
+
+/* Make sure all input files are consistent with respect to
+   EF_NCPU32K_NODELAY flag setting.  */
+
+static bfd_boolean
+elf32_ncpu32k_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
+{
+  bfd *obfd = info->output_bfd;
+  flagword out_flags;
+  flagword in_flags;
+
+  in_flags  = elf_elfheader (ibfd)->e_flags;
+  out_flags = elf_elfheader (obfd)->e_flags;
+
+  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return TRUE;
+
+  if (!elf_flags_init (obfd))
+    {
+      elf_flags_init (obfd) = TRUE;
+      elf_elfheader (obfd)->e_flags = in_flags;
+
+      return TRUE;
+    }
+
+  if (in_flags == out_flags)
+    return TRUE;
+  /* check other flags here */
+
+  return TRUE;
+
+}
+
+/* Implement elf_backend_grok_prstatus:
+   Support for core dump NOTE sections.  */
+static bfd_boolean
+ncpu32k_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
+{
+  int offset;
+  size_t size;
+
+  switch (note->descsz)
+    {
+    default:
+      return FALSE;
+
+    case 212: //FIXME!	      /* Linux/nano-cpu32k */
+      /* pr_cursig */
+      elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);
+
+      /* pr_pid */
+      elf_tdata (abfd)->core->pid = bfd_get_32 (abfd, note->descdata + 24);
+
+      /* pr_reg */
+      offset = 72;
+      size = 132;
+
+      break;
+    }
+
+  /* Make a ".reg/999" section.  */
+  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
+					  size, note->descpos + offset);
+}
+
+/* Implement elf_backend_grok_psinfo.  */
+static bfd_boolean
+ncpu32k_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+    default:
+      return FALSE;
+
+    case 128: //FIXME!	      /* Linux/nano-cpu32k elf_prpsinfo */
+      elf_tdata (abfd)->core->program
+	= _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
+      elf_tdata (abfd)->core->command
+	= _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
+    }
+
+  return TRUE;
+}
+
+
+#define ELF_ARCH			bfd_arch_ncpu32k
+#define ELF_MACHINE_CODE		EM_NCPU32K
+#define ELF_TARGET_ID			NCPU32K_ELF_DATA
+#define ELF_MAXPAGESIZE			0x2000
+
+#define TARGET_LITTLE_SYM		ncpu32k_elf32_vec
+#define TARGET_LITTLE_NAME		"elf32-ncpu32k"
+
+#define elf_info_to_howto_rel		NULL
+#define elf_info_to_howto		ncpu32k_info_to_howto_rela
+#define elf_backend_relocate_section	ncpu32k_elf_relocate_section
+#define elf_backend_gc_mark_hook	ncpu32k_elf_gc_mark_hook
+#define elf_backend_check_relocs	ncpu32k_elf_check_relocs
+#define elf_backend_reloc_type_class	ncpu32k_elf_reloc_type_class
+#define elf_backend_can_gc_sections	1
+#define elf_backend_rela_normal		1
+
+#define bfd_elf32_mkobject		     elf_ncpu32k_mkobject
+
+#define bfd_elf32_bfd_merge_private_bfd_data elf32_ncpu32k_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags ncpu32k_elf_set_private_flags
+#define bfd_elf32_bfd_reloc_type_lookup ncpu32k_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup ncpu32k_reloc_name_lookup
+
+#define elf_backend_object_p		    ncpu32k_elf_object_p
+#define elf_backend_final_write_processing  ncpu32k_elf_final_write_processing
+#define elf_backend_can_refcount		1
+
+#define elf_backend_plt_readonly		1
+#define elf_backend_want_got_plt		1
+#define elf_backend_want_plt_sym		0
+#define elf_backend_got_header_size		12
+#define elf_backend_dtrel_excludes_plt		1
+#define elf_backend_want_dynrelro		1
+
+#define bfd_elf32_bfd_link_hash_table_create	ncpu32k_elf_link_hash_table_create
+#define elf_backend_copy_indirect_symbol	ncpu32k_elf_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections	_bfd_elf_create_dynamic_sections
+#define elf_backend_finish_dynamic_sections	ncpu32k_elf_finish_dynamic_sections
+#define elf_backend_size_dynamic_sections	ncpu32k_elf_size_dynamic_sections
+#define elf_backend_adjust_dynamic_symbol	ncpu32k_elf_adjust_dynamic_symbol
+#define elf_backend_finish_dynamic_symbol	ncpu32k_elf_finish_dynamic_symbol
+
+#define elf_backend_grok_prstatus	  ncpu32k_grok_prstatus
+#define elf_backend_grok_psinfo		  ncpu32k_grok_psinfo
+
+#include "elf32-target.h"
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/elf-bfd.h binutils-ncpu32k-2.32/bfd/elf-bfd.h
--- binutils-2.32/bfd/elf-bfd.h	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/elf-bfd.h	2020-01-14 16:20:55.796150267 +0800
@@ -519,6 +519,7 @@
   TILEGX_ELF_DATA,
   TILEPRO_ELF_DATA,
   RISCV_ELF_DATA,
+  NCPU32K_ELF_DATA,
   GENERIC_ELF_DATA
 };
 
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/libbfd.h binutils-ncpu32k-2.32/bfd/libbfd.h
--- binutils-2.32/bfd/libbfd.h	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/libbfd.h	2020-02-12 15:18:47.043409673 +0800
@@ -2801,6 +2801,21 @@
   "BFD_RELOC_NIOS2_R2_L5I4X1",
   "BFD_RELOC_NIOS2_R2_T1X1I6",
   "BFD_RELOC_NIOS2_R2_T1X1I6_2",
+  "BFD_RELOC_NCPU32K_INSN_LO14",
+  "BFD_RELOC_NCPU32K_INSN_HI14",
+  "BFD_RELOC_NCPU32K_INSN_LO18",
+  "BFD_RELOC_NCPU32K_INSN_HI18",
+  "BFD_RELOC_NCPU32K_INSN_REL26",
+  "BFD_RELOC_NCPU32K_GLOB_DAT",
+  "BFD_RELOC_NCPU32K_JMP_SLOT",
+  "BFD_RELOC_NCPU32K_RELATIVE",
+  "BFD_RELOC_NCPU32K_COPY",
+  "BFD_RELOC_NCPU32K_GOT_PCREL_HI18",
+  "BFD_RELOC_NCPU32K_GOT_PCREL_LO14",
+  "BFD_RELOC_NCPU32K_PLT_REL26",
+  "BFD_RELOC_NCPU32K_GOTOFF_HI18",
+  "BFD_RELOC_NCPU32K_GOTOFF_LO14",
+  "BFD_RELOC_NCPU32K_GOT14",
   "BFD_RELOC_PRU_U16",
   "BFD_RELOC_PRU_U16_PMEMIMM",
   "BFD_RELOC_PRU_LDI32",
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/Makefile.am binutils-ncpu32k-2.32/bfd/Makefile.am
--- binutils-2.32/bfd/Makefile.am	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/Makefile.am	2019-08-12 16:25:58.353167120 +0800
@@ -137,6 +137,7 @@
 	cpu-moxie.lo \
 	cpu-msp430.lo \
 	cpu-mt.lo \
+	cpu-ncpu32k.lo \
 	cpu-nds32.lo \
 	cpu-nfp.lo \
 	cpu-nios2.lo \
@@ -223,6 +224,7 @@
 	cpu-moxie.c \
 	cpu-msp430.c \
 	cpu-mt.c \
+	cpu-ncpu32k.c \
 	cpu-nds32.c \
 	cpu-nfp.c \
 	cpu-ns32k.c \
@@ -335,6 +337,7 @@
 	elf32-moxie.lo \
 	elf32-msp430.lo \
 	elf32-mt.lo \
+	elf32-ncpu32k.lo \
 	elf32-nds32.lo \
 	elf32-nios2.lo \
 	elf32-or1k.lo \
@@ -472,6 +475,7 @@
 	elf32-moxie.c \
 	elf32-msp430.c \
 	elf32-mt.c \
+	elf32-ncpu32k.c \
 	elf32-nds32.c \
 	elf32-nios2.c \
 	elf32-or1k.c \
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/Makefile.in binutils-ncpu32k-2.32/bfd/Makefile.in
--- binutils-2.32/bfd/Makefile.in	2019-02-02 23:47:56.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/Makefile.in	2019-08-12 16:27:08.929168870 +0800
@@ -560,6 +560,7 @@
 	cpu-moxie.lo \
 	cpu-msp430.lo \
 	cpu-mt.lo \
+	cpu-ncpu32k.lo \
 	cpu-nds32.lo \
 	cpu-nfp.lo \
 	cpu-nios2.lo \
@@ -646,6 +647,7 @@
 	cpu-moxie.c \
 	cpu-msp430.c \
 	cpu-mt.c \
+	cpu-ncpu32k.c \
 	cpu-nds32.c \
 	cpu-nfp.c \
 	cpu-ns32k.c \
@@ -759,6 +761,7 @@
 	elf32-moxie.lo \
 	elf32-msp430.lo \
 	elf32-mt.lo \
+	elf32-ncpu32k.lo \
 	elf32-nds32.lo \
 	elf32-nios2.lo \
 	elf32-or1k.lo \
@@ -896,6 +899,7 @@
 	elf32-moxie.c \
 	elf32-msp430.c \
 	elf32-mt.c \
+	elf32-ncpu32k.c \
 	elf32-nds32.c \
 	elf32-nios2.c \
 	elf32-or1k.c \
@@ -1362,6 +1366,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-moxie.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-msp430.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-mt.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-ncpu32k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-nds32.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-nfp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-nios2.Plo@am__quote@
@@ -1454,6 +1459,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-moxie.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-msp430.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-mt.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-ncpu32k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-nds32.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-nios2.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-or1k.Plo@am__quote@
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/reloc.c binutils-ncpu32k-2.32/bfd/reloc.c
--- binutils-2.32/bfd/reloc.c	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/reloc.c	2020-02-12 15:05:31.103454452 +0800
@@ -6463,6 +6463,39 @@
   Relocations used by the Altera Nios II core.
 
 ENUM
+  BFD_RELOC_NCPU32K_INSN_LO14
+ENUMX
+  BFD_RELOC_NCPU32K_INSN_HI14
+ENUMX
+  BFD_RELOC_NCPU32K_INSN_LO18
+ENUMX
+  BFD_RELOC_NCPU32K_INSN_HI18
+ENUMX
+  BFD_RELOC_NCPU32K_INSN_REL26
+ENUMX
+  BFD_RELOC_NCPU32K_GLOB_DAT
+ENUMX
+  BFD_RELOC_NCPU32K_JMP_SLOT
+ENUMX
+  BFD_RELOC_NCPU32K_RELATIVE
+ENUMX
+  BFD_RELOC_NCPU32K_COPY
+ENUMX
+  BFD_RELOC_NCPU32K_GOT_PCREL_HI18
+ENUMX
+  BFD_RELOC_NCPU32K_GOT_PCREL_LO14
+ENUMX
+  BFD_RELOC_NCPU32K_PLT_REL26
+ENUMX
+  BFD_RELOC_NCPU32K_GOTOFF_HI18
+ENUMX
+  BFD_RELOC_NCPU32K_GOTOFF_LO14
+ENUMX
+  BFD_RELOC_NCPU32K_GOT14
+ENUMDOC
+  nano-cpu32k Relocations.
+
+ENUM
   BFD_RELOC_PRU_U16
 ENUMDOC
   PRU LDI 16-bit unsigned data-memory relocation.
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/targets.c binutils-ncpu32k-2.32/bfd/targets.c
--- binutils-2.32/bfd/targets.c	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/targets.c	2019-08-12 15:34:49.533091027 +0800
@@ -738,6 +738,7 @@
 extern const bfd_target msp430_elf32_vec;
 extern const bfd_target msp430_elf32_ti_vec;
 extern const bfd_target mt_elf32_vec;
+extern const bfd_target ncpu32k_elf32_vec;
 extern const bfd_target nds32_elf32_be_vec;
 extern const bfd_target nds32_elf32_le_vec;
 extern const bfd_target nds32_elf32_linux_be_vec;
@@ -1117,6 +1118,8 @@
 
 	&mt_elf32_vec,
 
+	&ncpu32k_elf32_vec,
+
 	&nds32_elf32_be_vec,
 	&nds32_elf32_le_vec,
 	&nds32_elf32_linux_be_vec,
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/binutils/readelf.c binutils-ncpu32k-2.32/binutils/readelf.c
--- binutils-2.32/binutils/readelf.c	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/binutils/readelf.c	2019-08-12 15:45:38.381107115 +0800
@@ -132,6 +132,7 @@
 #include "elf/moxie.h"
 #include "elf/mt.h"
 #include "elf/msp430.h"
+#include "elf/ncpu32k.h"
 #include "elf/nds32.h"
 #include "elf/nfp.h"
 #include "elf/nios2.h"
@@ -828,6 +829,7 @@
     case EM_MSP430:
     case EM_MSP430_OLD:
     case EM_MT:
+    case EM_NCPU32K:
     case EM_NDS32:
     case EM_NIOS32:
     case EM_OR1K:
@@ -1381,6 +1383,10 @@
 	  rtype = elf_msp430_reloc_type (type);
 	  break;
 
+	case EM_NCPU32K:
+	  rtype = elf_ncpu32k_reloc_type (type);
+	  break;
+
 	case EM_NDS32:
 	  rtype = elf_nds32_reloc_type (type);
 	  break;
@@ -2508,6 +2514,7 @@
     case EM_CYGNUS_FRV:		return "Fujitsu FR-V";
     case EM_S12Z:               return "Freescale S12Z";
     case EM_CSKY:		return "C-SKY";
+    case EM_NCPU32K:		return "nano-cpu32k";
 
     default:
       snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
@@ -3461,6 +3468,9 @@
 	    }
 	  break;
 
+        case EM_NCPU32K:
+          break;
+
 	case EM_NDS32:
 	  decode_NDS32_machine_flags (e_flags, buf, sizeof buf);
 	  break;
@@ -12459,6 +12469,8 @@
       return reloc_type == 1; /* R_MSP430_32 or R_MSP320_ABS32.  */
     case EM_MT:
       return reloc_type == 2; /* R_MT_32.  */
+    case EM_NCPU32K:
+      return reloc_type == 1; /* R_NCPU32K_32.  */
     case EM_NDS32:
       return reloc_type == 20; /* R_NDS32_RELA.  */
     case EM_ALTERA_NIOS2:
@@ -12577,6 +12589,8 @@
       return reloc_type == 36; /* R_AVR_32_PCREL.  */
     case EM_MICROBLAZE:
       return reloc_type == 2;  /* R_MICROBLAZE_32_PCREL.  */
+    case EM_NCPU32K:
+      return reloc_type == 9; /* R_NCPU32K_32_PCREL.  */
     case EM_OR1K:
       return reloc_type == 9; /* R_OR1K_32_PCREL.  */
     case EM_PARISC:
@@ -12767,6 +12781,8 @@
       return reloc_type == 19; /* R_NDS32_RELA.  */
     case EM_ALTERA_NIOS2:
       return reloc_type == 13; /* R_NIOS2_BFD_RELOC_16.  */
+    case EM_NCPU32K:
+      return reloc_type == 2; /* R_NCPU32K_16.  */
     case EM_NIOS32:
       return reloc_type == 9; /* R_NIOS_16.  */
     case EM_OR1K:
@@ -12989,6 +13005,7 @@
     case EM_MIPS:    /* R_MIPS_NONE.  */
     case EM_MN10300: /* R_MN10300_NONE.  */
     case EM_MOXIE:   /* R_MOXIE_NONE.  */
+    case EM_NCPU32K: /* R_NCPU32K_NONE. */
     case EM_NIOS32:  /* R_NIOS_NONE.  */
     case EM_OR1K:    /* R_OR1K_NONE. */
     case EM_PARISC:  /* R_PARISC_NONE.  */
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/config.guess binutils-ncpu32k-2.32/config.guess
--- binutils-2.32/config.guess	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/config.guess	2019-07-31 11:34:32.199896731 +0800
@@ -419,6 +419,9 @@
 	fi
 	echo "$SUN_ARCH"-pc-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
 	exit ;;
+    nano*cpu*32k*:Linux:*:*)
+	echo ncpu32k-unknown-linux-"$LIBC"
+	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/config.sub binutils-ncpu32k-2.32/config.sub
--- binutils-2.32/config.sub	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/config.sub	2019-08-12 15:36:41.857093812 +0800
@@ -1215,6 +1215,7 @@
 			| moxie \
 			| mt \
 			| msp430 \
+			| ncpu32* \
 			| nds32 | nds32le | nds32be \
 			| nfp \
 			| nios | nios2 | nios2eb | nios2el \
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/cpu/ncpu32k.cpu binutils-ncpu32k-2.32/cpu/ncpu32k.cpu
--- binutils-2.32/cpu/ncpu32k.cpu	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/cpu/ncpu32k.cpu	2020-02-03 19:22:01.488887164 +0800
@@ -0,0 +1,1085 @@
+; nano-cpu32k architecture -*- Scheme -*-
+; Copyright (C) 2019 cassuto
+;***************************************************************************
+;
+; This program is free software; you can redistribute it and/or modify
+; it under the terms of the GNU General Public License as published by
+; the Free Software Foundation; either version 3 of the License, or
+; (at your option) any later version.
+;
+; This program is distributed in the hope that it will be useful,
+; but WITHOUT ANY WARRANTY; without even the implied warranty of
+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+; GNU General Public License for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with this program; if not, see <http://www.gnu.org/licenses/>
+
+(include "simplify.inc")
+
+(define-arch
+  (name ncpu32k)
+  (comment "nano-CPU32k")
+  (default-alignment aligned)
+  (insn-lsb0? #t)
+  (machs ncpu32k-mach)
+  (isas ncpu32k-isa)
+)
+
+; Instruction set parameters.
+(define-isa
+  ; Name of the ISA.
+  (name ncpu32k-isa)
+  ; Max. insturction length.
+  (base-insn-bitsize 32)
+  )
+
+(define-cpu
+  (name ncpu32k)
+  (comment "nano-CPU 32k family")
+  (insn-endian little)
+  (data-endian little)
+  (word-bitsize 32)
+  (file-transform "")
+  )
+
+(define-mach
+  (name ncpu32k-mach)
+  (comment "nano-CPU 32k machine")
+  (cpu ncpu32k)
+  (bfd-name "ncpu32k")
+  )
+
+(define-model
+  (name ncpu32000) (comment "nano-CPU 32000 model")
+  (attrs)
+  (mach ncpu32k-mach)
+  (unit u-exec "Execution Unit" () 1 1 () () () ())
+  )
+
+
+;***************************************************************************
+; Registers
+;***************************************************************************
+
+(define-pmacro REG-INDICES
+  ((r0 0)
+   (r1 1)
+   (r2 2)
+   (r3 3)
+   (r4 4)
+   (r5 5)
+   (r6 6)
+   (r7 7)
+   (r8 8)
+   (r9 9)
+   (r10 10)
+   (r11 11)
+   (r12 12)
+   (r13 13)
+   (r14 14)
+   (r15 15)
+   (r16 16)
+   (r17 17)
+   (r18 18)
+   (r19 19)
+   (r20 20)
+   (r21 21)
+   (r22 22)
+   (r23 23)
+   (r24 24)
+   (r25 25)
+   (r26 26)
+   (r27 27)
+   (r28 28)
+   (r29 29)
+   (r30 30)
+   (r31 31)
+   ; aliases
+   (nil 0)
+   (lnk 1)
+   (sp 2)
+   (fp 3)
+   (v0 4)
+   (v1 5)
+   (v2 6)
+   (v3 7)
+   (v4 8)
+   (v5 9)
+   (rv 10)
+   (rvh 11)
+   (rtls 12)
+   (rgot 14)
+  )
+)
+
+;
+; FRS
+;
+(define-hardware
+  (name h-frs)
+  (comment "floating point registers (single, virtual)")
+  (attrs VIRTUAL)
+  (type register SF (32))
+  (indices keyword "" REG-INDICES)
+  (get (index) (subword SF (trunc SI (reg h-gpr index)) 0))
+  (set (index newval) (set UWI (reg h-gpr index) (zext UWI (subword SI newval 0))))
+  )
+
+;
+; FRD
+;
+(define-hardware
+  (name h-frd) (comment "floating point registers (double, virtual)")
+  (attrs VIRTUAL)
+  (type register DF (32))
+  (indices keyword "" REG-INDICES)
+  (get (index) (subword DF (trunc DI (reg h-gpr index)) 0))
+  (set (index newval) (set UDI (reg h-gpr index) (zext UDI (subword DI newval 0))))
+  )
+
+;
+; MSR
+;
+(define-hardware
+  (name h-msr) (comment "CPU status management registers")
+  (attrs VIRTUAL)
+  (type register UWI (#x20000))
+  (get (index) (c-call UWI "@cpu@_h_msr_get_raw" index))
+  (set (index newval) (c-call VOID "@cpu@_h_msr_set_raw" index newval))
+)
+
+(define-pmacro msr-bank-shift 10)
+(define-pmacro (msr-address msr-bank msr-index)
+  (or (sll UWI (enum UWI (.sym "MSR-BANK-" msr-bank)) msr-bank-shift)
+      (enum UWI (.sym "MSR-INDEX-" msr-bank "-" msr-index))))
+
+;
+; GPR
+;
+(define-hardware
+  (name h-gpr) (comment "general registers")
+  (attrs)
+  (type register UWI (32))
+  (indices keyword "" REG-INDICES)
+  (get (index) (reg UWI h-msr (add index (msr-address CCFG GPR0))))
+  (set (index newval) (set UWI (reg UWI h-msr (add index (msr-address CCFG GPR0))) newval))
+  )
+  
+(define-hardware
+  (name h-pc)
+  (comment "program counter")
+  (attrs PC)
+  (type pc UWI)
+  (get () (raw-reg h-pc))
+  (set (newval) (sequence ()
+                 (set (reg h-ppc) (raw-reg h-pc))
+                 (set (raw-reg h-pc) newval)
+                ))
+  )
+
+  
+
+;***************************************************************************
+; Exceptions
+;***************************************************************************
+
+(define-normal-enum
+  except-number
+  "Exception numbers"
+  ()
+  EXCEPT-
+  (
+   ("ERST"          #x00000000)
+   ("EINSN"         #x00000004)
+   ("EIRQ"          #x00000008)
+   ("ESYSCALL"      #x0000000c)
+   ("EBUS"          #x00000010)
+   ("EIPF"          #x00000014)
+   ("EDPF"          #x00000018)
+   ("EITM"          #x0000001c)
+   ("EDTM"          #x00000020)
+   ("EALGIN"        #x00000024)
+   ("EINT"          #x00000028)
+   )
+  )
+
+(define-pmacro (raise-exception exnum)
+  (c-call VOID "@cpu@_exception" pc exnum))
+
+
+;***************************************************************************
+; MSR fields
+;***************************************************************************
+
+(define-normal-enum
+  msr-groups
+  "CPU status management register groups"
+  ()
+  MSR-BANK-
+  (("PSB"       #x0)
+   ("IMB"       #x1)
+   ("DMB"       #x2)
+   ("ICB"       #x3)
+   ("DCB"       #x4)
+   ("DBGB"      #x5)
+   )
+  )
+
+(define-pmacro (msr-reg-info)
+  (.splice    
+   (PSE PSR     #x000 "Processor Status Register")
+   )
+  )
+
+(define-normal-enum
+  msr-reg-indices
+  "CPU status management register indicies"
+  ()
+  MSR-INDEX-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (bank index n comment)
+                                  ((.sym bank "-" index) n))
+                         args)
+                 )
+        (msr-reg-info)
+        )
+  )
+
+(define-pmacro (define-h-msr-reg msr-bank msr-index n msr-comment)
+  (define-hardware
+    (name (.sym "h-" (.downcase msr-bank) "-" (.downcase msr-index)))
+    (comment msr-comment)
+    (attrs VIRTUAL)
+    (type register UWI)
+    (get ()       (reg UWI h-msr (msr-address msr-bank msr-index)))
+    (set (newval) (set (reg UWI h-msr (msr-address msr-bank msr-index)) newval))
+    )
+  )
+(.splice begin (.unsplice (.map (.pmacro (args) (.apply define-h-msr-reg args)) (msr-reg-info))))
+
+(define-pmacro (msr-field-info)
+   ;
+   ; <bank> <index> <field> <field-msb> <field-lsb> <comment>
+   ;  |        |         |        |           |          |
+   ;  |   ------  --------        |           |          |
+   ;  |   |       |     -----------           |          |
+   ;  |   |       |     |  --------------------          |
+   ;  |   |       |     |  |        ----------------------
+   ;  |   |       |     |  |        |
+  ((PSB PSR      CC     0  0  "Condition Control?")
+   (PSB PSR      CY     1  1  "Carry (Unsigned overflow)?")
+   (PSB PSR      OV     2  2  "Overflow?")
+   (PSB PSR      OE     3  3  "Overflow exception Enable")
+   (PSB PSR      RM     4  4  "In Root mode?")
+   (PSB PSR      IRE    5  5  "Interrupt Respond Enable")
+   (PSB PSR      IMME   6  6  "Insn Memory Management Enable")
+   (PSB PSR      DMME   7  7  "Data Memory Management Enable")
+   (PSB PSR      ICAE   8  8  "Insn Cache Enable")
+   (PSB PSR      DCAE   9  9  "Data Cache Enable")
+   
+   (PSB CPUID    VER    7  0  "Major Version")
+   (PSB CPUID    REV    17 8  "Revision")
+   (PSB CPUID    FIMM   18 18 "Feature Insn Memory Management")
+   (PSB CPUID    FDMM   19 19 "Feature Data Memory Management")
+   (PSB CPUID    FICA   20 20 "Feature Insn Cache")
+   (PSB CPUID    FDCA   21 21 "Feature Data Cache")
+   (PSB CPUID    FDBG   22 22 "Feature Debug port")
+   (PSB CPUID    FFPU   23 23 "Feature Float point unit")
+   (PSB CPUID    FIRQC  24 24 "Feature Float point unit")
+   (PSB CPUID    FTSC   25 25 "Feature TSC")
+   )
+  )
+
+(define-normal-enum
+  msr-field-msbs
+  "MSR field msb positions"
+  ()
+  MSR-FIELD-MSB-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (bank index field msb lsb comment)
+                                  ((.sym bank "-" index "-" field) msb)
+                                  )
+                         args
+                         )
+                 )
+        (msr-field-info)
+        )
+  )
+
+(define-normal-enum
+  msr-field-lsbs
+  "MSR field lsb positions"
+  ()
+  MSR-FIELD-SIZE-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (bank index field msb lsb comment)
+                                  ((.sym bank "-" index "-" field) lsb)
+                                  )
+                         args
+                         )
+                 )
+        (msr-field-info)
+        )
+  )
+
+(define-normal-enum
+  msr-field-masks
+  "MSR field masks"
+  ()
+  MSR-FIELD-MASK-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (bank index field msb lsb comment)
+                                  (.splice (.str bank "-" index "-" field) (.sll (.inv (.sll (.inv 0) (.add (.sub msb lsb) 1))) lsb))
+                                  )
+                         args
+                         )
+                 )
+        (msr-field-info)
+        )
+  )
+
+
+(define-pmacro (define-h-msr-field msr-bank msr-index msr-field msr-field-msb msr-field-lsb msr-field-comment)
+  (.let ((msr-field-name (.sym "h-" (.downcase msr-bank) "-" (.downcase msr-index) "-" (.downcase msr-field)))
+         )
+        (begin
+          (define-hardware
+            (name msr-field-name)
+            (comment msr-field-comment)
+            (attrs VIRTUAL (MACH ncpu32k-mach))
+            (type register UWI)
+            (get ()      (c-call UWI  "@cpu@_h_cmsr_field_get_raw" (msr-address msr-bank msr-index) msr-field-msb msr-field-lsb))
+            (set (value) (c-call VOID "@cpu@_h-cmsr_field_set_raw" (msr-address msr-bank msr-index) msr-field-msb msr-field-lsb value))
+            )
+          )
+        )
+  )
+
+(.splice begin (.unsplice (.map (.pmacro (args) (.apply define-h-msr-field args)) (msr-field-info))) )
+
+
+;***************************************************************************
+
+(define-attr
+  (for insn)
+  (type boolean)
+  (name FORCED-CTI)
+  (comment "forcefully transfer control, mainly for RET instruction.")
+  )
+
+
+; Hardware for immediate operands
+(dnh h-simm14   "14-bit signed immediate"   () (immediate (INT 14)) () () ())
+(dnh h-uimm14   "14-bit unsigned immediate" ()  (immediate (UINT 14)) () () ())
+(dnh h-uimm18   "18-bit unsigned immediate" ()  (immediate (UINT 18)) () () ())
+
+;***************************************************************************
+; Instruction fields.
+;***************************************************************************
+
+(dnf f-opcode   "<opcode>"    ()          5 6)
+(dnf f-rd       "<rd>"        ()          11 6)
+(dnf f-res-rd   "<res>-<rd>"  (RESERVED)  11 6)
+(dnf f-rs1      "<rs1>"       ()          17 6)
+(dnf f-res-rs1  "<res>-<rs1>" (RESERVED)  17 6)
+(dnf f-rs2      "<rs2>"       ()          23 6)
+(dnf f-res-rs2  "<res>-<rs2>" (RESERVED)  23 6)
+
+(dnf f-res-attr   "<res>-<attr>"  (RESERVED) 31 8)
+(dnf f-uimm14     "uimm14"        ()      31 14)
+(df  f-simm14     "simm14"        (SIGN-OPT) 31 14 INT #f #f)
+(dnf f-res-imm14  "<res>-<imm14>" (RESERVED) 31 14)
+(dnf f-uimm18     "uimm18"        ()      29 18)
+(dnf f-res-imm2   "<res>-<imm2>"  (RESERVED) 31 2)
+
+; <address> PC relative, 26-bit
+(df f-rel26
+    "rel26"
+    (PCREL-ADDR)
+    31
+    26
+    INT
+    ((value pc) (sra SI (sub IAI value pc) (const 2)))
+    ((value pc) (add IAI (sll IAI value (const 2)) pc))
+    )
+
+;***************************************************************************
+; Enums.
+;***************************************************************************
+
+; <opcode> [5..0]
+(define-normal-insn-enum insn-opcode "<opcode> insn opcodes" ()
+  OPC_
+  f-opcode
+  (
+   ; BASE insn group
+   ("AND"               #x00)
+   ("AND.I"             #x01)
+   ("OR"                #x02)
+   ("OR.I"              #x03)
+   ("XOR"               #x04)
+   ("XOR.I"             #x05)
+   ("LSL"               #x06)
+   ("LSL.I"             #x07)
+   ("LSR"               #x08)
+   ("LSR.I"             #x09)
+   ("JMP"               #x0a)
+   ("JMP.I"             #x0b)
+   ("CMP"               #x0c)
+   ("BT"                #x0d)
+   ("BF"                #x0e)
+   ("LDWU"              #x0f)
+   ("STW"               #x10)
+   ("MBARR"             #x11)
+   ("SYSCALL"           #x12)
+   ("RET"               #x13)
+   ("WMSR"              #x14)
+   ("RMSR"              #x15)
+   ("VENTER"            #x16)
+   ("VLEAVE"            #x17)
+   ("JMP.I.LNK"         #x18)
+
+   ; VIRT insn group
+   ("ASR"               #x1a)
+   ("ASR.I"             #x1b)
+   ("ADD"               #x1c)
+   ("ADD.I"             #x1d)
+   ("SUB"               #x1e)
+   ("MUL"               #x1f)
+   ("DIV"               #x20)
+   ("DIVU"              #x21)
+   ("MOD"               #x22)
+   ("MODU"              #x23)
+   ("LDB"               #x24)
+   ("LDBU"              #x25)
+   ("LDH"               #x26)
+   ("LDHU"              #x27)
+   ("STB"               #x28)
+   ("STH"               #x29)
+   ("MHI"               #x2a)
+   ("FADDS"             #x2b)
+   ("FSUBS"             #x2c)
+   ("FMULS"             #x2d)
+   ("FDIVS"             #x2e)
+   ("FCMPS"             #x2f)
+   ("FITFS"             #x30)
+   ("FFTIS"             #x31)
+   ("LDWA"              #x32)
+   ("STWA"              #x33)
+  )
+)
+
+;***************************************************************************
+; Instruction operands.
+;***************************************************************************
+
+; operands for insns
+(dnop rs1  "source operand #1"  ()  h-gpr   f-rs1)
+(dnop rs2  "source operand #2"  ()  h-gpr   f-rs2)
+(dnop rd  "destination operand" ()  h-gpr   f-rd)
+
+(define-operand
+  (name simm14)
+  (comment "14-bit signed immediate")
+  (attrs SIGN-OPT)
+  (type h-simm14)
+  (index f-simm14)
+  (handlers (parse "simm14"))
+  )
+
+(define-operand
+  (name uimm14)
+  (comment "14-bit unsigned immediate")
+  (attrs)
+  (type h-uimm14)
+  (index f-uimm14)
+  (handlers (parse "uimm14"))
+  )
+  
+(define-operand
+  (name uimm18)
+  (comment "18-bit unsigned immediate")
+  (attrs)
+  (type h-uimm18)
+  (index f-uimm18)
+  (handlers (parse "uimm18"))
+  )
+
+(define-operand
+  (name rel26)
+  (comment "pc-rel 26 bit address")
+  (attrs)
+  (type h-iaddr)
+  (index f-rel26)
+  (handlers (parse "rel26"))
+  )
+
+; Hardware for semantic atomic registers
+(dsh h-atomic-flag "atomic flag" () (register BI))
+(dsh h-atomic-addr "atomic address" () (register SI))
+
+
+; operands in MSR (for semantics description only)
+(dnop msr-psr-cc "PSR Condition bit"     (SEM-ONLY) h-psb-psr-cc      f-nil)
+(dnop msr-psr-cy "PSR carry bit"         (SEM-ONLY) h-psb-psr-cy      f-nil)
+(dnop msr-psr-ov "PSR overflow bit"      (SEM-ONLY) h-psb-psr-ov      f-nil)
+(dnop msr-psr-oe "PSR overflow exception enable bit" (SEM-ONLY) h-psb-psr-oe f-nil)
+(dnop atomic-flag "atomic flag"          (SEM-ONLY) h-atomic-flag    f-nil)
+(dnop atomic-addr "atomic address"       (SEM-ONLY) h-atomic-addr    f-nil)
+
+;***************************************************************************
+; Internal pseudo macros
+;***************************************************************************
+
+(define-pmacro (rop-alu-insn mnemonic)
+  (begin
+     (dni mnemonic
+          (.str mnemonic " reg/reg/reg")
+          ()
+          (.str mnemonic " $rd,$rs1,$rs2")
+          (+ (.sym OPC_ (.upcase mnemonic)) rd rs1 rs2 (f-res-attr 0))
+          (set rd (mnemonic rs1 rs2))
+          ()
+     )
+  )
+ )
+(define-pmacro (uimm-alu-insn  mnemonic binop)
+    (begin
+      (dni (.sym mnemonic ".i")
+           (.str mnemonic " reg/reg/uimm14")
+           ()
+           (.str mnemonic " $rd,$rs1,$uimm14")
+           (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs1 uimm14)
+           (set rd (binop rs1 (zext UWI uimm14)))
+           ()
+     )
+    )
+  )
+(define-pmacro (simm-alu-insn  mnemonic binop)
+    (begin
+      (dni (.sym mnemonic ".i")
+          (.str mnemonic " reg/reg/simm14")
+          ()
+          (.str mnemonic " $rd,$rs1,$simm14")
+          (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs1 simm14)
+          (set rd (binop rs1 (ext WI simm14)))
+          ()
+     )
+    )
+  )
+
+
+(define-pmacro (rop-alu-carry-insn mnemonic)
+  (begin
+    (dni mnemonic
+         (.str mnemonic " reg/reg/reg")
+         ()
+         (.str mnemonic " $rd,$rs1,$rs2")
+         (+ (.sym OPC_ (.upcase mnemonic)) rd rs1 rs2 (f-res-attr 0))
+         (sequence ()
+                   (sequence ()
+                             (set BI msr-psr-cy ((.sym mnemonic "c-cflag") WI rs1 rs2 0))
+                             (set BI msr-psr-ov ((.sym mnemonic "c-oflag") WI rs1 rs2 0))
+                             (set rd (mnemonic WI rs1 rs2))
+                             )
+                   (if (andif msr-psr-ov msr-psr-oe)
+                       (raise-exception EXCEPT-EINT))
+                   )
+         ()
+         )
+    )
+  )
+(define-pmacro (simm-alu-carry-insn mnemonic binop)
+  (begin
+    (dni (.sym mnemonic ".i")
+         (.str mnemonic " reg/reg/simm14")
+         ()
+         (.str mnemonic " $rd,$rs1,$simm14")
+         (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs1 simm14)
+         (sequence ()
+                   (sequence ()
+                             (set BI msr-psr-cy ((.sym binop "c-cflag") WI rs1 (ext WI simm14) 0))
+                             (set BI msr-psr-ov ((.sym binop "c-oflag") WI rs1 (ext WI simm14) 0))
+                             (set rd (binop WI rs1 (ext WI simm14)))
+                             )
+                   (if (andif msr-psr-ov msr-psr-oe)
+                       (raise-exception EXCEPT-EINT))
+                   )
+         ()
+         )
+    )
+  )
+
+  
+;***************************************************************************
+; Pseudo Instructions
+;***************************************************************************
+
+(dni nop "nop"
+  ()
+  "nop"
+  (+ OPC_AND (f-res-rd 0) (f-res-rs1 0) (f-res-rs2 0) (f-res-attr 0))
+  (nop)
+  ()
+ )
+
+(dni mov
+  (.str "mov reg/reg")
+  ()
+  (.str "mov $rd,$rs1")
+  (+ OPC_OR rd rs1 (f-res-rs2 0) (f-res-attr 0))
+  (set rd rs1)
+  ()
+ )
+
+
+;***************************************************************************
+; ALU Logic Instructions
+;***************************************************************************
+
+(rop-alu-insn and)
+(uimm-alu-insn and and)
+
+(rop-alu-insn or)
+(uimm-alu-insn or or)
+
+(rop-alu-insn xor)
+(simm-alu-insn xor xor)
+
+(define-pmacro (rop-shift-insn mnemonic binop)
+  (begin
+     (dni mnemonic
+          (.str mnemonic " reg/reg/reg")
+          ()
+          (.str mnemonic " $rd,$rs1,$rs2")
+          (+ (.sym OPC_ (.upcase mnemonic)) rd rs1 rs2 (f-res-attr 0))
+          (set UWI rd (binop rs1 rs2))
+          ()
+     )
+   )
+ )
+(define-pmacro (uimm-shift-insn mnemonic binop)
+    (dni (.sym mnemonic ".i")
+          (.str mnemonic " reg/reg/uimm14")
+          ()
+          (.str mnemonic " $rd,$rs1,${uimm14}")
+          (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs1 uimm14)
+          (set rd (binop rs1 uimm14))
+          ()
+     )
+  )
+
+
+(rop-shift-insn lsl sll)
+(uimm-shift-insn lsl sll)
+
+(rop-shift-insn lsr srl)
+(uimm-shift-insn lsr srl)
+
+(rop-shift-insn asr sra)
+(uimm-shift-insn asr sra)
+
+
+;***************************************************************************
+; ALU Integer Instructions
+;***************************************************************************
+
+(rop-alu-carry-insn add)
+(simm-alu-carry-insn add add)
+
+(rop-alu-carry-insn sub)
+
+(dni mul "mul reg/reg/reg"
+  ()
+  ("mul $rd,$rs1,$rs2")
+  (+ OPC_MUL rd rs1 rs2 (f-res-attr 0))
+  (sequence ()
+            (sequence ()
+                      ; 2's complement overflow
+                      (set BI msr-psr-ov (mul-o2flag WI rs1 rs2))
+                      ; 1's complement overflow
+                      (set BI msr-psr-cy (mul-o1flag WI rs1 rs2))
+                      (set rd (mul WI rs1 rs2))
+                      )
+            (if (andif msr-psr-ov msr-psr-oe)
+                (raise-exception EXCEPT-EINT))
+            )
+  ()
+ )
+
+(dni div "div (signed) reg/reg/reg"
+  ()
+  "div $rd,$rs1,$rs2"
+  (+ OPC_DIV rd rs1 rs2 (f-res-attr 0))
+  (sequence ()
+            (if (ne rs2 0)
+                (sequence ()
+                          (set BI msr-psr-cy 0)
+                          (set WI rd (div WI rs1 rs2))
+                          )
+                (set BI msr-psr-cy 1)
+                )
+            (set BI msr-psr-ov 0)
+            (if (andif msr-psr-cy msr-psr-oe)
+                (raise-exception EXCEPT-EINT))
+            )
+  ()
+ )
+
+(dni divu "div (unsigned) reg/reg/reg"
+  ()
+  "divu $rd,$rs1,$rs2"
+  (+ OPC_DIVU rd rs1 rs2 (f-res-attr 0))
+  (sequence ()
+            (if (ne rs2 0)
+                (sequence ()
+                          (set BI msr-psr-cy 0)
+                          (set rd (udiv UWI rs1 rs2))
+                          )
+                (set BI msr-psr-cy 1)
+                )
+            (set BI msr-psr-ov 0)
+            (if (andif msr-psr-cy msr-psr-oe)
+                (raise-exception EXCEPT-EINT))
+            )
+  ()
+ )
+
+(dni mod "mod (signed) reg/reg/reg"
+  ()
+  "mod $rd,$rs1,$rs2"
+  (+ OPC_MOD rd rs1 rs2 (f-res-attr 0))
+  (sequence ()
+            (if (ne rs2 0)
+                (sequence ()
+                          (set BI msr-psr-cy 0)
+                          (set WI rd (mod WI rs1 rs2))
+                          )
+                (set BI msr-psr-cy 1)
+                )
+            (set BI msr-psr-ov 0)
+            (if (andif msr-psr-cy msr-psr-oe)
+                (raise-exception EXCEPT-EINT))
+            )
+  ()
+ )
+ 
+(dni modu "mod (unsigned) reg/reg/reg"
+  ()
+  "modu $rd,$rs1,$rs2"
+  (+ OPC_MODU rd rs1 rs2 (f-res-attr 0))
+  (sequence ()
+            (if (ne rs2 0)
+                (sequence ()
+                          (set BI msr-psr-cy 0)
+                          (set WI rd (mod UWI rs1 rs2))
+                          )
+                (set BI msr-psr-cy 1)
+                )
+            (set BI msr-psr-ov 0)
+            (if (andif msr-psr-cy msr-psr-oe)
+                (raise-exception EXCEPT-EINT))
+            )
+  ()
+ )
+
+
+;***************************************************************************
+; Data Transfer Instructions
+;***************************************************************************
+
+(dni mhi "mhi"
+     ()
+     "mhi $rd,${uimm18}"
+     (+ OPC_MHI rd uimm18 (f-res-imm2 0))
+     (set UWI rd (sll UWI (zext UWI uimm18) (const 14)))
+     ()
+ )
+
+(dni rmsr "rmsr"
+     ()
+     "rmsr $rd,$rs1,${uimm14}"
+     (+ OPC_RMSR rd rs1 uimm14)
+     (set UWI rd (c-call UWI "@cpu@_rmsr" (or rs1 (zext UWI uimm14))))
+     ()
+ )
+
+(dni wmsr "wmsr"
+     ()
+     "wmsr $rd,$rs1,${uimm14}"
+     (+ OPC_WMSR rd rs1 uimm14)
+     (c-call VOID "@cpu@_wmsr" (or rd (zext WI uimm14)) rs1)
+     ()
+ )
+ 
+
+;***************************************************************************
+; Comparasion Instructions
+;***************************************************************************
+
+(dni cmpeq
+  "cmp reg==reg"
+  ()
+  "cmp $rs1,eq,$rs2"
+  (+ OPC_CMP (f-res-rd 0) rs1 rs2 (f-res-attr 0) )
+  (set msr-psr-cc (eq WI rs1 rs2))
+  ()
+ )
+(dni cmpgt
+  "cmp reg>reg"
+  ()
+  "cmp $rs1,gt,$rs2"
+  (+ OPC_CMP (f-res-rd 0) rs1 rs2 (f-res-attr 1) )
+  (set msr-psr-cc (gt WI rs1 rs2))
+  ()
+ )
+(dni cmp
+  "cmp unsigned reg>reg"
+  ()
+  "cmp $rs1,gtu,$rs2"
+  (+ OPC_CMP (f-res-rd 0) rs1 rs2 (f-res-attr 2) )
+  (set msr-psr-cc (gtu WI rs1 rs2))
+  ()
+ )
+
+
+;***************************************************************************
+; Control flow - Branch Instructions
+;***************************************************************************
+
+(define-pmacro (cbi-link-return lnk offset)
+  (set IAI (reg h-gpr lnk) (add pc offset))
+ )
+(define-pmacro (cbi-transfer-control condition target)
+  (sequence ()
+    (if condition
+        (delay 1 (set IAI pc target))
+        )
+    )
+ )
+
+(define-pmacro
+  (define-cbi
+    cbi-name
+    cbi-comment
+    cbi-attrs
+    cbi-syntax
+    cbi-format
+    cbi-semantics)
+  (begin
+    (dni
+      cbi-name
+      cbi-comment
+      cbi-attrs
+      cbi-syntax
+      cbi-format
+      (cbi-semantics)
+      ()
+      )
+    )
+  )
+  
+
+(define-cbi
+  jmp
+  "jmp reg and link (absolute)"
+  (!COND-CTI UNCOND-CTI)
+  "jmp $rd,$rs1"
+  (+ OPC_JMP rd rs1 (f-res-rs2 0) (f-res-attr 0))
+  (.pmacro ()
+           (sequence ()
+                     (cbi-link-return rd 4)
+                     (cbi-transfer-control 1 rs1)
+                     )
+           )
+ )
+
+(define-cbi
+  jmp.i
+  "jmp segment (pc-relative rel26)"
+  (!COND-CTI UNCOND-CTI)
+  "jmp r0,${rel26}"
+  (+ OPC_JMP.I rel26)
+  (.pmacro ()
+           (sequence ()
+                     (cbi-transfer-control 1 rel26)
+                     )
+           )
+ )
+(define-cbi
+  jmp.i.lnk
+  "jmp segment with link (pc-relative rel26)"
+  (!COND-CTI UNCOND-CTI)
+  "jmp lnk,${rel26}"
+  (+ OPC_JMP.I.LNK rel26)
+  (.pmacro ()
+           (sequence ()
+                     (cbi-link-return 1 4)
+                     (cbi-transfer-control 1 rel26)
+                     )
+           )
+ )
+
+
+(define-cbi
+  bt
+  "branch if condition is true (pc relative addressing)"
+  (COND-CTI !UNCOND-CTI)
+  "bt ${rel26}"
+  (+ OPC_BT rel26)
+  (.pmacro ()
+           (cbi-transfer-control msr-psr-cc rel26)
+           )
+ )
+(define-cbi
+  bf
+  "branch if condition is false (pc relative addressing)"
+  (COND-CTI !UNCOND-CTI)
+  "bf ${rel26}"
+  (+ OPC_BF rel26)
+  (.pmacro ()
+           (cbi-transfer-control (not msr-psr-cc) rel26)
+           )
+ )
+
+;***************************************************************************
+; Load/Store Instructions
+;***************************************************************************
+
+(define-pmacro (load-store-addr base offset size)
+  (c-call AI "@cpu@_get_load_store_addr" base (ext SI offset) size))
+
+(dni ldb "ldb reg/simm14(reg) (signed)"
+     ()
+     "ldb $rd,${simm14}($rs1)"
+     (+ OPC_LDB rd rs1 simm14)
+     (set WI rd (ext WI (mem QI (load-store-addr rs1 simm14 1))))
+     ()
+ )
+
+(dni ldbu "ldbu reg/simm14(reg) (signed)"
+     ()
+     "ldbu $rd,${simm14}($rs1)"
+     (+ OPC_LDBU rd rs1 simm14)
+     (set UWI rd (zext UWI (mem UQI (load-store-addr rs1 simm14 1))))
+     ()
+ )
+
+(dni ldh "ldh reg/simm14(reg) (signed)"
+     ()
+     "ldh $rd,${simm14}($rs1)"
+     (+ OPC_LDH rd rs1 simm14)
+     (set WI rd (ext WI (mem HI (load-store-addr rs1 simm14 2))))
+     ()
+ )
+
+(dni ldhu "ldhu reg/simm14(reg) (signed)"
+     ()
+     "ldhu $rd,${simm14}($rs1)"
+     (+ OPC_LDHU rd rs1 simm14)
+     (set UWI rd (zext UWI (mem UHI (load-store-addr rs1 simm14 2))))
+     ()
+ )
+
+(dni ldw "ldw reg/simm14(reg) (signed)"
+     ()
+     "ldw $rd,${simm14}($rs1)"
+     (+ OPC_LDWU rd rs1 simm14) ;; 32bit implementation only.
+     (set WI rd (ext WI (mem SI (load-store-addr rs1 simm14 4))))
+     ()
+ )
+
+(dni ldwu "ldwu reg/simm14(reg) (signed)"
+     ()
+     "ldwu $rd,${simm14}($rs1)"
+     (+ OPC_LDWU rd rs1 simm14) ;; 32bit implementation only.
+     (set UWI rd (zext UWI (mem USI (load-store-addr rs1 simm14 4))))
+     ()
+ )
+
+(define-pmacro (store-insn mnemonic tp opc-op mode size)
+  (begin
+     (dni mnemonic
+          (.str mnemonic " simm14(reg)/reg")
+          ()
+          (.str "st" tp " ${simm14}($rd),$rs1")
+          (+ opc-op rd rs1 simm14)
+          (sequence ((SI addr))
+                    (set addr (load-store-addr rd simm14 size))
+                    (set mode (mem mode addr) (trunc mode rs1))
+           )
+          ()
+     )
+   )
+ )
+
+(store-insn stb "b"  OPC_STB UQI 1)
+(store-insn sth "h"  OPC_STH UHI 2)
+(store-insn stw "w"  OPC_STW USI 4)
+
+;***************************************************************************
+; Exception Instructions
+;***************************************************************************
+
+(dni syscall "syscall"
+     ()
+
+     "syscall ${uimm14}"
+     (+ OPC_SYSCALL (f-res-rd 0) (f-res-rs1 0) uimm14)
+     ; Do exception entry handling in C function, PC set based on SR state
+     (raise-exception EXCEPT-ESYSCALL)
+     ()
+ )
+
+(dni ret "resume from exception"
+     (FORCED-CTI)
+
+     "ret"
+     (+ OPC_RET (f-res-rd 0) (f-res-rs1 0) (f-res-imm14 0))
+     (c-call VOID "@cpu@_ret")
+     ()
+ )
+
+;***************************************************************************
+; Barriar Instructions
+;***************************************************************************
+
+(dni mbarr "memory barrier"
+     ()
+     "mbarr"
+     (+ OPC_MBARR (f-res-rd 0) (f-res-rs1 0) (f-res-imm14 0))
+     (nop)
+     ()
+ )
+
+;***************************************************************************
+; Virt -Atomics Instructions
+;***************************************************************************
+
+(dni ldwa "ldwa"
+     ()
+     "ldwa $rd,${simm14}($rs1)"
+     (+ OPC_LDWA rd rs1 simm14)
+     (sequence ()
+               (set UWI rd (zext UWI (mem USI (load-store-addr rs1 simm14 4))))
+               (set atomic-flag (const 1))
+               (set atomic-addr (load-store-addr rs1 simm14 4))
+               )
+     ()
+ )
+
+(dni stwa "stwa"
+     ()
+     "stwa ${simm14}($rd),$rs1"
+     (+ OPC_STWA rd rs1 simm14)
+     (sequence ((SI addr) (BI flag))
+	       (set addr (load-store-addr rd simm14 4))
+	       (set msr-psr-cc (and atomic-flag (eq addr atomic-addr)))
+	       (if msr-psr-cc
+		   (set USI (mem USI addr) (trunc USI rs1))
+		   )
+	       (set atomic-flag (const 0))
+	       )
+     ()
+ )
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/cpu/ncpu32k.opc binutils-ncpu32k-2.32/cpu/ncpu32k.opc
--- binutils-2.32/cpu/ncpu32k.opc	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/cpu/ncpu32k.opc	2020-02-12 15:17:34.803413737 +0800
@@ -0,0 +1,307 @@
+/* nano-CPU32k opcode support.  -*- C -*-
+   Copyright 2019 Free Software Foundation, Inc.
+
+   This file is part of the GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>. */
+
+
+/* Each section is delimited with start and end markers.
+
+   <arch>-opc.h additions use: "-- opc.h"
+   <arch>-opc.c additions use: "-- opc.c"
+   <arch>-asm.c additions use: "-- asm.c"
+   <arch>-dis.c additions use: "-- dis.c"
+   <arch>-ibd.h additions use: "-- ibd.h"  */
+
+/* -- opc.h */
+
+#undef  CGEN_DIS_HASH_SIZE
+#define CGEN_DIS_HASH_SIZE 256
+#undef  CGEN_DIS_HASH
+#define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] & 0x3f) /* opcode[5..0] */
+
+/* -- */
+
+/* -- opc.c */
+/* -- */
+
+/* -- asm.c */
+
+static const char * MISSING_CLOSING_PARENTHESIS = N_("missing `)'");
+
+#define CGEN_VERBOSE_ASSEMBLER_ERRORS
+
+static const char *
+parse_rel26 (CGEN_CPU_DESC cd,
+	      const char ** strp,
+	      int opindex,
+	      int opinfo ATTRIBUTE_UNUSED,
+	      enum cgen_parse_operand_result * resultp,
+	      bfd_vma * valuep)
+{
+  const char *str = *strp;
+  const char *errmsg = NULL;
+  bfd_reloc_code_real_type reloc = BFD_RELOC_NCPU32K_INSN_REL26;
+  
+  if (strncasecmp (str, "plt(", 4) == 0)
+    {
+      *strp = str + 4;
+      reloc = BFD_RELOC_NCPU32K_PLT_REL26;
+    }
+
+  errmsg = cgen_parse_address (cd, strp, opindex, reloc, resultp, valuep);
+
+  if (reloc != BFD_RELOC_NCPU32K_INSN_REL26)
+    {
+      if (**strp != ')')
+	errmsg = MISSING_CLOSING_PARENTHESIS;
+      else
+	++*strp;
+    }
+  return errmsg;
+}
+
+static const char *
+parse_simm14 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
+{
+  const char *errmsg;
+  enum cgen_parse_operand_result result_type;
+  long ret;
+
+  if (**strp == '#')
+    ++*strp;
+
+  if (strncasecmp (*strp, "hi14(", 5) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 5;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NCPU32K_INSN_HI14,
+				   & result_type, & value);
+      if (**strp != ')')
+	errmsg = MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret >>= 18;
+	  ret &= 0x3fff;
+	  ret = (ret ^ 0x2000) - 0x2000;
+	}
+    }
+  else if (strncasecmp (*strp, "lo(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NCPU32K_INSN_LO14,
+				   & result_type, & value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret &= 0x3fff;
+	  ret = (ret ^ 0x2000) - 0x2000;
+	}
+    }
+  else if (strncasecmp (*strp, "got_pcrel_lo(", 13) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 13;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+				   BFD_RELOC_NCPU32K_GOT_PCREL_LO14,
+				   &result_type, &value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	value &= 0x3fff;
+      ret = value;
+    }
+  else if (strncasecmp (*strp, "gotoff_lo(", 10) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 10;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+				   BFD_RELOC_NCPU32K_GOTOFF_LO14,
+				   &result_type, &value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	value &= 0x3fff;
+      ret = value;
+    }
+  else if (strncasecmp (*strp, "got(", 4) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 4;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NCPU32K_GOT14,
+				   & result_type, & value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	value &= 0x3fff;
+      ret = value;
+    }
+  else
+    {
+      long value;
+      errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
+      ret = value;
+    }
+
+  if (errmsg == NULL)
+    *valuep = ret;
+
+  return errmsg;
+}
+
+static const char *
+parse_uimm14 (CGEN_CPU_DESC cd, const char ** strp, int opindex, unsigned long * valuep)
+{
+  const char *errmsg = parse_simm14(cd, strp, opindex, (long *) valuep);
+
+  if (errmsg == NULL)
+    *valuep &= 0x3fff;
+  return errmsg;
+}
+
+
+static const char *
+parse_simm18 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
+{
+  const char *errmsg;
+  enum cgen_parse_operand_result result_type;
+  long ret;
+
+  if (**strp == '#')
+    ++*strp;
+
+  if (strncasecmp (*strp, "hi(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NCPU32K_INSN_HI18,
+				   & result_type, & value);
+      if (**strp != ')')
+	errmsg = MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret >>= 14;
+	  ret &= 0x3ffff;
+	  ret = (ret ^ 0x20000) - 0x20000;
+	}
+    }
+  else if (strncasecmp (*strp, "lo18(", 5) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 5;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NCPU32K_INSN_LO18,
+				   & result_type, & value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret &= 0x3ffff;
+	  ret = (ret ^ 0x20000) - 0x20000;
+	}
+    }
+  else if (strncasecmp (*strp, "got_pcrel_hi(", 13) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 13;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+				   BFD_RELOC_NCPU32K_GOT_PCREL_HI18,
+				   & result_type, & value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	value = (value >> 14) & 0x3ffff;
+      ret = value;
+    }
+  else if (strncasecmp (*strp, "gotoff_hi(", 10) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 10;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+				   BFD_RELOC_NCPU32K_GOTOFF_HI18,
+				   & result_type, & value);
+
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	value = (value >> 14) & 0x3ffff;
+      ret = value;
+    }
+  else
+    {
+      long value;
+      errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
+      ret = value;
+    }
+
+  if (errmsg == NULL)
+    *valuep = ret;
+
+  return errmsg;
+}
+
+static const char *
+parse_uimm18 (CGEN_CPU_DESC cd, const char ** strp, int opindex, unsigned long * valuep)
+{
+  const char *errmsg = parse_simm18(cd, strp, opindex, (long *) valuep);
+
+  if (errmsg == NULL)
+    *valuep &= 0x3ffff;
+  return errmsg;
+}
+
+/* -- */
+
+/* -- ibd.h */
+
+/* -- */
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/elfcpp/elfcpp.h binutils-ncpu32k-2.32/elfcpp/elfcpp.h
--- binutils-2.32/elfcpp/elfcpp.h	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/elfcpp/elfcpp.h	2019-07-31 11:35:54.387898769 +0800
@@ -286,7 +286,9 @@
   // Vitesse IQ2000
   EM_IQ2000 = 0xfeba,
   // NIOS
-  EM_NIOS32 = 0xfebb
+  EM_NIOS32 = 0xfebb,
+  // NCPU32k
+  EM_NCPU32K = 0x4e43
   // Old AVR objects used 0x1057 (EM_AVR is correct).
   // Old MSP430 objects used 0x1059 (EM_MSP430 is correct).
   // Old FR30 objects used 0x3330 (EM_FR30 is correct).
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/gas/config/tc-ncpu32k.c binutils-ncpu32k-2.32/gas/config/tc-ncpu32k.c
--- binutils-2.32/gas/config/tc-ncpu32k.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/config/tc-ncpu32k.c	2020-02-04 21:04:57.089314488 +0800
@@ -0,0 +1,371 @@
+/* tc-ncpu32k.c -- Assembler for the nano-CPU32k processor.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/> */
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+#include "symcat.h"
+#include "opcodes/ncpu32k-desc.h"
+#include "opcodes/ncpu32k-opc.h"
+#include "cgen.h"
+#include "elf/ncpu32k.h"
+#include "dw2gencfi.h"
+
+/* Structure to hold all of the different components describing
+   an individual instruction.  */
+
+typedef struct
+{
+  const CGEN_INSN *     insn;
+  const CGEN_INSN *     orig_insn;
+  CGEN_FIELDS           fields;
+#if CGEN_INT_INSN_P
+  CGEN_INSN_INT         buffer [1];
+#define INSN_VALUE(buf) (*(buf))
+#else
+  unsigned char         buffer [CGEN_MAX_INSN_SIZE];
+#define INSN_VALUE(buf) (buf)
+#endif
+  char *                addr;
+  fragS *               frag;
+  int                   num_fixups;
+  fixS *                fixups [GAS_CGEN_MAX_FIXUPS];
+  int                   indices [MAX_OPERAND_INSTANCES];
+}
+ncpu32k_insn;
+
+/* Bit length of REL field */
+#define N_REL_BITS 26
+
+const char comment_chars[]        = "#";
+const char line_comment_chars[]   = "#";
+const char line_separator_chars[] = ";";
+const char EXP_CHARS[]            = "eE";
+const char FLT_CHARS[]            = "dD";
+
+#define NCPU32K_SHORTOPTS "m:"
+const char * md_shortopts = NCPU32K_SHORTOPTS;
+
+struct option md_longopts[] =
+{
+  {NULL, no_argument, NULL, 0}
+};
+size_t md_longopts_size = sizeof (md_longopts);
+
+unsigned long ncpu32k_machine = 0; /* default */
+
+int
+md_parse_option (int c ATTRIBUTE_UNUSED, const char * arg ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+void
+md_show_usage (FILE * stream ATTRIBUTE_UNUSED)
+{
+}
+
+static void
+ignore_pseudo (int val ATTRIBUTE_UNUSED)
+{
+  discard_rest_of_line ();
+}
+
+const char ncpu32k_comment_chars [] = ";#";
+
+/* The target specific pseudo-ops which we support.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  { "align",    s_align_bytes,  0 },
+  { "word",     cons,           4 },
+  { "proc",     ignore_pseudo,  0 },
+  { "endproc",  ignore_pseudo,  0 },
+  { NULL,       NULL,           0 }
+};
+
+
+void
+md_begin (void)
+{
+  /* Initialize the `cgen' interface.  */
+
+  /* Set the machine number and endian.  */
+  gas_cgen_cpu_desc = ncpu32k_cgen_cpu_open (CGEN_CPU_OPEN_MACHS, 0,
+                                              CGEN_CPU_OPEN_ENDIAN,
+                                              CGEN_ENDIAN_LITTLE, /* le */
+                                              CGEN_CPU_OPEN_END);
+  ncpu32k_cgen_init_asm (gas_cgen_cpu_desc);
+
+  /* This is a callback from cgen to gas to parse operands.  */
+  cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);
+}
+
+void
+md_assemble (char * str)
+{
+  static int last_insn_had_delay_slot = 0;
+  ncpu32k_insn insn;
+  char *    errmsg;
+
+  /* Initialize GAS's cgen interface for a new instruction.  */
+  gas_cgen_init_parse ();
+
+  insn.insn = ncpu32k_cgen_assemble_insn
+    (gas_cgen_cpu_desc, str, & insn.fields, insn.buffer, & errmsg);
+
+  if (!insn.insn)
+    {
+      as_bad ("%s", errmsg);
+      return;
+    }
+
+  /* Doesn't really matter what we pass for RELAX_P here.  */
+  gas_cgen_finish_insn (insn.insn, insn.buffer,
+                        CGEN_FIELDS_BITSIZE (& insn.fields), 1, NULL);
+
+  last_insn_had_delay_slot
+    = CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_DELAY_SLOT);
+  (void) last_insn_had_delay_slot;
+}
+
+void
+md_operand (expressionS * expressionP)
+{
+  if (* input_line_pointer == '#')
+    {
+      input_line_pointer ++;
+      expression (expressionP);
+    }
+}
+
+valueT
+md_section_align (segT segment, valueT size)
+{
+  int align = bfd_get_section_alignment (stdoutput, segment);
+  return ((size + (1 << align) - 1) & -(1 << align));
+}
+
+symbolS *
+md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+
+/* Interface to relax_segment.  */
+
+const relax_typeS md_relax_table[] =
+{
+/* The fields are:
+   1) most positive reach of this state,
+   2) most negative reach of this state,
+   3) how many bytes this mode will add to the size of the current frag
+   4) which index into the table to try if we can't fit into this one.  */
+
+  /* The first entry must be unused because an `rlx_more' value of zero ends
+     each list.  */
+  {1, 1, 0, 0},
+
+  /* The displacement used by GAS is from the end of the 4 byte insn,
+     so we subtract 4 from the following.  */
+  {(((1 << (N_REL_BITS-1)) - 1) << 1) - 4, -((1 << (N_REL_BITS-1)) << 1) - 4, 0, 0},
+};
+
+int
+md_estimate_size_before_relax (fragS * fragP, segT segment ATTRIBUTE_UNUSED)
+{
+  return md_relax_table[fragP->fr_subtype].rlx_length;
+}
+
+/* *fragP has been relaxed to its final size, and now needs to have
+   the bytes inside it modified to conform to the new size.
+
+   Called after relaxation is finished.
+   fragP->fr_type == rs_machine_dependent.
+   fragP->fr_subtype is the subtype of what the address relaxed to.  */
+
+void
+md_convert_frag (bfd *   abfd ATTRIBUTE_UNUSED,
+                 segT    sec  ATTRIBUTE_UNUSED,
+                 fragS * fragP ATTRIBUTE_UNUSED)
+{
+  /* FIXME */
+}
+
+
+/* Functions concerning relocs.  */
+
+/* The location from which a PC relative jump should be calculated,
+   given a PC relative reloc.  */
+
+long
+md_pcrel_from_section (fixS * fixP, segT sec)
+{
+  if (fixP->fx_addsy != (symbolS *) NULL
+      && (! S_IS_DEFINED (fixP->fx_addsy)
+          || (S_GET_SEGMENT (fixP->fx_addsy) != sec)
+          || S_IS_EXTERNAL (fixP->fx_addsy)
+          || S_IS_WEAK (fixP->fx_addsy)))
+    {
+        /* The symbol is undefined (or is defined but not in this section).
+         Let the linker figure it out.  */
+      return 0;
+    }
+
+  return fixP->fx_frag->fr_address + fixP->fx_where;
+}
+
+
+/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.
+   Returns BFD_RELOC_NONE if no reloc type can be found.
+   *FIXP may be modified if desired.  */
+
+bfd_reloc_code_real_type
+md_cgen_lookup_reloc (const CGEN_INSN *    insn ATTRIBUTE_UNUSED,
+                      const CGEN_OPERAND * operand,
+                      fixS *               fixP)
+{
+  if (fixP->fx_cgen.opinfo)
+    return fixP->fx_cgen.opinfo;
+
+  switch (operand->type)
+    {
+    case NCPU32K_OPERAND_REL26:
+      fixP->fx_pcrel = 1;
+      return BFD_RELOC_NCPU32K_INSN_REL26;
+
+    default: /* avoid -Wall warning */
+      return BFD_RELOC_NONE;
+    }
+}
+
+/* Write a value out to the object file, using the appropriate endianness.  */
+
+void
+md_number_to_chars (char * buf, valueT val, int n)
+{
+  number_to_chars_littleendian (buf, val, n);
+}
+
+/* Turn a string in input_line_pointer into a floating point constant of type
+   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
+   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.  */
+
+/* Equal to MAX_PRECISION in atof-ieee.c.  */
+#define MAX_LITTLENUMS 6
+
+const char *
+md_atof (int type, char * litP, int *  sizeP)
+{
+  return ieee_md_atof (type, litP, sizeP, TRUE);
+}
+
+bfd_boolean
+ncpu32k_fix_adjustable (fixS * fixP)
+{
+  /* We need the symbol name for the VTABLE entries.  */
+  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return FALSE;
+
+  return TRUE;
+}
+
+#define GOT_NAME "_GLOBAL_OFFSET_TABLE_"
+
+arelent *
+tc_gen_reloc (asection * section, fixS * fixp)
+{
+  arelent *reloc;
+  bfd_reloc_code_real_type code;
+
+  reloc = XNEW (arelent);
+
+  reloc->sym_ptr_ptr = XNEW (asymbol *);
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+
+  if (fixp->fx_pcrel)
+    {
+      if (section->use_rela_p)
+        fixp->fx_offset -= md_pcrel_from_section (fixp, section);
+      else
+        fixp->fx_offset = reloc->address;
+    }
+  reloc->addend = fixp->fx_offset;
+
+  code = fixp->fx_r_type;
+  switch (code)
+    {
+    case BFD_RELOC_16:
+      if (fixp->fx_pcrel)
+        code = BFD_RELOC_16_PCREL;
+      break;
+
+    case BFD_RELOC_32:
+      if (fixp->fx_pcrel)
+        code = BFD_RELOC_32_PCREL;
+      break;
+
+    case BFD_RELOC_64:
+      if (fixp->fx_pcrel)
+        code = BFD_RELOC_64_PCREL;
+      break;
+
+    default:
+      break;
+    }
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+                    _
+                    ("cannot represent %s relocation in this object file format"),
+                    bfd_get_reloc_code_name (code));
+      return NULL;
+    }
+
+  return reloc;
+}
+
+void
+ncpu32k_apply_fix (struct fix *f, valueT *t, segT s)
+{
+  gas_cgen_md_apply_fix (f, t, s);
+
+  switch (f->fx_r_type)
+    {
+    //FIXME!
+    default:
+      break;
+    }
+}
+
+void
+ncpu32k_elf_final_processing (void)
+{
+}
+
+/* Standard calling conventions leave the CFA at SP on entry.  */
+
+void
+ncpu32k_cfi_frame_initial_instructions (void)
+{
+    cfi_add_CFA_def_cfa_register (1);
+}
+
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/gas/config/tc-ncpu32k.h binutils-ncpu32k-2.32/gas/config/tc-ncpu32k.h
--- binutils-2.32/gas/config/tc-ncpu32k.h	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/config/tc-ncpu32k.h	2020-01-14 16:19:37.596154952 +0800
@@ -0,0 +1,77 @@
+/* tc-ncpu32k.h -- Header file for tc-ncpu32k.c.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/> */
+
+#define TC_NCPU32K
+
+#define LISTING_HEADER "nano-cpu32k GAS "
+
+/* The target BFD architecture.  */
+#define TARGET_ARCH bfd_arch_ncpu32k
+
+extern unsigned long ncpu32k_machine;
+#define TARGET_MACH (ncpu32k_machine)
+
+#define TARGET_FORMAT           "elf32-ncpu32k"
+#define TARGET_BYTES_BIG_ENDIAN 0 /* le */
+
+extern const char ncpu32k_comment_chars [];
+#define tc_comment_chars ncpu32k_comment_chars
+
+/* Permit temporary numeric labels.  */
+#define LOCAL_LABELS_FB 1
+
+#define DIFF_EXPR_OK    1       /* .-foo gets turned into PC relative relocs.  */
+
+/* Turn off 'Broken Words'.  */
+#define WORKING_DOT_WORD
+
+/* Values passed to md_apply_fix don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+#define md_apply_fix ncpu32k_apply_fix
+extern void ncpu32k_apply_fix (struct fix *, valueT *, segT);
+
+extern bfd_boolean ncpu32k_fix_adjustable (struct fix *);
+#define tc_fix_adjustable(FIX) ncpu32k_fix_adjustable (FIX)
+
+/* Call md_pcrel_from_section(), not md_pcrel_from().  */
+extern long md_pcrel_from_section (struct fix *, segT);
+#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from_section (FIX, SEC)
+
+/* Relax PC relative references. For 8 vs 16 vs 32 bit branch selection.  */
+extern const struct relax_type md_relax_table[];
+#define TC_GENERIC_RELAX_TABLE md_relax_table
+
+#define elf_tc_final_processing ncpu32k_elf_final_processing
+void ncpu32k_elf_final_processing (void);
+
+/* Enable cfi directives.  */
+#define TARGET_USE_CFIPOP 1
+
+/* Stack grows to lower addresses and wants 4 byte boundary.  */
+#define DWARF2_CIE_DATA_ALIGNMENT -4
+
+/* Define the column that represents the PC.  */
+#define DWARF2_DEFAULT_RETURN_COLUMN 1
+
+/* minimum ncpu32k instructions are 4 bytes long.  */
+#define DWARF2_LINE_MIN_INSN_LENGTH     4
+
+#define tc_cfi_frame_initial_instructions \
+    ncpu32k_cfi_frame_initial_instructions
+extern void ncpu32k_cfi_frame_initial_instructions (void);
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/gas/configure binutils-ncpu32k-2.32/gas/configure
--- binutils-2.32/gas/configure	2019-02-02 23:50:20.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/configure	2019-08-12 16:22:55.221162579 +0800
@@ -12852,6 +12852,10 @@
 	using_cgen=yes
 	;;
 
+      ncpu32k)
+	using_cgen=yes
+	;;
+
       nds32)
 	# setup NDS32_LINUX_TOOLCHAIN definition
 	if test "linux" = $em; then
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/gas/configure.ac binutils-ncpu32k-2.32/gas/configure.ac
--- binutils-2.32/gas/configure.ac	2019-02-01 19:19:06.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/configure.ac	2019-07-30 18:22:23.224387558 +0800
@@ -454,6 +454,10 @@
 	using_cgen=yes
 	;;
 
+      ncpu32k)
+	using_cgen=yes
+	;;
+
       nds32)
 	# setup NDS32_LINUX_TOOLCHAIN definition
 	if test "linux" = $em; then
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/gas/configure.tgt binutils-ncpu32k-2.32/gas/configure.tgt
--- binutils-2.32/gas/configure.tgt	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/configure.tgt	2019-07-30 18:19:46.876383681 +0800
@@ -332,6 +332,9 @@
 
   msp430-*-*)				fmt=elf ;;
 
+  ncpu32k-*-elf*)			fmt=elf endian=little ;;
+  ncpu32k-*-linux*)			fmt=elf em=linux endian=little ;;
+
   nds32-*-elf*)				fmt=elf ;;
   nds32-*-linux*)			fmt=elf em=linux ;;
 
@@ -438,7 +441,7 @@
 esac
 
 case ${cpu_type} in
-  aarch64 | alpha | arm | csky | i386 | ia64 | microblaze | mips | ns32k | or1k | or1knd | pdp11 | ppc | riscv | sparc | z80 | z8k)
+  aarch64 | alpha | arm | csky | i386 | ia64 | microblaze | mips | ncpu32k | ns32k | or1k | or1knd | pdp11 | ppc | riscv | sparc | z80 | z8k)
     bfd_gas=yes
     ;;
 esac
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/gas/Makefile.am binutils-ncpu32k-2.32/gas/Makefile.am
--- binutils-2.32/gas/Makefile.am	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/Makefile.am	2019-07-31 11:29:50.671889750 +0800
@@ -168,6 +168,7 @@
 	config/tc-moxie.c \
 	config/tc-msp430.c \
 	config/tc-mt.c \
+	config/tc-ncpu32k.c \
 	config/tc-nds32.c \
 	config/tc-nios2.c \
 	config/tc-ns32k.c \
@@ -242,6 +243,7 @@
 	config/tc-mn10300.h \
 	config/tc-msp430.h \
 	config/tc-mt.h \
+	confog/tc-ncpu32k.h \
 	config/tc-nds32.h \
 	config/tc-nios2.h \
 	config/tc-ns32k.h \
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/gas/Makefile.in binutils-ncpu32k-2.32/gas/Makefile.in
--- binutils-2.32/gas/Makefile.in	2019-02-02 23:50:20.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/Makefile.in	2019-08-12 16:20:58.521159685 +0800
@@ -557,6 +557,7 @@
 	config/tc-moxie.c \
 	config/tc-msp430.c \
 	config/tc-mt.c \
+	config/tc-ncpu32k.c \
 	config/tc-nds32.c \
 	config/tc-nios2.c \
 	config/tc-ns32k.c \
@@ -631,6 +632,7 @@
 	config/tc-mn10300.h \
 	config/tc-msp430.h \
 	config/tc-mt.h \
+	confog/tc-ncpu32k.h \
 	config/tc-nds32.h \
 	config/tc-nios2.h \
 	config/tc-ns32k.h \
@@ -964,6 +966,8 @@
 	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-mt.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
+config/tc-ncpu32k.$(OBJEXT): config/$(am__dirstamp) \
+	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-nds32.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-nios2.$(OBJEXT): config/$(am__dirstamp) \
@@ -1184,6 +1188,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-moxie.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-msp430.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-mt.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-ncpu32k.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-nds32.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-nios2.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-ns32k.Po@am__quote@
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/include/elf/common.h binutils-ncpu32k-2.32/include/elf/common.h
--- binutils-2.32/include/elf/common.h	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/include/elf/common.h	2019-07-30 18:08:30.384366907 +0800
@@ -440,6 +440,8 @@
    architecture was derived.  */
 #define EM_CSKY_OLD		EM_MCORE
 
+#define EM_NCPU32K		0x4e43	/* nano-CPU32K processor */
+
 /* See the above comment before you add a new EM_* value here.  */
 
 /* Values for e_version.  */
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/include/elf/ncpu32k.h binutils-ncpu32k-2.32/include/elf/ncpu32k.h
--- binutils-2.32/include/elf/ncpu32k.h	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/include/elf/ncpu32k.h	2020-02-12 15:05:19.959455079 +0800
@@ -0,0 +1,50 @@
+/* nano-CPU32k ELF support for BFD.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/> */
+
+#ifndef _ELF_NCPU32K_H
+#define _ELF_NCPU32K_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocations.  */
+START_RELOC_NUMBERS (elf_ncpu32k_reloc_type)
+  RELOC_NUMBER (R_NCPU32K_NONE,           0)
+  RELOC_NUMBER (R_NCPU32K_32,             1)
+  RELOC_NUMBER (R_NCPU32K_16,             2)
+  RELOC_NUMBER (R_NCPU32K_8,              3)
+  RELOC_NUMBER (R_NCPU32K_INSN_LO14,      4)
+  RELOC_NUMBER (R_NCPU32K_INSN_HI14,      5)
+  RELOC_NUMBER (R_NCPU32K_INSN_LO18,      6)
+  RELOC_NUMBER (R_NCPU32K_INSN_HI18,      7)
+  RELOC_NUMBER (R_NCPU32K_INSN_REL26,     8)
+  RELOC_NUMBER (R_NCPU32K_GNU_VTENTRY,    9)
+  RELOC_NUMBER (R_NCPU32K_GNU_VTINHERIT, 10)
+  RELOC_NUMBER (R_NCPU32K_COPY,          11)
+  RELOC_NUMBER (R_NCPU32K_GLOB_DAT,      12)
+  RELOC_NUMBER (R_NCPU32K_JMP_SLOT,      13)
+  RELOC_NUMBER (R_NCPU32K_RELATIVE,      14)
+  RELOC_NUMBER (R_NCPU32K_GOT_PCREL_HI18,	15)
+  RELOC_NUMBER (R_NCPU32K_GOT_PCREL_LO14,	16)
+  RELOC_NUMBER (R_NCPU32K_PLT_REL26,	17)
+  RELOC_NUMBER (R_NCPU32K_GOTOFF_HI18,	18)
+  RELOC_NUMBER (R_NCPU32K_GOTOFF_LO14,	19)
+  RELOC_NUMBER (R_NCPU32K_GOT14,	20)
+END_RELOC_NUMBERS (R_NCPU32K_max)
+
+#endif /* _ELF_NCPU32K_H */
+
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/ld/configure.tgt binutils-ncpu32k-2.32/ld/configure.tgt
--- binutils-2.32/ld/configure.tgt	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/ld/configure.tgt	2019-08-12 15:47:09.917109385 +0800
@@ -510,6 +510,9 @@
 msp430-*-*)		targ_emul=msp430elf
 			targ_extra_emuls="msp430X"
 			;;
+ncpu32k-*-elf)
+			targ_emul=elf32ncpu32k ;;
+ncpu32k-*-linux*)	targ_emul=elf32ncpu32k_linux ;;
 nds32*le-*-elf*)	targ_emul=nds32elf
 			targ_extra_emuls="nds32elf16m nds32belf nds32belf16m"
 			;;
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/ld/emulparams/elf32ncpu32k_linux.sh binutils-ncpu32k-2.32/ld/emulparams/elf32ncpu32k_linux.sh
--- binutils-2.32/ld/emulparams/elf32ncpu32k_linux.sh	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/ld/emulparams/elf32ncpu32k_linux.sh	2019-08-12 15:50:56.521115004 +0800
@@ -0,0 +1,6 @@
+. ${srcdir}/emulparams/elf32ncpu32k.sh
+unset EMBEDDED
+GENERATE_SHLIB_SCRIPT=yes
+GENERATE_PIE_SCRIPT=yes
+GENERATE_COMBRELOC_SCRIPT=yes
+TEXT_START_ADDR=0x00002000
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/ld/emulparams/elf32ncpu32k.sh binutils-ncpu32k-2.32/ld/emulparams/elf32ncpu32k.sh
--- binutils-2.32/ld/emulparams/elf32ncpu32k.sh	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/ld/emulparams/elf32ncpu32k.sh	2019-08-12 15:50:24.081114199 +0800
@@ -0,0 +1,14 @@
+SCRIPT_NAME=elf
+MACHINE=
+TEMPLATE_NAME=elf32
+OUTPUT_FORMAT="elf32-ncpu32k"
+NOP=0x00000002
+TEXT_START_ADDR=0x0000
+TARGET_PAGE_SIZE=0x2000
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+EMBEDDED=yes
+ARCH=ncpu32k
+ELFSIZE=32
+INITIAL_READONLY_SECTIONS=".vectors ${RELOCATING-0} : { KEEP (*(.vectors)) }"
+NO_REL_RELOCS=yes
+COMMONPAGESIZE="CONSTANT (COMMONPAGESIZE)"
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/ld/Makefile.am binutils-ncpu32k-2.32/ld/Makefile.am
--- binutils-2.32/ld/Makefile.am	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/ld/Makefile.am	2019-08-12 19:06:23.541405781 +0800
@@ -258,6 +258,8 @@
 	eelf32moxie.c \
 	emoxiebox.c \
 	eelf32mt.c \
+	eelf32ncpu32k.c \
+	eelf32ncpu32k_linux.c \
 	eelf32or1k.c \
 	eelf32or1k_linux.c \
 	eelf32ppc.c \
@@ -1195,6 +1197,12 @@
 eelf32mt.c: $(srcdir)/emulparams/elf32mt.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
+eelf32ncpu32k.c: $(srcdir)/emulparams/elf32ncpu32k.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ncpu32k_linux.c: $(srcdir)/emulparams/elf32ncpu32k_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
 eelf32or1k.c: $(srcdir)/emulparams/elf32or1k.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/ld/Makefile.in binutils-ncpu32k-2.32/ld/Makefile.in
--- binutils-2.32/ld/Makefile.in	2019-02-02 23:54:43.000000000 +0800
+++ binutils-ncpu32k-2.32/ld/Makefile.in	2019-08-12 19:06:42.841406260 +0800
@@ -744,6 +744,8 @@
 	eelf32moxie.c \
 	emoxiebox.c \
 	eelf32mt.c \
+	eelf32ncpu32k.c \
+	eelf32ncpu32k_linux.c \
 	eelf32or1k.c \
 	eelf32or1k_linux.c \
 	eelf32ppc.c \
@@ -1334,6 +1336,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mipswindiss.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32moxie.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mt.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ncpu32k.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ncpu32k_linux.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32or1k.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32or1k_linux.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppc.Po@am__quote@
@@ -2799,6 +2803,12 @@
 eelf32mt.c: $(srcdir)/emulparams/elf32mt.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
+eelf32ncpu32k.c: $(srcdir)/emulparams/elf32ncpu32k.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ncpu32k_linux.c: $(srcdir)/emulparams/elf32ncpu32k_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
 eelf32or1k.c: $(srcdir)/emulparams/elf32or1k.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/configure binutils-ncpu32k-2.32/opcodes/configure
--- binutils-2.32/opcodes/configure	2019-02-02 23:49:37.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/configure	2019-08-12 16:24:53.633165515 +0800
@@ -12908,6 +12908,7 @@
 	bfd_mn10300_arch)	ta="$ta m10300-dis.lo m10300-opc.lo" ;;
 	bfd_mt_arch)		ta="$ta mt-asm.lo mt-desc.lo mt-dis.lo mt-ibld.lo mt-opc.lo" using_cgen=yes ;;
 	bfd_msp430_arch)	ta="$ta msp430-dis.lo msp430-decode.lo" ;;
+	bfd_ncpu32k_arch)	ta="$ta ncpu32k-asm.lo ncpu32k-desc.lo ncpu32k-dis.lo ncpu32k-ibld.lo ncpu32k-opc.lo" using_cgen=yes ;;
 	bfd_nds32_arch)		ta="$ta nds32-asm.lo nds32-dis.lo" ;;
 	bfd_nfp_arch)		ta="$ta nfp-dis.lo" ;;
 	bfd_nios2_arch)		ta="$ta nios2-dis.lo nios2-opc.lo" ;;
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/configure.ac binutils-ncpu32k-2.32/opcodes/configure.ac
--- binutils-2.32/opcodes/configure.ac	2019-01-20 00:01:34.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/configure.ac	2019-08-12 16:25:09.521165909 +0800
@@ -299,6 +299,7 @@
 	bfd_mn10300_arch)	ta="$ta m10300-dis.lo m10300-opc.lo" ;;
 	bfd_mt_arch)		ta="$ta mt-asm.lo mt-desc.lo mt-dis.lo mt-ibld.lo mt-opc.lo" using_cgen=yes ;;
 	bfd_msp430_arch)	ta="$ta msp430-dis.lo msp430-decode.lo" ;;
+	bfd_ncpu32k_arch)	ta="$ta ncpu32k-asm.lo ncpu32k-desc.lo ncpu32k-dis.lo ncpu32k-ibld.lo ncpu32k-opc.lo" using_cgen=yes ;;
 	bfd_nds32_arch)		ta="$ta nds32-asm.lo nds32-dis.lo" ;;
 	bfd_nfp_arch)		ta="$ta nfp-dis.lo" ;;
 	bfd_nios2_arch)		ta="$ta nios2-dis.lo nios2-opc.lo" ;;
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/disassemble.c binutils-ncpu32k-2.32/opcodes/disassemble.c
--- binutils-2.32/opcodes/disassemble.c	2019-01-20 00:01:34.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/disassemble.c	2019-08-12 18:09:49.341321620 +0800
@@ -64,6 +64,7 @@
 #define ARCH_moxie
 #define ARCH_mt
 #define ARCH_msp430
+#define ARCH_ncpu32k
 #define ARCH_nds32
 #define ARCH_nfp
 #define ARCH_nios2
@@ -284,6 +285,11 @@
       disassemble = print_insn_msp430;
       break;
 #endif
+#ifdef ARCH_ncpu32k
+    case bfd_arch_ncpu32k:
+      disassemble = print_insn_ncpu32k;
+      break;
+#endif
 #ifdef ARCH_nds32
     case bfd_arch_nds32:
       disassemble = print_insn_nds32;
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/disassemble.h binutils-ncpu32k-2.32/opcodes/disassemble.h
--- binutils-2.32/opcodes/disassemble.h	2019-01-20 00:01:34.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/disassemble.h	2019-07-31 11:40:56.239906253 +0800
@@ -73,6 +73,7 @@
 extern int print_insn_moxie		(bfd_vma, disassemble_info *);
 extern int print_insn_msp430		(bfd_vma, disassemble_info *);
 extern int print_insn_mt                (bfd_vma, disassemble_info *);
+extern int print_insn_ncpu32k		(bfd_vma, disassemble_info *);
 extern int print_insn_nds32		(bfd_vma, disassemble_info *);
 extern int print_insn_nfp		(bfd_vma, disassemble_info *);
 extern int print_insn_ns32k		(bfd_vma, disassemble_info *);
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/Makefile.am binutils-ncpu32k-2.32/opcodes/Makefile.am
--- binutils-2.32/opcodes/Makefile.am	2019-01-20 00:01:34.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/Makefile.am	2019-08-12 18:16:39.529331791 +0800
@@ -200,6 +200,11 @@
 	mt-dis.c \
 	mt-ibld.c \
 	mt-opc.c \
+	ncpu32k-asm.c \
+	ncpu32k-desc.c \
+	ncpu32k-dis.c \
+	ncpu32k-ibld.c \
+	ncpu32k-opc.c \
 	nds32-asm.c \
 	nds32-dis.c \
 	nfp-dis.c \
@@ -351,7 +356,7 @@
 CLEANFILES = \
 	stamp-epiphany stamp-fr30 stamp-frv stamp-ip2k stamp-iq2000 stamp-lm32 \
 	stamp-m32c stamp-m32r stamp-mep stamp-mt \
-	stamp-or1k stamp-xc16x stamp-xstormy16 \
+	stamp-ncpu32k stamp-or1k stamp-xc16x stamp-xstormy16 \
 	libopcodes.a stamp-lib
 
 
@@ -367,7 +372,7 @@
 	$(CGENDIR)/opc-opinst.scm \
 	cgen-asm.in cgen-dis.in cgen-ibld.in
 
-CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt or1k xc16x xstormy16
+CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt ncpu32k or1k xc16x xstormy16
 
 if CGEN_MAINT
 EPIPHANY_DEPS = stamp-epiphany
@@ -380,6 +385,7 @@
 M32R_DEPS = stamp-m32r
 MEP_DEPS = stamp-mep
 MT_DEPS = stamp-mt
+NCPU32K_DEPS = stamp-ncpu32k
 OR1K_DEPS = stamp-or1k
 XC16X_DEPS = stamp-xc16x
 XSTORMY16_DEPS = stamp-xstormy16
@@ -394,6 +400,7 @@
 M32R_DEPS =
 MEP_DEPS =
 MT_DEPS =
+NCPU32K_DEPS =
 OR1K_DEPS =
 XC16X_DEPS =
 XSTORMY16_DEPS =
@@ -488,6 +495,12 @@
 		archfile=$(CPUDIR)/mt.cpu \
 		opcfile=$(CPUDIR)/mt.opc extrafiles=
 
+$(srcdir)/ncpu32k-desc.h $(srcdir)/ncpu32k-desc.c $(srcdir)/ncpu32k-opc.h $(srcdir)/ncpu32k-opc.c $(srcdir)/ncpu32k-ibld.c $(srcdir)/ncpu32k-opinst.c $(srcdir)/ncpu32k-asm.c $(srcdir)/ncpu32k-dis.c: $(NCPU32K_DEPS)
+	@true
+stamp-ncpu32k: $(CGENDEPS) $(CPUDIR)/ncpu32k.cpu $(CPUDIR)/ncpu32k.opc
+	$(MAKE) run-cgen arch=ncpu32k prefix=ncpu32k options=opinst \
+		archfile=$(CPUDIR)/ncpu32k.cpu opcfile=$(CPUDIR)/ncpu32k.opc extrafiles=opinst
+
 $(srcdir)/or1k-desc.h $(srcdir)/or1k-desc.c $(srcdir)/or1k-opc.h $(srcdir)/or1k-opc.c $(srcdir)/or1k-ibld.c $(srcdir)/or1k-opinst.c $(srcdir)/or1k-asm.c $(srcdir)/or1k-dis.c: $(OR1K_DEPS)
 	@true
 stamp-or1k: $(CGENDEPS) $(CPUDIR)/or1k.cpu $(CPUDIR)/or1k.opc $(CPUDIR)/or1kcommon.cpu $(CPUDIR)/or1korbis.cpu $(CPUDIR)/or1korfpx.cpu
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/Makefile.in binutils-ncpu32k-2.32/opcodes/Makefile.in
--- binutils-2.32/opcodes/Makefile.in	2019-02-02 23:49:37.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/Makefile.in	2019-08-12 18:18:13.869334130 +0800
@@ -590,6 +590,11 @@
 	mt-dis.c \
 	mt-ibld.c \
 	mt-opc.c \
+	ncpu32k-asm.c \
+	ncpu32k-desc.c \
+	ncpu32k-dis.c \
+	ncpu32k-ibld.c \
+	ncpu32k-opc.c \
 	nds32-asm.c \
 	nds32-dis.c \
 	nfp-dis.c \
@@ -710,7 +715,7 @@
 CLEANFILES = \
 	stamp-epiphany stamp-fr30 stamp-frv stamp-ip2k stamp-iq2000 stamp-lm32 \
 	stamp-m32c stamp-m32r stamp-mep stamp-mt \
-	stamp-or1k stamp-xc16x stamp-xstormy16 \
+	stamp-ncpu32k stamp-or1k stamp-xc16x stamp-xstormy16 \
 	libopcodes.a stamp-lib
 
 CGENDIR = @cgendir@
@@ -724,7 +729,7 @@
 	$(CGENDIR)/opc-opinst.scm \
 	cgen-asm.in cgen-dis.in cgen-ibld.in
 
-CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt or1k xc16x xstormy16
+CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt ncpu32k or1k xc16x xstormy16
 @CGEN_MAINT_FALSE@EPIPHANY_DEPS = 
 @CGEN_MAINT_TRUE@EPIPHANY_DEPS = stamp-epiphany
 @CGEN_MAINT_FALSE@FR30_DEPS = 
@@ -745,6 +750,8 @@
 @CGEN_MAINT_TRUE@MEP_DEPS = stamp-mep
 @CGEN_MAINT_FALSE@MT_DEPS = 
 @CGEN_MAINT_TRUE@MT_DEPS = stamp-mt
+@CGEN_MAINT_FALSE@NCPU32K_DEPS = 
+@CGEN_MAINT_TRUE@NCPU32K_DEPS = stamp-ncpu32k
 @CGEN_MAINT_FALSE@OR1K_DEPS = 
 @CGEN_MAINT_TRUE@OR1K_DEPS = stamp-or1k
 @CGEN_MAINT_FALSE@XC16X_DEPS = 
@@ -997,6 +1004,11 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mt-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mt-ibld.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mt-opc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncpu32k-asm.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncpu32k-desc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncpu32k-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncpu32k-ibld.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncpu32k-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nds32-asm.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nds32-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nfp-dis.Plo@am__quote@
@@ -1470,6 +1482,12 @@
 		archfile=$(CPUDIR)/mt.cpu \
 		opcfile=$(CPUDIR)/mt.opc extrafiles=
 
+$(srcdir)/ncpu32k-desc.h $(srcdir)/ncpu32k-desc.c $(srcdir)/ncpu32k-opc.h $(srcdir)/ncpu32k-opc.c $(srcdir)/ncpu32k-ibld.c $(srcdir)/ncpu32k-opinst.c $(srcdir)/ncpu32k-asm.c $(srcdir)/ncpu32k-dis.c: $(NCPU32K_DEPS)
+	@true
+stamp-ncpu32k: $(CGENDEPS) $(CPUDIR)/ncpu32k.cpu $(CPUDIR)/ncpu32k.opc
+	$(MAKE) run-cgen arch=ncpu32k prefix=ncpu32k options=opinst \
+		archfile=$(CPUDIR)/ncpu32k.cpu opcfile=$(CPUDIR)/ncpu32k.opc extrafiles=opinst
+
 $(srcdir)/or1k-desc.h $(srcdir)/or1k-desc.c $(srcdir)/or1k-opc.h $(srcdir)/or1k-opc.c $(srcdir)/or1k-ibld.c $(srcdir)/or1k-opinst.c $(srcdir)/or1k-asm.c $(srcdir)/or1k-dis.c: $(OR1K_DEPS)
 	@true
 stamp-or1k: $(CGENDEPS) $(CPUDIR)/or1k.cpu $(CPUDIR)/or1k.opc $(CPUDIR)/or1kcommon.cpu $(CPUDIR)/or1korbis.cpu $(CPUDIR)/or1korfpx.cpu
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-asm.c binutils-ncpu32k-2.32/opcodes/ncpu32k-asm.c
--- binutils-2.32/opcodes/ncpu32k-asm.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-asm.c	2020-02-12 15:19:00.407408921 +0800
@@ -0,0 +1,781 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Assembler interface for targets using CGEN. -*- C -*-
+   CGEN: Cpu tools GENerator
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN.
+   - the resultant file is machine generated, cgen-asm.in isn't
+
+   Copyright (C) 1996-2019 Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+#include "opintl.h"
+#include "xregex.h"
+#include "libiberty.h"
+#include "safe-ctype.h"
+
+#undef  min
+#define min(a,b) ((a) < (b) ? (a) : (b))
+#undef  max
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+static const char * parse_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *, const char **, CGEN_FIELDS *);
+
+/* -- assembler routines inserted here.  */
+
+/* -- asm.c */
+
+static const char * MISSING_CLOSING_PARENTHESIS = N_("missing `)'");
+
+#define CGEN_VERBOSE_ASSEMBLER_ERRORS
+
+static const char *
+parse_rel26 (CGEN_CPU_DESC cd,
+	      const char ** strp,
+	      int opindex,
+	      int opinfo ATTRIBUTE_UNUSED,
+	      enum cgen_parse_operand_result * resultp,
+	      bfd_vma * valuep)
+{
+  const char *str = *strp;
+  const char *errmsg = NULL;
+  bfd_reloc_code_real_type reloc = BFD_RELOC_NCPU32K_INSN_REL26;
+
+  if (strncasecmp (str, "plt(", 4) == 0)
+    {
+      *strp = str + 4;
+      reloc = BFD_RELOC_NCPU32K_PLT_REL26;
+    }
+
+  errmsg = cgen_parse_address (cd, strp, opindex, reloc, resultp, valuep);
+
+  if (reloc != BFD_RELOC_NCPU32K_INSN_REL26)
+    {
+      if (**strp != ')')
+	errmsg = MISSING_CLOSING_PARENTHESIS;
+      else
+	++*strp;
+    }
+  return errmsg;
+}
+
+static const char *
+parse_simm14 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
+{
+  const char *errmsg;
+  enum cgen_parse_operand_result result_type;
+  long ret;
+
+  if (**strp == '#')
+    ++*strp;
+
+  if (strncasecmp (*strp, "hi14(", 5) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 5;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NCPU32K_INSN_HI14,
+				   & result_type, & value);
+      if (**strp != ')')
+	errmsg = MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret >>= 18;
+	  ret &= 0x3fff;
+	  ret = (ret ^ 0x2000) - 0x2000;
+	}
+    }
+  else if (strncasecmp (*strp, "lo(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NCPU32K_INSN_LO14,
+				   & result_type, & value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret &= 0x3fff;
+	  ret = (ret ^ 0x2000) - 0x2000;
+	}
+    }
+  else if (strncasecmp (*strp, "got_pcrel_lo(", 13) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 13;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+				   BFD_RELOC_NCPU32K_GOT_PCREL_LO14,
+				   &result_type, &value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	value &= 0x3fff;
+      ret = value;
+    }
+  else if (strncasecmp (*strp, "gotoff_lo(", 10) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 10;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+				   BFD_RELOC_NCPU32K_GOTOFF_LO14,
+				   &result_type, &value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	value &= 0x3fff;
+      ret = value;
+    }
+  else if (strncasecmp (*strp, "got(", 4) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 4;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NCPU32K_GOT14,
+				   & result_type, & value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	value &= 0x3fff;
+      ret = value;
+    }
+  else
+    {
+      long value;
+      errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
+      ret = value;
+    }
+
+  if (errmsg == NULL)
+    *valuep = ret;
+
+  return errmsg;
+}
+
+static const char *
+parse_uimm14 (CGEN_CPU_DESC cd, const char ** strp, int opindex, unsigned long * valuep)
+{
+  const char *errmsg = parse_simm14(cd, strp, opindex, (long *) valuep);
+
+  if (errmsg == NULL)
+    *valuep &= 0x3fff;
+  return errmsg;
+}
+
+
+static const char *
+parse_simm18 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
+{
+  const char *errmsg;
+  enum cgen_parse_operand_result result_type;
+  long ret;
+
+  if (**strp == '#')
+    ++*strp;
+
+  if (strncasecmp (*strp, "hi(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NCPU32K_INSN_HI18,
+				   & result_type, & value);
+      if (**strp != ')')
+	errmsg = MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret >>= 14;
+	  ret &= 0x3ffff;
+	  ret = (ret ^ 0x20000) - 0x20000;
+	}
+    }
+  else if (strncasecmp (*strp, "lo18(", 5) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 5;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_NCPU32K_INSN_LO18,
+				   & result_type, & value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret &= 0x3ffff;
+	  ret = (ret ^ 0x20000) - 0x20000;
+	}
+    }
+  else if (strncasecmp (*strp, "got_pcrel_hi(", 13) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 13;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+				   BFD_RELOC_NCPU32K_GOT_PCREL_HI18,
+				   & result_type, & value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	value = (value >> 14) & 0x3ffff;
+      ret = value;
+    }
+  else if (strncasecmp (*strp, "gotoff_hi(", 10) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 10;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+				   BFD_RELOC_NCPU32K_GOTOFF_HI18,
+				   & result_type, & value);
+
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	value = (value >> 14) & 0x3ffff;
+      ret = value;
+    }
+  else
+    {
+      long value;
+      errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
+      ret = value;
+    }
+
+  if (errmsg == NULL)
+    *valuep = ret;
+
+  return errmsg;
+}
+
+static const char *
+parse_uimm18 (CGEN_CPU_DESC cd, const char ** strp, int opindex, unsigned long * valuep)
+{
+  const char *errmsg = parse_simm18(cd, strp, opindex, (long *) valuep);
+
+  if (errmsg == NULL)
+    *valuep &= 0x3ffff;
+  return errmsg;
+}
+
+/* -- */
+
+const char * ncpu32k_cgen_parse_operand
+  (CGEN_CPU_DESC, int, const char **, CGEN_FIELDS *);
+
+/* Main entry point for operand parsing.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `parse_insn_normal', but keeping it
+   separate makes clear the interface between `parse_insn_normal' and each of
+   the handlers.  */
+
+const char *
+ncpu32k_cgen_parse_operand (CGEN_CPU_DESC cd,
+			   int opindex,
+			   const char ** strp,
+			   CGEN_FIELDS * fields)
+{
+  const char * errmsg = NULL;
+  /* Used by scalar operands that still need to be parsed.  */
+  long junk ATTRIBUTE_UNUSED;
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      errmsg = cgen_parse_keyword (cd, strp, & ncpu32k_cgen_opval_h_gpr, & fields->f_rd);
+      break;
+    case NCPU32K_OPERAND_REL26 :
+      {
+        bfd_vma value = 0;
+        errmsg = parse_rel26 (cd, strp, NCPU32K_OPERAND_REL26, 0, NULL,  & value);
+        fields->f_rel26 = value;
+      }
+      break;
+    case NCPU32K_OPERAND_RS1 :
+      errmsg = cgen_parse_keyword (cd, strp, & ncpu32k_cgen_opval_h_gpr, & fields->f_rs1);
+      break;
+    case NCPU32K_OPERAND_RS2 :
+      errmsg = cgen_parse_keyword (cd, strp, & ncpu32k_cgen_opval_h_gpr, & fields->f_rs2);
+      break;
+    case NCPU32K_OPERAND_SIMM14 :
+      errmsg = parse_simm14 (cd, strp, NCPU32K_OPERAND_SIMM14, (long *) (& fields->f_simm14));
+      break;
+    case NCPU32K_OPERAND_UIMM14 :
+      errmsg = parse_uimm14 (cd, strp, NCPU32K_OPERAND_UIMM14, (unsigned long *) (& fields->f_uimm14));
+      break;
+    case NCPU32K_OPERAND_UIMM18 :
+      errmsg = parse_uimm18 (cd, strp, NCPU32K_OPERAND_UIMM18, (unsigned long *) (& fields->f_uimm18));
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while parsing.\n"), opindex);
+      abort ();
+  }
+
+  return errmsg;
+}
+
+cgen_parse_fn * const ncpu32k_cgen_parse_handlers[] =
+{
+  parse_insn_normal,
+};
+
+void
+ncpu32k_cgen_init_asm (CGEN_CPU_DESC cd)
+{
+  ncpu32k_cgen_init_opcode_table (cd);
+  ncpu32k_cgen_init_ibld_table (cd);
+  cd->parse_handlers = & ncpu32k_cgen_parse_handlers[0];
+  cd->parse_operand = ncpu32k_cgen_parse_operand;
+#ifdef CGEN_ASM_INIT_HOOK
+CGEN_ASM_INIT_HOOK
+#endif
+}
+
+
+
+/* Regex construction routine.
+
+   This translates an opcode syntax string into a regex string,
+   by replacing any non-character syntax element (such as an
+   opcode) with the pattern '.*'
+
+   It then compiles the regex and stores it in the opcode, for
+   later use by ncpu32k_cgen_assemble_insn
+
+   Returns NULL for success, an error message for failure.  */
+
+char *
+ncpu32k_cgen_build_insn_regex (CGEN_INSN *insn)
+{
+  CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
+  const char *mnem = CGEN_INSN_MNEMONIC (insn);
+  char rxbuf[CGEN_MAX_RX_ELEMENTS];
+  char *rx = rxbuf;
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+  int reg_err;
+
+  syn = CGEN_SYNTAX_STRING (CGEN_OPCODE_SYNTAX (opc));
+
+  /* Mnemonics come first in the syntax string.  */
+  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))
+    return _("missing mnemonic in syntax string");
+  ++syn;
+
+  /* Generate a case sensitive regular expression that emulates case
+     insensitive matching in the "C" locale.  We cannot generate a case
+     insensitive regular expression because in Turkish locales, 'i' and 'I'
+     are not equal modulo case conversion.  */
+
+  /* Copy the literal mnemonic out of the insn.  */
+  for (; *mnem; mnem++)
+    {
+      char c = *mnem;
+
+      if (ISALPHA (c))
+	{
+	  *rx++ = '[';
+	  *rx++ = TOLOWER (c);
+	  *rx++ = TOUPPER (c);
+	  *rx++ = ']';
+	}
+      else
+	*rx++ = c;
+    }
+
+  /* Copy any remaining literals from the syntax string into the rx.  */
+  for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
+    {
+      if (CGEN_SYNTAX_CHAR_P (* syn))
+	{
+	  char c = CGEN_SYNTAX_CHAR (* syn);
+
+	  switch (c)
+	    {
+	      /* Escape any regex metacharacters in the syntax.  */
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
+
+#ifdef CGEN_ESCAPE_EXTENDED_REGEX
+	    case '?': case '{': case '}':
+	    case '(': case ')': case '*':
+	    case '|': case '+': case ']':
+#endif
+	      *rx++ = '\\';
+	      *rx++ = c;
+	      break;
+
+	    default:
+	      if (ISALPHA (c))
+		{
+		  *rx++ = '[';
+		  *rx++ = TOLOWER (c);
+		  *rx++ = TOUPPER (c);
+		  *rx++ = ']';
+		}
+	      else
+		*rx++ = c;
+	      break;
+	    }
+	}
+      else
+	{
+	  /* Replace non-syntax fields with globs.  */
+	  *rx++ = '.';
+	  *rx++ = '*';
+	}
+    }
+
+  /* Trailing whitespace ok.  */
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
+
+  /* But anchor it after that.  */
+  * rx++ = '$';
+  * rx = '\0';
+
+  CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
+  reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
+
+  if (reg_err == 0)
+    return NULL;
+  else
+    {
+      static char msg[80];
+
+      regerror (reg_err, (regex_t *) CGEN_INSN_RX (insn), msg, 80);
+      regfree ((regex_t *) CGEN_INSN_RX (insn));
+      free (CGEN_INSN_RX (insn));
+      (CGEN_INSN_RX (insn)) = NULL;
+      return msg;
+    }
+}
+
+
+/* Default insn parser.
+
+   The syntax string is scanned and operands are parsed and stored in FIELDS.
+   Relocs are queued as we go via other callbacks.
+
+   ??? Note that this is currently an all-or-nothing parser.  If we fail to
+   parse the instruction, we return 0 and the caller will start over from
+   the beginning.  Backtracking will be necessary in parsing subexpressions,
+   but that can be handled there.  Not handling backtracking here may get
+   expensive in the case of the m68k.  Deal with later.
+
+   Returns NULL for success, an error message for failure.  */
+
+static const char *
+parse_insn_normal (CGEN_CPU_DESC cd,
+		   const CGEN_INSN *insn,
+		   const char **strp,
+		   CGEN_FIELDS *fields)
+{
+  /* ??? Runtime added insns not handled yet.  */
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  const char *str = *strp;
+  const char *errmsg;
+  const char *p;
+  const CGEN_SYNTAX_CHAR_TYPE * syn;
+#ifdef CGEN_MNEMONIC_OPERANDS
+  /* FIXME: wip */
+  int past_opcode_p;
+#endif
+
+  /* For now we assume the mnemonic is first (there are no leading operands).
+     We can parse it without needing to set up operand parsing.
+     GAS's input scrubber will ensure mnemonics are lowercase, but we may
+     not be called from GAS.  */
+  p = CGEN_INSN_MNEMONIC (insn);
+  while (*p && TOLOWER (*p) == TOLOWER (*str))
+    ++p, ++str;
+
+  if (* p)
+    return _("unrecognized instruction");
+
+#ifndef CGEN_MNEMONIC_OPERANDS
+  if (* str && ! ISSPACE (* str))
+    return _("unrecognized instruction");
+#endif
+
+  CGEN_INIT_PARSE (cd);
+  cgen_init_parse_operand (cd);
+#ifdef CGEN_MNEMONIC_OPERANDS
+  past_opcode_p = 0;
+#endif
+
+  /* We don't check for (*str != '\0') here because we want to parse
+     any trailing fake arguments in the syntax string.  */
+  syn = CGEN_SYNTAX_STRING (syntax);
+
+  /* Mnemonics come first for now, ensure valid string.  */
+  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))
+    abort ();
+
+  ++syn;
+
+  while (* syn != 0)
+    {
+      /* Non operand chars must match exactly.  */
+      if (CGEN_SYNTAX_CHAR_P (* syn))
+	{
+	  /* FIXME: While we allow for non-GAS callers above, we assume the
+	     first char after the mnemonic part is a space.  */
+	  /* FIXME: We also take inappropriate advantage of the fact that
+	     GAS's input scrubber will remove extraneous blanks.  */
+	  if (TOLOWER (*str) == TOLOWER (CGEN_SYNTAX_CHAR (* syn)))
+	    {
+#ifdef CGEN_MNEMONIC_OPERANDS
+	      if (CGEN_SYNTAX_CHAR(* syn) == ' ')
+		past_opcode_p = 1;
+#endif
+	      ++ syn;
+	      ++ str;
+	    }
+	  else if (*str)
+	    {
+	      /* Syntax char didn't match.  Can't be this insn.  */
+	      static char msg [80];
+
+	      /* xgettext:c-format */
+	      sprintf (msg, _("syntax error (expected char `%c', found `%c')"),
+		       CGEN_SYNTAX_CHAR(*syn), *str);
+	      return msg;
+	    }
+	  else
+	    {
+	      /* Ran out of input.  */
+	      static char msg [80];
+
+	      /* xgettext:c-format */
+	      sprintf (msg, _("syntax error (expected char `%c', found end of instruction)"),
+		       CGEN_SYNTAX_CHAR(*syn));
+	      return msg;
+	    }
+	  continue;
+	}
+
+#ifdef CGEN_MNEMONIC_OPERANDS
+      (void) past_opcode_p;
+#endif
+      /* We have an operand of some sort.  */
+      errmsg = cd->parse_operand (cd, CGEN_SYNTAX_FIELD (*syn), &str, fields);
+      if (errmsg)
+	return errmsg;
+
+      /* Done with this operand, continue with next one.  */
+      ++ syn;
+    }
+
+  /* If we're at the end of the syntax string, we're done.  */
+  if (* syn == 0)
+    {
+      /* FIXME: For the moment we assume a valid `str' can only contain
+	 blanks now.  IE: We needn't try again with a longer version of
+	 the insn and it is assumed that longer versions of insns appear
+	 before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */
+      while (ISSPACE (* str))
+	++ str;
+
+      if (* str != '\0')
+	return _("junk at end of line"); /* FIXME: would like to include `str' */
+
+      return NULL;
+    }
+
+  /* We couldn't parse it.  */
+  return _("unrecognized instruction");
+}
+
+/* Main entry point.
+   This routine is called for each instruction to be assembled.
+   STR points to the insn to be assembled.
+   We assume all necessary tables have been initialized.
+   The assembled instruction, less any fixups, is stored in BUF.
+   Remember that if CGEN_INT_INSN_P then BUF is an int and thus the value
+   still needs to be converted to target byte order, otherwise BUF is an array
+   of bytes in target byte order.
+   The result is a pointer to the insn's entry in the opcode table,
+   or NULL if an error occured (an error message will have already been
+   printed).
+
+   Note that when processing (non-alias) macro-insns,
+   this function recurses.
+
+   ??? It's possible to make this cpu-independent.
+   One would have to deal with a few minor things.
+   At this point in time doing so would be more of a curiosity than useful
+   [for example this file isn't _that_ big], but keeping the possibility in
+   mind helps keep the design clean.  */
+
+const CGEN_INSN *
+ncpu32k_cgen_assemble_insn (CGEN_CPU_DESC cd,
+			   const char *str,
+			   CGEN_FIELDS *fields,
+			   CGEN_INSN_BYTES_PTR buf,
+			   char **errmsg)
+{
+  const char *start;
+  CGEN_INSN_LIST *ilist;
+  const char *parse_errmsg = NULL;
+  const char *insert_errmsg = NULL;
+  int recognized_mnemonic = 0;
+
+  /* Skip leading white space.  */
+  while (ISSPACE (* str))
+    ++ str;
+
+  /* The instructions are stored in hashed lists.
+     Get the first in the list.  */
+  ilist = CGEN_ASM_LOOKUP_INSN (cd, str);
+
+  /* Keep looking until we find a match.  */
+  start = str;
+  for ( ; ilist != NULL ; ilist = CGEN_ASM_NEXT_INSN (ilist))
+    {
+      const CGEN_INSN *insn = ilist->insn;
+      recognized_mnemonic = 1;
+
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
+      /* Not usually needed as unsupported opcodes
+	 shouldn't be in the hash lists.  */
+      /* Is this insn supported by the selected cpu?  */
+      if (! ncpu32k_cgen_insn_supported (cd, insn))
+	continue;
+#endif
+      /* If the RELAXED attribute is set, this is an insn that shouldn't be
+	 chosen immediately.  Instead, it is used during assembler/linker
+	 relaxation if possible.  */
+      if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED) != 0)
+	continue;
+
+      str = start;
+
+      /* Skip this insn if str doesn't look right lexically.  */
+      if (CGEN_INSN_RX (insn) != NULL &&
+	  regexec ((regex_t *) CGEN_INSN_RX (insn), str, 0, NULL, 0) == REG_NOMATCH)
+	continue;
+
+      /* Allow parse/insert handlers to obtain length of insn.  */
+      CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);
+
+      parse_errmsg = CGEN_PARSE_FN (cd, insn) (cd, insn, & str, fields);
+      if (parse_errmsg != NULL)
+	continue;
+
+      /* ??? 0 is passed for `pc'.  */
+      insert_errmsg = CGEN_INSERT_FN (cd, insn) (cd, insn, fields, buf,
+						 (bfd_vma) 0);
+      if (insert_errmsg != NULL)
+        continue;
+
+      /* It is up to the caller to actually output the insn and any
+         queued relocs.  */
+      return insn;
+    }
+
+  {
+    static char errbuf[150];
+    const char *tmp_errmsg;
+#ifdef CGEN_VERBOSE_ASSEMBLER_ERRORS
+#define be_verbose 1
+#else
+#define be_verbose 0
+#endif
+
+    if (be_verbose)
+      {
+	/* If requesting verbose error messages, use insert_errmsg.
+	   Failing that, use parse_errmsg.  */
+	tmp_errmsg = (insert_errmsg ? insert_errmsg :
+		      parse_errmsg ? parse_errmsg :
+		      recognized_mnemonic ?
+		      _("unrecognized form of instruction") :
+		      _("unrecognized instruction"));
+
+	if (strlen (start) > 50)
+	  /* xgettext:c-format */
+	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
+	else
+	  /* xgettext:c-format */
+	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
+      }
+    else
+      {
+	if (strlen (start) > 50)
+	  /* xgettext:c-format */
+	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
+	else
+	  /* xgettext:c-format */
+	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
+      }
+
+    *errmsg = errbuf;
+    return NULL;
+  }
+}
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-desc.c binutils-ncpu32k-2.32/opcodes/ncpu32k-desc.c
--- binutils-2.32/opcodes/ncpu32k-desc.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-desc.c	2020-02-04 21:04:18.969314708 +0800
@@ -0,0 +1,1046 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* CPU data for ncpu32k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include <stdio.h>
+#include <stdarg.h>
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+#include "opintl.h"
+#include "libiberty.h"
+#include "xregex.h"
+
+/* Attributes.  */
+
+static const CGEN_ATTR_ENTRY bool_attr[] =
+{
+  { "#f", 0 },
+  { "#t", 1 },
+  { 0, 0 }
+};
+
+static const CGEN_ATTR_ENTRY MACH_attr[] ATTRIBUTE_UNUSED =
+{
+  { "base", MACH_BASE },
+  { "ncpu32k_mach", MACH_NCPU32K_MACH },
+  { "max", MACH_MAX },
+  { 0, 0 }
+};
+
+static const CGEN_ATTR_ENTRY ISA_attr[] ATTRIBUTE_UNUSED =
+{
+  { "ncpu32k_isa", ISA_NCPU32K_ISA },
+  { "max", ISA_MAX },
+  { 0, 0 }
+};
+
+const CGEN_ATTR_TABLE ncpu32k_cgen_ifield_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "RESERVED", &bool_attr[0], &bool_attr[0] },
+  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
+  { "SIGNED", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE ncpu32k_cgen_hardware_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "CACHE-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "PC", &bool_attr[0], &bool_attr[0] },
+  { "PROFILE", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE ncpu32k_cgen_operand_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
+  { "SIGNED", &bool_attr[0], &bool_attr[0] },
+  { "NEGATIVE", &bool_attr[0], &bool_attr[0] },
+  { "RELAX", &bool_attr[0], &bool_attr[0] },
+  { "SEM-ONLY", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE ncpu32k_cgen_insn_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "ALIAS", &bool_attr[0], &bool_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "UNCOND-CTI", &bool_attr[0], &bool_attr[0] },
+  { "COND-CTI", &bool_attr[0], &bool_attr[0] },
+  { "SKIP-CTI", &bool_attr[0], &bool_attr[0] },
+  { "DELAY-SLOT", &bool_attr[0], &bool_attr[0] },
+  { "RELAXABLE", &bool_attr[0], &bool_attr[0] },
+  { "RELAXED", &bool_attr[0], &bool_attr[0] },
+  { "NO-DIS", &bool_attr[0], &bool_attr[0] },
+  { "PBB", &bool_attr[0], &bool_attr[0] },
+  { "FORCED-CTI", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+/* Instruction set variants.  */
+
+static const CGEN_ISA ncpu32k_cgen_isa_table[] = {
+  { "ncpu32k-isa", 32, 32, 32, 32 },
+  { 0, 0, 0, 0, 0 }
+};
+
+/* Machine variants.  */
+
+static const CGEN_MACH ncpu32k_cgen_mach_table[] = {
+  { "ncpu32k-mach", "ncpu32k", MACH_NCPU32K_MACH, 0 },
+  { 0, 0, 0, 0 }
+};
+
+static CGEN_KEYWORD_ENTRY ncpu32k_cgen_opval_h_frs_entries[] =
+{
+  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
+  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
+  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
+  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
+  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
+  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 },
+  { "nil", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "lnk", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "sp", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "fp", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "v0", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "v1", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "v2", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "v3", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "v4", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "v5", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "rv", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "rvh", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "rtls", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "rgot", 14, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD ncpu32k_cgen_opval_h_frs =
+{
+  & ncpu32k_cgen_opval_h_frs_entries[0],
+  46,
+  0, 0, 0, 0, ""
+};
+
+static CGEN_KEYWORD_ENTRY ncpu32k_cgen_opval_h_frd_entries[] =
+{
+  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
+  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
+  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
+  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
+  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
+  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 },
+  { "nil", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "lnk", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "sp", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "fp", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "v0", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "v1", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "v2", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "v3", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "v4", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "v5", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "rv", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "rvh", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "rtls", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "rgot", 14, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD ncpu32k_cgen_opval_h_frd =
+{
+  & ncpu32k_cgen_opval_h_frd_entries[0],
+  46,
+  0, 0, 0, 0, ""
+};
+
+static CGEN_KEYWORD_ENTRY ncpu32k_cgen_opval_h_gpr_entries[] =
+{
+  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
+  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
+  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
+  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
+  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
+  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 },
+  { "nil", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "lnk", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "sp", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "fp", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "v0", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "v1", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "v2", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "v3", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "v4", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "v5", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "rv", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "rvh", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "rtls", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "rgot", 14, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD ncpu32k_cgen_opval_h_gpr =
+{
+  & ncpu32k_cgen_opval_h_gpr_entries[0],
+  46,
+  0, 0, 0, 0, ""
+};
+
+
+/* The hardware table.  */
+
+#define A(a) (1 << CGEN_HW_##a)
+
+const CGEN_HW_ENTRY ncpu32k_cgen_hw_table[] =
+{
+  { "h-memory", HW_H_MEMORY, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-sint", HW_H_SINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-uint", HW_H_UINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-addr", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-iaddr", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-frs", HW_H_FRS, CGEN_ASM_KEYWORD, (PTR) & ncpu32k_cgen_opval_h_frs, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-frd", HW_H_FRD, CGEN_ASM_KEYWORD, (PTR) & ncpu32k_cgen_opval_h_frd, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-msr", HW_H_MSR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-gpr", HW_H_GPR, CGEN_ASM_KEYWORD, (PTR) & ncpu32k_cgen_opval_h_gpr, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-pc", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PC), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-pse-psr", HW_H_PSE_PSR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-psb-psr-cc", HW_H_PSB_PSR_CC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-psr-cy", HW_H_PSB_PSR_CY, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-psr-ov", HW_H_PSB_PSR_OV, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-psr-oe", HW_H_PSB_PSR_OE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-psr-rm", HW_H_PSB_PSR_RM, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-psr-ire", HW_H_PSB_PSR_IRE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-psr-imme", HW_H_PSB_PSR_IMME, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-psr-dmme", HW_H_PSB_PSR_DMME, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-psr-icae", HW_H_PSB_PSR_ICAE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-psr-dcae", HW_H_PSB_PSR_DCAE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-cpuid-ver", HW_H_PSB_CPUID_VER, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-cpuid-rev", HW_H_PSB_CPUID_REV, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-cpuid-fimm", HW_H_PSB_CPUID_FIMM, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-cpuid-fdmm", HW_H_PSB_CPUID_FDMM, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-cpuid-fica", HW_H_PSB_CPUID_FICA, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-cpuid-fdca", HW_H_PSB_CPUID_FDCA, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-cpuid-fdbg", HW_H_PSB_CPUID_FDBG, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-cpuid-ffpu", HW_H_PSB_CPUID_FFPU, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-cpuid-firqc", HW_H_PSB_CPUID_FIRQC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-psb-cpuid-ftsc", HW_H_PSB_CPUID_FTSC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-simm14", HW_H_SIMM14, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-uimm14", HW_H_UIMM14, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-uimm18", HW_H_UIMM18, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-atomic-flag", HW_H_ATOMIC_FLAG, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-atomic-addr", HW_H_ATOMIC_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { 0, 0, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+/* The instruction field table.  */
+
+#define A(a) (1 << CGEN_IFLD_##a)
+
+const CGEN_IFLD ncpu32k_cgen_ifld_table[] =
+{
+  { NCPU32K_F_NIL, "f-nil", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_ANYOF, "f-anyof", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_OPCODE, "f-opcode", 0, 32, 5, 6, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RD, "f-rd", 0, 32, 11, 6, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RES_RD, "f-res-rd", 0, 32, 11, 6, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RS1, "f-rs1", 0, 32, 17, 6, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RES_RS1, "f-res-rs1", 0, 32, 17, 6, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RS2, "f-rs2", 0, 32, 23, 6, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RES_RS2, "f-res-rs2", 0, 32, 23, 6, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RES_ATTR, "f-res-attr", 0, 32, 31, 8, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_UIMM14, "f-uimm14", 0, 32, 31, 14, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_SIMM14, "f-simm14", 0, 32, 31, 14, { 0|A(SIGN_OPT), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RES_IMM14, "f-res-imm14", 0, 32, 31, 14, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_UIMM18, "f-uimm18", 0, 32, 29, 18, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RES_IMM2, "f-res-imm2", 0, 32, 31, 2, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_REL26, "f-rel26", 0, 32, 31, 26, { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
+  { 0, 0, 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+
+/* multi ifield declarations */
+
+
+
+/* multi ifield definitions */
+
+
+/* The operand table.  */
+
+#define A(a) (1 << CGEN_OPERAND_##a)
+#define OPERAND(op) NCPU32K_OPERAND_##op
+
+const CGEN_OPERAND ncpu32k_cgen_operand_table[] =
+{
+/* pc: program counter */
+  { "pc", NCPU32K_OPERAND_PC, HW_H_PC, 0, 0,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_NIL] } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* rs1: source operand #1 */
+  { "rs1", NCPU32K_OPERAND_RS1, HW_H_GPR, 17, 6,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_RS1] } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* rs2: source operand #2 */
+  { "rs2", NCPU32K_OPERAND_RS2, HW_H_GPR, 23, 6,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_RS2] } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* rd: destination operand */
+  { "rd", NCPU32K_OPERAND_RD, HW_H_GPR, 11, 6,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_RD] } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* simm14: 14-bit signed immediate */
+  { "simm14", NCPU32K_OPERAND_SIMM14, HW_H_SIMM14, 31, 14,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_SIMM14] } },
+    { 0|A(SIGN_OPT), { { { (1<<MACH_BASE), 0 } } } }  },
+/* uimm14: 14-bit unsigned immediate */
+  { "uimm14", NCPU32K_OPERAND_UIMM14, HW_H_UIMM14, 31, 14,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_UIMM14] } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* uimm18: 18-bit unsigned immediate */
+  { "uimm18", NCPU32K_OPERAND_UIMM18, HW_H_UIMM18, 29, 18,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_UIMM18] } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* rel26: pc-rel 26 bit address */
+  { "rel26", NCPU32K_OPERAND_REL26, HW_H_IADDR, 31, 26,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_REL26] } },
+    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
+/* msr-psr-cc: PSR Condition bit */
+  { "msr-psr-cc", NCPU32K_OPERAND_MSR_PSR_CC, HW_H_PSB_PSR_CC, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* msr-psr-cy: PSR carry bit */
+  { "msr-psr-cy", NCPU32K_OPERAND_MSR_PSR_CY, HW_H_PSB_PSR_CY, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* msr-psr-ov: PSR overflow bit */
+  { "msr-psr-ov", NCPU32K_OPERAND_MSR_PSR_OV, HW_H_PSB_PSR_OV, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* msr-psr-oe: PSR overflow exception enable bit */
+  { "msr-psr-oe", NCPU32K_OPERAND_MSR_PSR_OE, HW_H_PSB_PSR_OE, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* atomic-flag: atomic flag */
+  { "atomic-flag", NCPU32K_OPERAND_ATOMIC_FLAG, HW_H_ATOMIC_FLAG, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* atomic-addr: atomic address */
+  { "atomic-addr", NCPU32K_OPERAND_ATOMIC_ADDR, HW_H_ATOMIC_ADDR, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* sentinel */
+  { 0, 0, 0, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+/* The instruction table.  */
+
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+#define A(a) (1 << CGEN_INSN_##a)
+
+static const CGEN_IBASE ncpu32k_cgen_insn_table[MAX_INSNS] =
+{
+  /* Special null first entry.
+     A `num' value of zero is thus invalid.
+     Also, the special `invalid' insn resides here.  */
+  { 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+/* nop */
+  {
+    NCPU32K_INSN_NOP, "nop", "nop", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mov $rd,$rs1 */
+  {
+    NCPU32K_INSN_MOV, "mov", "mov", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* and $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_AND, "and", "and", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* and $rd,$rs1,$uimm14 */
+  {
+    NCPU32K_INSN_AND_I, "and.i", "and", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* or $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_OR, "or", "or", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* or $rd,$rs1,$uimm14 */
+  {
+    NCPU32K_INSN_OR_I, "or.i", "or", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* xor $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_XOR, "xor", "xor", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* xor $rd,$rs1,$simm14 */
+  {
+    NCPU32K_INSN_XOR_I, "xor.i", "xor", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lsl $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_LSL, "lsl", "lsl", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lsl $rd,$rs1,${uimm14} */
+  {
+    NCPU32K_INSN_LSL_I, "lsl.i", "lsl", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lsr $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_LSR, "lsr", "lsr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lsr $rd,$rs1,${uimm14} */
+  {
+    NCPU32K_INSN_LSR_I, "lsr.i", "lsr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* asr $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_ASR, "asr", "asr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* asr $rd,$rs1,${uimm14} */
+  {
+    NCPU32K_INSN_ASR_I, "asr.i", "asr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* add $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_ADD, "add", "add", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* add $rd,$rs1,$simm14 */
+  {
+    NCPU32K_INSN_ADD_I, "add.i", "add", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sub $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_SUB, "sub", "sub", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mul $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_MUL, "mul", "mul", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* div $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_DIV, "div", "div", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* divu $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_DIVU, "divu", "divu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mod $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_MOD, "mod", "mod", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* modu $rd,$rs1,$rs2 */
+  {
+    NCPU32K_INSN_MODU, "modu", "modu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mhi $rd,${uimm18} */
+  {
+    NCPU32K_INSN_MHI, "mhi", "mhi", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* rmsr $rd,$rs1,${uimm14} */
+  {
+    NCPU32K_INSN_RMSR, "rmsr", "rmsr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* wmsr $rd,$rs1,${uimm14} */
+  {
+    NCPU32K_INSN_WMSR, "wmsr", "wmsr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmp $rs1,eq,$rs2 */
+  {
+    NCPU32K_INSN_CMPEQ, "cmpeq", "cmp", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmp $rs1,gt,$rs2 */
+  {
+    NCPU32K_INSN_CMPGT, "cmpgt", "cmp", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* cmp $rs1,gtu,$rs2 */
+  {
+    NCPU32K_INSN_CMP, "cmp", "cmp", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* jmp $rd,$rs1 */
+  {
+    NCPU32K_INSN_JMP, "jmp", "jmp", 32,
+    { 0|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* jmp r0,${rel26} */
+  {
+    NCPU32K_INSN_JMP_I, "jmp.i", "jmp", 32,
+    { 0|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* jmp lnk,${rel26} */
+  {
+    NCPU32K_INSN_JMP_I_LNK, "jmp.i.lnk", "jmp", 32,
+    { 0|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bt ${rel26} */
+  {
+    NCPU32K_INSN_BT, "bt", "bt", 32,
+    { 0|A(COND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bf ${rel26} */
+  {
+    NCPU32K_INSN_BF, "bf", "bf", 32,
+    { 0|A(COND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ldb $rd,${simm14}($rs1) */
+  {
+    NCPU32K_INSN_LDB, "ldb", "ldb", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ldbu $rd,${simm14}($rs1) */
+  {
+    NCPU32K_INSN_LDBU, "ldbu", "ldbu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ldh $rd,${simm14}($rs1) */
+  {
+    NCPU32K_INSN_LDH, "ldh", "ldh", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ldhu $rd,${simm14}($rs1) */
+  {
+    NCPU32K_INSN_LDHU, "ldhu", "ldhu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ldw $rd,${simm14}($rs1) */
+  {
+    NCPU32K_INSN_LDW, "ldw", "ldw", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ldwu $rd,${simm14}($rs1) */
+  {
+    NCPU32K_INSN_LDWU, "ldwu", "ldwu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* stb ${simm14}($rd),$rs1 */
+  {
+    NCPU32K_INSN_STB, "stb", "stb", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sth ${simm14}($rd),$rs1 */
+  {
+    NCPU32K_INSN_STH, "sth", "sth", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* stw ${simm14}($rd),$rs1 */
+  {
+    NCPU32K_INSN_STW, "stw", "stw", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* syscall ${uimm14} */
+  {
+    NCPU32K_INSN_SYSCALL, "syscall", "syscall", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ret */
+  {
+    NCPU32K_INSN_RET, "ret", "ret", 32,
+    { 0|A(FORCED_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mbarr */
+  {
+    NCPU32K_INSN_MBARR, "mbarr", "mbarr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ldwa $rd,${simm14}($rs1) */
+  {
+    NCPU32K_INSN_LDWA, "ldwa", "ldwa", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* stwa ${simm14}($rd),$rs1 */
+  {
+    NCPU32K_INSN_STWA, "stwa", "stwa", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+};
+
+#undef OP
+#undef A
+
+/* Initialize anything needed to be done once, before any cpu_open call.  */
+
+static void
+init_tables (void)
+{
+}
+
+static const CGEN_MACH * lookup_mach_via_bfd_name (const CGEN_MACH *, const char *);
+static void build_hw_table      (CGEN_CPU_TABLE *);
+static void build_ifield_table  (CGEN_CPU_TABLE *);
+static void build_operand_table (CGEN_CPU_TABLE *);
+static void build_insn_table    (CGEN_CPU_TABLE *);
+static void ncpu32k_cgen_rebuild_tables (CGEN_CPU_TABLE *);
+
+/* Subroutine of ncpu32k_cgen_cpu_open to look up a mach via its bfd name.  */
+
+static const CGEN_MACH *
+lookup_mach_via_bfd_name (const CGEN_MACH *table, const char *name)
+{
+  while (table->name)
+    {
+      if (strcmp (name, table->bfd_name) == 0)
+	return table;
+      ++table;
+    }
+  return NULL;
+}
+
+/* Subroutine of ncpu32k_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_hw_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  int machs = cd->machs;
+  const CGEN_HW_ENTRY *init = & ncpu32k_cgen_hw_table[0];
+  /* MAX_HW is only an upper bound on the number of selected entries.
+     However each entry is indexed by it's enum so there can be holes in
+     the table.  */
+  const CGEN_HW_ENTRY **selected =
+    (const CGEN_HW_ENTRY **) xmalloc (MAX_HW * sizeof (CGEN_HW_ENTRY *));
+
+  cd->hw_table.init_entries = init;
+  cd->hw_table.entry_size = sizeof (CGEN_HW_ENTRY);
+  memset (selected, 0, MAX_HW * sizeof (CGEN_HW_ENTRY *));
+  /* ??? For now we just use machs to determine which ones we want.  */
+  for (i = 0; init[i].name != NULL; ++i)
+    if (CGEN_HW_ATTR_VALUE (&init[i], CGEN_HW_MACH)
+	& machs)
+      selected[init[i].type] = &init[i];
+  cd->hw_table.entries = selected;
+  cd->hw_table.num_entries = MAX_HW;
+}
+
+/* Subroutine of ncpu32k_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_ifield_table (CGEN_CPU_TABLE *cd)
+{
+  cd->ifld_table = & ncpu32k_cgen_ifld_table[0];
+}
+
+/* Subroutine of ncpu32k_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_operand_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  int machs = cd->machs;
+  const CGEN_OPERAND *init = & ncpu32k_cgen_operand_table[0];
+  /* MAX_OPERANDS is only an upper bound on the number of selected entries.
+     However each entry is indexed by it's enum so there can be holes in
+     the table.  */
+  const CGEN_OPERAND **selected = xmalloc (MAX_OPERANDS * sizeof (* selected));
+
+  cd->operand_table.init_entries = init;
+  cd->operand_table.entry_size = sizeof (CGEN_OPERAND);
+  memset (selected, 0, MAX_OPERANDS * sizeof (CGEN_OPERAND *));
+  /* ??? For now we just use mach to determine which ones we want.  */
+  for (i = 0; init[i].name != NULL; ++i)
+    if (CGEN_OPERAND_ATTR_VALUE (&init[i], CGEN_OPERAND_MACH)
+	& machs)
+      selected[init[i].type] = &init[i];
+  cd->operand_table.entries = selected;
+  cd->operand_table.num_entries = MAX_OPERANDS;
+}
+
+/* Subroutine of ncpu32k_cgen_cpu_open to build the hardware table.
+   ??? This could leave out insns not supported by the specified mach/isa,
+   but that would cause errors like "foo only supported by bar" to become
+   "unknown insn", so for now we include all insns and require the app to
+   do the checking later.
+   ??? On the other hand, parsing of such insns may require their hardware or
+   operand elements to be in the table [which they mightn't be].  */
+
+static void
+build_insn_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  const CGEN_IBASE *ib = & ncpu32k_cgen_insn_table[0];
+  CGEN_INSN *insns = xmalloc (MAX_INSNS * sizeof (CGEN_INSN));
+
+  memset (insns, 0, MAX_INSNS * sizeof (CGEN_INSN));
+  for (i = 0; i < MAX_INSNS; ++i)
+    insns[i].base = &ib[i];
+  cd->insn_table.init_entries = insns;
+  cd->insn_table.entry_size = sizeof (CGEN_IBASE);
+  cd->insn_table.num_init_entries = MAX_INSNS;
+}
+
+/* Subroutine of ncpu32k_cgen_cpu_open to rebuild the tables.  */
+
+static void
+ncpu32k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  CGEN_BITSET *isas = cd->isas;
+  unsigned int machs = cd->machs;
+
+  cd->int_insn_p = CGEN_INT_INSN_P;
+
+  /* Data derived from the isa spec.  */
+#define UNSET (CGEN_SIZE_UNKNOWN + 1)
+  cd->default_insn_bitsize = UNSET;
+  cd->base_insn_bitsize = UNSET;
+  cd->min_insn_bitsize = 65535; /* Some ridiculously big number.  */
+  cd->max_insn_bitsize = 0;
+  for (i = 0; i < MAX_ISAS; ++i)
+    if (cgen_bitset_contains (isas, i))
+      {
+	const CGEN_ISA *isa = & ncpu32k_cgen_isa_table[i];
+
+	/* Default insn sizes of all selected isas must be
+	   equal or we set the result to 0, meaning "unknown".  */
+	if (cd->default_insn_bitsize == UNSET)
+	  cd->default_insn_bitsize = isa->default_insn_bitsize;
+	else if (isa->default_insn_bitsize == cd->default_insn_bitsize)
+	  ; /* This is ok.  */
+	else
+	  cd->default_insn_bitsize = CGEN_SIZE_UNKNOWN;
+
+	/* Base insn sizes of all selected isas must be equal
+	   or we set the result to 0, meaning "unknown".  */
+	if (cd->base_insn_bitsize == UNSET)
+	  cd->base_insn_bitsize = isa->base_insn_bitsize;
+	else if (isa->base_insn_bitsize == cd->base_insn_bitsize)
+	  ; /* This is ok.  */
+	else
+	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
+
+	/* Set min,max insn sizes.  */
+	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	  cd->min_insn_bitsize = isa->min_insn_bitsize;
+	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+      }
+
+  /* Data derived from the mach spec.  */
+  for (i = 0; i < MAX_MACHS; ++i)
+    if (((1 << i) & machs) != 0)
+      {
+	const CGEN_MACH *mach = & ncpu32k_cgen_mach_table[i];
+
+	if (mach->insn_chunk_bitsize != 0)
+	{
+	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	    {
+	      fprintf (stderr, "ncpu32k_cgen_rebuild_tables: conflicting insn-chunk-bitsize values: `%d' vs. `%d'\n",
+		       cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
+	      abort ();
+	    }
+
+ 	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
+	}
+      }
+
+  /* Determine which hw elements are used by MACH.  */
+  build_hw_table (cd);
+
+  /* Build the ifield table.  */
+  build_ifield_table (cd);
+
+  /* Determine which operands are used by MACH/ISA.  */
+  build_operand_table (cd);
+
+  /* Build the instruction table.  */
+  build_insn_table (cd);
+}
+
+/* Initialize a cpu table and return a descriptor.
+   It's much like opening a file, and must be the first function called.
+   The arguments are a set of (type/value) pairs, terminated with
+   CGEN_CPU_OPEN_END.
+
+   Currently supported values:
+   CGEN_CPU_OPEN_ISAS:    bitmap of values in enum isa_attr
+   CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr
+   CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name
+   CGEN_CPU_OPEN_ENDIAN:  specify endian choice
+   CGEN_CPU_OPEN_END:     terminates arguments
+
+   ??? Simultaneous multiple isas might not make sense, but it's not (yet)
+   precluded.  */
+
+CGEN_CPU_DESC
+ncpu32k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
+{
+  CGEN_CPU_TABLE *cd = (CGEN_CPU_TABLE *) xmalloc (sizeof (CGEN_CPU_TABLE));
+  static int init_p;
+  CGEN_BITSET *isas = 0;  /* 0 = "unspecified" */
+  unsigned int machs = 0; /* 0 = "unspecified" */
+  enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;
+  va_list ap;
+
+  if (! init_p)
+    {
+      init_tables ();
+      init_p = 1;
+    }
+
+  memset (cd, 0, sizeof (*cd));
+
+  va_start (ap, arg_type);
+  while (arg_type != CGEN_CPU_OPEN_END)
+    {
+      switch (arg_type)
+	{
+	case CGEN_CPU_OPEN_ISAS :
+	  isas = va_arg (ap, CGEN_BITSET *);
+	  break;
+	case CGEN_CPU_OPEN_MACHS :
+	  machs = va_arg (ap, unsigned int);
+	  break;
+	case CGEN_CPU_OPEN_BFDMACH :
+	  {
+	    const char *name = va_arg (ap, const char *);
+	    const CGEN_MACH *mach =
+	      lookup_mach_via_bfd_name (ncpu32k_cgen_mach_table, name);
+
+	    if (mach != NULL)
+	      machs |= 1 << mach->num;
+	    break;
+	  }
+	case CGEN_CPU_OPEN_ENDIAN :
+	  endian = va_arg (ap, enum cgen_endian);
+	  break;
+	default :
+	  fprintf (stderr, "ncpu32k_cgen_cpu_open: unsupported argument `%d'\n",
+		   arg_type);
+	  abort (); /* ??? return NULL? */
+	}
+      arg_type = va_arg (ap, enum cgen_cpu_open_arg);
+    }
+  va_end (ap);
+
+  /* Mach unspecified means "all".  */
+  if (machs == 0)
+    machs = (1 << MAX_MACHS) - 1;
+  /* Base mach is always selected.  */
+  machs |= 1;
+  if (endian == CGEN_ENDIAN_UNKNOWN)
+    {
+      /* ??? If target has only one, could have a default.  */
+      fprintf (stderr, "ncpu32k_cgen_cpu_open: no endianness specified\n");
+      abort ();
+    }
+
+  cd->isas = cgen_bitset_copy (isas);
+  cd->machs = machs;
+  cd->endian = endian;
+  /* FIXME: for the sparc case we can determine insn-endianness statically.
+     The worry here is where both data and insn endian can be independently
+     chosen, in which case this function will need another argument.
+     Actually, will want to allow for more arguments in the future anyway.  */
+  cd->insn_endian = endian;
+
+  /* Table (re)builder.  */
+  cd->rebuild_tables = ncpu32k_cgen_rebuild_tables;
+  ncpu32k_cgen_rebuild_tables (cd);
+
+  /* Default to not allowing signed overflow.  */
+  cd->signed_overflow_ok_p = 0;
+
+  return (CGEN_CPU_DESC) cd;
+}
+
+/* Cover fn to ncpu32k_cgen_cpu_open to handle the simple case of 1 isa, 1 mach.
+   MACH_NAME is the bfd name of the mach.  */
+
+CGEN_CPU_DESC
+ncpu32k_cgen_cpu_open_1 (const char *mach_name, enum cgen_endian endian)
+{
+  return ncpu32k_cgen_cpu_open (CGEN_CPU_OPEN_BFDMACH, mach_name,
+			       CGEN_CPU_OPEN_ENDIAN, endian,
+			       CGEN_CPU_OPEN_END);
+}
+
+/* Close a cpu table.
+   ??? This can live in a machine independent file, but there's currently
+   no place to put this file (there's no libcgen).  libopcodes is the wrong
+   place as some simulator ports use this but they don't use libopcodes.  */
+
+void
+ncpu32k_cgen_cpu_close (CGEN_CPU_DESC cd)
+{
+  unsigned int i;
+  const CGEN_INSN *insns;
+
+  if (cd->macro_insn_table.init_entries)
+    {
+      insns = cd->macro_insn_table.init_entries;
+      for (i = 0; i < cd->macro_insn_table.num_init_entries; ++i, ++insns)
+	if (CGEN_INSN_RX ((insns)))
+	  regfree (CGEN_INSN_RX (insns));
+    }
+
+  if (cd->insn_table.init_entries)
+    {
+      insns = cd->insn_table.init_entries;
+      for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
+	if (CGEN_INSN_RX (insns))
+	  regfree (CGEN_INSN_RX (insns));
+    }
+
+  if (cd->macro_insn_table.init_entries)
+    free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
+
+  if (cd->insn_table.init_entries)
+    free ((CGEN_INSN *) cd->insn_table.init_entries);
+
+  if (cd->hw_table.entries)
+    free ((CGEN_HW_ENTRY *) cd->hw_table.entries);
+
+  if (cd->operand_table.entries)
+    free ((CGEN_HW_ENTRY *) cd->operand_table.entries);
+
+  free (cd);
+}
+
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-desc.h binutils-ncpu32k-2.32/opcodes/ncpu32k-desc.h
--- binutils-2.32/opcodes/ncpu32k-desc.h	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-desc.h	2020-02-04 21:04:18.961314708 +0800
@@ -0,0 +1,300 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* CPU data header for ncpu32k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef NCPU32K_CPU_H
+#define NCPU32K_CPU_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CGEN_ARCH ncpu32k
+
+/* Given symbol S, return ncpu32k_cgen_<S>.  */
+#define CGEN_SYM(s) ncpu32k##_cgen_##s
+
+
+/* Selected cpu families.  */
+#define HAVE_CPU_NCPU32K
+
+#define CGEN_INSN_LSB0_P 1
+
+/* Minimum size of any insn (in bytes).  */
+#define CGEN_MIN_INSN_SIZE 4
+
+/* Maximum size of any insn (in bytes).  */
+#define CGEN_MAX_INSN_SIZE 4
+
+#define CGEN_INT_INSN_P 1
+
+/* Maximum number of syntax elements in an instruction.  */
+#define CGEN_ACTUAL_MAX_SYNTAX_ELEMENTS 13
+
+/* CGEN_MNEMONIC_OPERANDS is defined if mnemonics have operands.
+   e.g. In "b,a foo" the ",a" is an operand.  If mnemonics have operands
+   we can't hash on everything up to the space.  */
+#define CGEN_MNEMONIC_OPERANDS
+
+/* Maximum number of fields in an instruction.  */
+#define CGEN_ACTUAL_MAX_IFMT_OPERANDS 5
+
+/* Enums.  */
+
+/* Enum declaration for Exception numbers.  */
+typedef enum except_number {
+  EXCEPT_ERST = 0, EXCEPT_EINSN = 4, EXCEPT_EIRQ = 8, EXCEPT_ESYSCALL = 12
+ , EXCEPT_EBUS = 16, EXCEPT_EIPF = 20, EXCEPT_EDPF = 24, EXCEPT_EITM = 28
+ , EXCEPT_EDTM = 32, EXCEPT_EALGIN = 36, EXCEPT_EINT = 40
+} EXCEPT_NUMBER;
+
+/* Enum declaration for CPU status management register groups.  */
+typedef enum msr_groups {
+  MSR_BANK_PSB, MSR_BANK_IMB, MSR_BANK_DMB, MSR_BANK_ICB
+ , MSR_BANK_DCB, MSR_BANK_DBGB
+} MSR_GROUPS;
+
+/* Enum declaration for CPU status management register indicies.  */
+typedef enum msr_reg_indices {
+  MSR_INDEX_PSE_PSR
+} MSR_REG_INDICES;
+
+/* Enum declaration for MSR field msb positions.  */
+typedef enum msr_field_msbs {
+  MSR_FIELD_MSB_PSB_PSR_CC = 0, MSR_FIELD_MSB_PSB_PSR_CY = 1, MSR_FIELD_MSB_PSB_PSR_OV = 2, MSR_FIELD_MSB_PSB_PSR_OE = 3
+ , MSR_FIELD_MSB_PSB_PSR_RM = 4, MSR_FIELD_MSB_PSB_PSR_IRE = 5, MSR_FIELD_MSB_PSB_PSR_IMME = 6, MSR_FIELD_MSB_PSB_PSR_DMME = 7
+ , MSR_FIELD_MSB_PSB_PSR_ICAE = 8, MSR_FIELD_MSB_PSB_PSR_DCAE = 9, MSR_FIELD_MSB_PSB_CPUID_VER = 7, MSR_FIELD_MSB_PSB_CPUID_REV = 17
+ , MSR_FIELD_MSB_PSB_CPUID_FIMM = 18, MSR_FIELD_MSB_PSB_CPUID_FDMM = 19, MSR_FIELD_MSB_PSB_CPUID_FICA = 20, MSR_FIELD_MSB_PSB_CPUID_FDCA = 21
+ , MSR_FIELD_MSB_PSB_CPUID_FDBG = 22, MSR_FIELD_MSB_PSB_CPUID_FFPU = 23, MSR_FIELD_MSB_PSB_CPUID_FIRQC = 24, MSR_FIELD_MSB_PSB_CPUID_FTSC = 25
+} MSR_FIELD_MSBS;
+
+/* Enum declaration for MSR field lsb positions.  */
+typedef enum msr_field_lsbs {
+  MSR_FIELD_SIZE_PSB_PSR_CC = 0, MSR_FIELD_SIZE_PSB_PSR_CY = 1, MSR_FIELD_SIZE_PSB_PSR_OV = 2, MSR_FIELD_SIZE_PSB_PSR_OE = 3
+ , MSR_FIELD_SIZE_PSB_PSR_RM = 4, MSR_FIELD_SIZE_PSB_PSR_IRE = 5, MSR_FIELD_SIZE_PSB_PSR_IMME = 6, MSR_FIELD_SIZE_PSB_PSR_DMME = 7
+ , MSR_FIELD_SIZE_PSB_PSR_ICAE = 8, MSR_FIELD_SIZE_PSB_PSR_DCAE = 9, MSR_FIELD_SIZE_PSB_CPUID_VER = 0, MSR_FIELD_SIZE_PSB_CPUID_REV = 8
+ , MSR_FIELD_SIZE_PSB_CPUID_FIMM = 18, MSR_FIELD_SIZE_PSB_CPUID_FDMM = 19, MSR_FIELD_SIZE_PSB_CPUID_FICA = 20, MSR_FIELD_SIZE_PSB_CPUID_FDCA = 21
+ , MSR_FIELD_SIZE_PSB_CPUID_FDBG = 22, MSR_FIELD_SIZE_PSB_CPUID_FFPU = 23, MSR_FIELD_SIZE_PSB_CPUID_FIRQC = 24, MSR_FIELD_SIZE_PSB_CPUID_FTSC = 25
+} MSR_FIELD_LSBS;
+
+/* Enum declaration for MSR field masks.  */
+typedef enum msr_field_masks {
+  MSR_FIELD_MASK_PSB_PSR_CC = 1, MSR_FIELD_MASK_PSB_PSR_CY = 2, MSR_FIELD_MASK_PSB_PSR_OV = 4, MSR_FIELD_MASK_PSB_PSR_OE = 8
+ , MSR_FIELD_MASK_PSB_PSR_RM = 16, MSR_FIELD_MASK_PSB_PSR_IRE = 32, MSR_FIELD_MASK_PSB_PSR_IMME = 64, MSR_FIELD_MASK_PSB_PSR_DMME = 128
+ , MSR_FIELD_MASK_PSB_PSR_ICAE = 256, MSR_FIELD_MASK_PSB_PSR_DCAE = 512, MSR_FIELD_MASK_PSB_CPUID_VER = 255, MSR_FIELD_MASK_PSB_CPUID_REV = 261888
+ , MSR_FIELD_MASK_PSB_CPUID_FIMM = 262144, MSR_FIELD_MASK_PSB_CPUID_FDMM = 524288, MSR_FIELD_MASK_PSB_CPUID_FICA = 1048576, MSR_FIELD_MASK_PSB_CPUID_FDCA = 2097152
+ , MSR_FIELD_MASK_PSB_CPUID_FDBG = 4194304, MSR_FIELD_MASK_PSB_CPUID_FFPU = 8388608, MSR_FIELD_MASK_PSB_CPUID_FIRQC = 16777216, MSR_FIELD_MASK_PSB_CPUID_FTSC = 33554432
+} MSR_FIELD_MASKS;
+
+/* Enum declaration for <opcode> insn opcodes.  */
+typedef enum insn_opcode {
+  OPC_AND = 0, OPC_AND_I = 1, OPC_OR = 2, OPC_OR_I = 3
+ , OPC_XOR = 4, OPC_XOR_I = 5, OPC_LSL = 6, OPC_LSL_I = 7
+ , OPC_LSR = 8, OPC_LSR_I = 9, OPC_JMP = 10, OPC_JMP_I = 11
+ , OPC_CMP = 12, OPC_BT = 13, OPC_BF = 14, OPC_LDWU = 15
+ , OPC_STW = 16, OPC_MBARR = 17, OPC_SYSCALL = 18, OPC_RET = 19
+ , OPC_WMSR = 20, OPC_RMSR = 21, OPC_VENTER = 22, OPC_VLEAVE = 23
+ , OPC_JMP_I_LNK = 24, OPC_ASR = 26, OPC_ASR_I = 27, OPC_ADD = 28
+ , OPC_ADD_I = 29, OPC_SUB = 30, OPC_MUL = 31, OPC_DIV = 32
+ , OPC_DIVU = 33, OPC_MOD = 34, OPC_MODU = 35, OPC_LDB = 36
+ , OPC_LDBU = 37, OPC_LDH = 38, OPC_LDHU = 39, OPC_STB = 40
+ , OPC_STH = 41, OPC_MHI = 42, OPC_FADDS = 43, OPC_FSUBS = 44
+ , OPC_FMULS = 45, OPC_FDIVS = 46, OPC_FCMPS = 47, OPC_FITFS = 48
+ , OPC_FFTIS = 49, OPC_LDWA = 50, OPC_STWA = 51
+} INSN_OPCODE;
+
+/* Attributes.  */
+
+/* Enum declaration for machine type selection.  */
+typedef enum mach_attr {
+  MACH_BASE, MACH_NCPU32K_MACH, MACH_MAX
+} MACH_ATTR;
+
+/* Enum declaration for instruction set selection.  */
+typedef enum isa_attr {
+  ISA_NCPU32K_ISA, ISA_MAX
+} ISA_ATTR;
+
+/* Number of architecture variants.  */
+#define MAX_ISAS  1
+#define MAX_MACHS ((int) MACH_MAX)
+
+/* Ifield support.  */
+
+/* Ifield attribute indices.  */
+
+/* Enum declaration for cgen_ifld attrs.  */
+typedef enum cgen_ifld_attr {
+  CGEN_IFLD_VIRTUAL, CGEN_IFLD_PCREL_ADDR, CGEN_IFLD_ABS_ADDR, CGEN_IFLD_RESERVED
+ , CGEN_IFLD_SIGN_OPT, CGEN_IFLD_SIGNED, CGEN_IFLD_END_BOOLS, CGEN_IFLD_START_NBOOLS = 31
+ , CGEN_IFLD_MACH, CGEN_IFLD_END_NBOOLS
+} CGEN_IFLD_ATTR;
+
+/* Number of non-boolean elements in cgen_ifld_attr.  */
+#define CGEN_IFLD_NBOOL_ATTRS (CGEN_IFLD_END_NBOOLS - CGEN_IFLD_START_NBOOLS - 1)
+
+/* cgen_ifld attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_IFLD_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_IFLD_MACH-CGEN_IFLD_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_IFLD_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_PCREL_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_PCREL_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_ABS_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_ABS_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_RESERVED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_RESERVED)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_SIGN_OPT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_SIGN_OPT)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_SIGNED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_SIGNED)) != 0)
+
+/* Enum declaration for ncpu32k ifield types.  */
+typedef enum ifield_type {
+  NCPU32K_F_NIL, NCPU32K_F_ANYOF, NCPU32K_F_OPCODE, NCPU32K_F_RD
+ , NCPU32K_F_RES_RD, NCPU32K_F_RS1, NCPU32K_F_RES_RS1, NCPU32K_F_RS2
+ , NCPU32K_F_RES_RS2, NCPU32K_F_RES_ATTR, NCPU32K_F_UIMM14, NCPU32K_F_SIMM14
+ , NCPU32K_F_RES_IMM14, NCPU32K_F_UIMM18, NCPU32K_F_RES_IMM2, NCPU32K_F_REL26
+ , NCPU32K_F_MAX
+} IFIELD_TYPE;
+
+#define MAX_IFLD ((int) NCPU32K_F_MAX)
+
+/* Hardware attribute indices.  */
+
+/* Enum declaration for cgen_hw attrs.  */
+typedef enum cgen_hw_attr {
+  CGEN_HW_VIRTUAL, CGEN_HW_CACHE_ADDR, CGEN_HW_PC, CGEN_HW_PROFILE
+ , CGEN_HW_END_BOOLS, CGEN_HW_START_NBOOLS = 31, CGEN_HW_MACH, CGEN_HW_END_NBOOLS
+} CGEN_HW_ATTR;
+
+/* Number of non-boolean elements in cgen_hw_attr.  */
+#define CGEN_HW_NBOOL_ATTRS (CGEN_HW_END_NBOOLS - CGEN_HW_START_NBOOLS - 1)
+
+/* cgen_hw attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_HW_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_HW_MACH-CGEN_HW_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_HW_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_HW_CACHE_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_CACHE_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_HW_PC_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_PC)) != 0)
+#define CGEN_ATTR_CGEN_HW_PROFILE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_PROFILE)) != 0)
+
+/* Enum declaration for ncpu32k hardware types.  */
+typedef enum cgen_hw_type {
+  HW_H_MEMORY, HW_H_SINT, HW_H_UINT, HW_H_ADDR
+ , HW_H_IADDR, HW_H_FRS, HW_H_FRD, HW_H_MSR
+ , HW_H_GPR, HW_H_PC, HW_H_PSE_PSR, HW_H_PSB_PSR_CC
+ , HW_H_PSB_PSR_CY, HW_H_PSB_PSR_OV, HW_H_PSB_PSR_OE, HW_H_PSB_PSR_RM
+ , HW_H_PSB_PSR_IRE, HW_H_PSB_PSR_IMME, HW_H_PSB_PSR_DMME, HW_H_PSB_PSR_ICAE
+ , HW_H_PSB_PSR_DCAE, HW_H_PSB_CPUID_VER, HW_H_PSB_CPUID_REV, HW_H_PSB_CPUID_FIMM
+ , HW_H_PSB_CPUID_FDMM, HW_H_PSB_CPUID_FICA, HW_H_PSB_CPUID_FDCA, HW_H_PSB_CPUID_FDBG
+ , HW_H_PSB_CPUID_FFPU, HW_H_PSB_CPUID_FIRQC, HW_H_PSB_CPUID_FTSC, HW_H_SIMM14
+ , HW_H_UIMM14, HW_H_UIMM18, HW_H_ATOMIC_FLAG, HW_H_ATOMIC_ADDR
+ , HW_MAX
+} CGEN_HW_TYPE;
+
+#define MAX_HW ((int) HW_MAX)
+
+/* Operand attribute indices.  */
+
+/* Enum declaration for cgen_operand attrs.  */
+typedef enum cgen_operand_attr {
+  CGEN_OPERAND_VIRTUAL, CGEN_OPERAND_PCREL_ADDR, CGEN_OPERAND_ABS_ADDR, CGEN_OPERAND_SIGN_OPT
+ , CGEN_OPERAND_SIGNED, CGEN_OPERAND_NEGATIVE, CGEN_OPERAND_RELAX, CGEN_OPERAND_SEM_ONLY
+ , CGEN_OPERAND_END_BOOLS, CGEN_OPERAND_START_NBOOLS = 31, CGEN_OPERAND_MACH, CGEN_OPERAND_END_NBOOLS
+} CGEN_OPERAND_ATTR;
+
+/* Number of non-boolean elements in cgen_operand_attr.  */
+#define CGEN_OPERAND_NBOOL_ATTRS (CGEN_OPERAND_END_NBOOLS - CGEN_OPERAND_START_NBOOLS - 1)
+
+/* cgen_operand attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_OPERAND_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_OPERAND_MACH-CGEN_OPERAND_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_OPERAND_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_PCREL_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_PCREL_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_ABS_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_ABS_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SIGN_OPT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SIGN_OPT)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SIGNED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SIGNED)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_NEGATIVE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_NEGATIVE)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_RELAX_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_RELAX)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SEM_ONLY_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SEM_ONLY)) != 0)
+
+/* Enum declaration for ncpu32k operand types.  */
+typedef enum cgen_operand_type {
+  NCPU32K_OPERAND_PC, NCPU32K_OPERAND_RS1, NCPU32K_OPERAND_RS2, NCPU32K_OPERAND_RD
+ , NCPU32K_OPERAND_SIMM14, NCPU32K_OPERAND_UIMM14, NCPU32K_OPERAND_UIMM18, NCPU32K_OPERAND_REL26
+ , NCPU32K_OPERAND_MSR_PSR_CC, NCPU32K_OPERAND_MSR_PSR_CY, NCPU32K_OPERAND_MSR_PSR_OV, NCPU32K_OPERAND_MSR_PSR_OE
+ , NCPU32K_OPERAND_ATOMIC_FLAG, NCPU32K_OPERAND_ATOMIC_ADDR, NCPU32K_OPERAND_MAX
+} CGEN_OPERAND_TYPE;
+
+/* Number of operands types.  */
+#define MAX_OPERANDS 14
+
+/* Maximum number of operands referenced by any insn.  */
+#define MAX_OPERAND_INSTANCES 9
+
+/* Insn attribute indices.  */
+
+/* Enum declaration for cgen_insn attrs.  */
+typedef enum cgen_insn_attr {
+  CGEN_INSN_ALIAS, CGEN_INSN_VIRTUAL, CGEN_INSN_UNCOND_CTI, CGEN_INSN_COND_CTI
+ , CGEN_INSN_SKIP_CTI, CGEN_INSN_DELAY_SLOT, CGEN_INSN_RELAXABLE, CGEN_INSN_RELAXED
+ , CGEN_INSN_NO_DIS, CGEN_INSN_PBB, CGEN_INSN_FORCED_CTI, CGEN_INSN_END_BOOLS
+ , CGEN_INSN_START_NBOOLS = 31, CGEN_INSN_MACH, CGEN_INSN_END_NBOOLS
+} CGEN_INSN_ATTR;
+
+/* Number of non-boolean elements in cgen_insn_attr.  */
+#define CGEN_INSN_NBOOL_ATTRS (CGEN_INSN_END_NBOOLS - CGEN_INSN_START_NBOOLS - 1)
+
+/* cgen_insn attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_INSN_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_INSN_MACH-CGEN_INSN_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_INSN_ALIAS_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_ALIAS)) != 0)
+#define CGEN_ATTR_CGEN_INSN_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_INSN_UNCOND_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_UNCOND_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_COND_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_COND_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_SKIP_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_SKIP_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_DELAY_SLOT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_DELAY_SLOT)) != 0)
+#define CGEN_ATTR_CGEN_INSN_RELAXABLE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_RELAXABLE)) != 0)
+#define CGEN_ATTR_CGEN_INSN_RELAXED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_RELAXED)) != 0)
+#define CGEN_ATTR_CGEN_INSN_NO_DIS_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_NO_DIS)) != 0)
+#define CGEN_ATTR_CGEN_INSN_PBB_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_PBB)) != 0)
+#define CGEN_ATTR_CGEN_INSN_FORCED_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_FORCED_CTI)) != 0)
+
+/* cgen.h uses things we just defined.  */
+#include "opcode/cgen.h"
+
+extern const struct cgen_ifld ncpu32k_cgen_ifld_table[];
+
+/* Attributes.  */
+extern const CGEN_ATTR_TABLE ncpu32k_cgen_hardware_attr_table[];
+extern const CGEN_ATTR_TABLE ncpu32k_cgen_ifield_attr_table[];
+extern const CGEN_ATTR_TABLE ncpu32k_cgen_operand_attr_table[];
+extern const CGEN_ATTR_TABLE ncpu32k_cgen_insn_attr_table[];
+
+/* Hardware decls.  */
+
+extern CGEN_KEYWORD ncpu32k_cgen_opval_h_frs;
+extern CGEN_KEYWORD ncpu32k_cgen_opval_h_frd;
+extern CGEN_KEYWORD ncpu32k_cgen_opval_h_gpr;
+
+extern const CGEN_HW_ENTRY ncpu32k_cgen_hw_table[];
+
+
+
+   #ifdef __cplusplus
+   }
+   #endif
+
+#endif /* NCPU32K_CPU_H */
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-dis.c binutils-ncpu32k-2.32/opcodes/ncpu32k-dis.c
--- binutils-2.32/opcodes/ncpu32k-dis.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-dis.c	2020-01-30 15:59:04.887706395 +0800
@@ -0,0 +1,538 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Disassembler interface for targets using CGEN. -*- C -*-
+   CGEN: Cpu tools GENerator
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN.
+   - the resultant file is machine generated, cgen-dis.in isn't
+
+   Copyright (C) 1996-2019 Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "disassemble.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "libiberty.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+#include "opintl.h"
+
+/* Default text to print if an instruction isn't recognized.  */
+#define UNKNOWN_INSN_MSG _("*unknown*")
+
+static void print_normal
+  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+static void print_address
+  (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
+static void print_keyword
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+static void print_insn_normal
+  (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
+static int print_insn
+  (CGEN_CPU_DESC, bfd_vma,  disassemble_info *, bfd_byte *, unsigned);
+static int default_print_insn
+  (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
+static int read_insn
+  (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
+   unsigned long *);
+
+/* -- disassembler routines inserted here.  */
+
+
+void ncpu32k_cgen_print_operand
+  (CGEN_CPU_DESC, int, PTR, CGEN_FIELDS *, void const *, bfd_vma, int);
+
+/* Main entry point for printing operands.
+   XINFO is a `void *' and not a `disassemble_info *' to not put a requirement
+   of dis-asm.h on cgen.h.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `print_insn_normal', but keeping it
+   separate makes clear the interface between `print_insn_normal' and each of
+   the handlers.  */
+
+void
+ncpu32k_cgen_print_operand (CGEN_CPU_DESC cd,
+			   int opindex,
+			   void * xinfo,
+			   CGEN_FIELDS *fields,
+			   void const *attrs ATTRIBUTE_UNUSED,
+			   bfd_vma pc,
+			   int length)
+{
+  disassemble_info *info = (disassemble_info *) xinfo;
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      print_keyword (cd, info, & ncpu32k_cgen_opval_h_gpr, fields->f_rd, 0);
+      break;
+    case NCPU32K_OPERAND_REL26 :
+      print_address (cd, info, fields->f_rel26, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
+      break;
+    case NCPU32K_OPERAND_RS1 :
+      print_keyword (cd, info, & ncpu32k_cgen_opval_h_gpr, fields->f_rs1, 0);
+      break;
+    case NCPU32K_OPERAND_RS2 :
+      print_keyword (cd, info, & ncpu32k_cgen_opval_h_gpr, fields->f_rs2, 0);
+      break;
+    case NCPU32K_OPERAND_SIMM14 :
+      print_normal (cd, info, fields->f_simm14, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_SIGN_OPT), pc, length);
+      break;
+    case NCPU32K_OPERAND_UIMM14 :
+      print_normal (cd, info, fields->f_uimm14, 0, pc, length);
+      break;
+    case NCPU32K_OPERAND_UIMM18 :
+      print_normal (cd, info, fields->f_uimm18, 0, pc, length);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while printing insn.\n"),
+	       opindex);
+    abort ();
+  }
+}
+
+cgen_print_fn * const ncpu32k_cgen_print_handlers[] =
+{
+  print_insn_normal,
+};
+
+
+void
+ncpu32k_cgen_init_dis (CGEN_CPU_DESC cd)
+{
+  ncpu32k_cgen_init_opcode_table (cd);
+  ncpu32k_cgen_init_ibld_table (cd);
+  cd->print_handlers = & ncpu32k_cgen_print_handlers[0];
+  cd->print_operand = ncpu32k_cgen_print_operand;
+}
+
+
+/* Default print handler.  */
+
+static void
+print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	      void *dis_info,
+	      long value,
+	      unsigned int attrs,
+	      bfd_vma pc ATTRIBUTE_UNUSED,
+	      int length ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+
+  /* Print the operand as directed by the attributes.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
+    ; /* nothing to do */
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
+    (*info->fprintf_func) (info->stream, "%ld", value);
+  else
+    (*info->fprintf_func) (info->stream, "0x%lx", value);
+}
+
+/* Default address handler.  */
+
+static void
+print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	       void *dis_info,
+	       bfd_vma value,
+	       unsigned int attrs,
+	       bfd_vma pc ATTRIBUTE_UNUSED,
+	       int length ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+
+  /* Print the operand as directed by the attributes.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
+    ; /* Nothing to do.  */
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_PCREL_ADDR))
+    (*info->print_address_func) (value, info);
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
+    (*info->print_address_func) (value, info);
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
+    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+  else
+    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+}
+
+/* Keyword print handler.  */
+
+static void
+print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	       void *dis_info,
+	       CGEN_KEYWORD *keyword_table,
+	       long value,
+	       unsigned int attrs ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+  const CGEN_KEYWORD_ENTRY *ke;
+
+  ke = cgen_keyword_lookup_value (keyword_table, value);
+  if (ke != NULL)
+    (*info->fprintf_func) (info->stream, "%s", ke->name);
+  else
+    (*info->fprintf_func) (info->stream, "???");
+}
+
+/* Default insn printer.
+
+   DIS_INFO is defined as `void *' so the disassembler needn't know anything
+   about disassemble_info.  */
+
+static void
+print_insn_normal (CGEN_CPU_DESC cd,
+		   void *dis_info,
+		   const CGEN_INSN *insn,
+		   CGEN_FIELDS *fields,
+		   bfd_vma pc,
+		   int length)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  disassemble_info *info = (disassemble_info *) dis_info;
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+
+  CGEN_INIT_PRINT (cd);
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
+    {
+      if (CGEN_SYNTAX_MNEMONIC_P (*syn))
+	{
+	  (*info->fprintf_func) (info->stream, "%s", CGEN_INSN_MNEMONIC (insn));
+	  continue;
+	}
+      if (CGEN_SYNTAX_CHAR_P (*syn))
+	{
+	  (*info->fprintf_func) (info->stream, "%c", CGEN_SYNTAX_CHAR (*syn));
+	  continue;
+	}
+
+      /* We have an operand.  */
+      ncpu32k_cgen_print_operand (cd, CGEN_SYNTAX_FIELD (*syn), info,
+				 fields, CGEN_INSN_ATTRS (insn), pc, length);
+    }
+}
+
+/* Subroutine of print_insn. Reads an insn into the given buffers and updates
+   the extract info.
+   Returns 0 if all is well, non-zero otherwise.  */
+
+static int
+read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	   bfd_vma pc,
+	   disassemble_info *info,
+	   bfd_byte *buf,
+	   int buflen,
+	   CGEN_EXTRACT_INFO *ex_info,
+	   unsigned long *insn_value)
+{
+  int status = (*info->read_memory_func) (pc, buf, buflen, info);
+
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, pc, info);
+      return -1;
+    }
+
+  ex_info->dis_info = info;
+  ex_info->valid = (1 << buflen) - 1;
+  ex_info->insn_bytes = buf;
+
+  *insn_value = bfd_get_bits (buf, buflen * 8, info->endian == BFD_ENDIAN_BIG);
+  return 0;
+}
+
+/* Utility to print an insn.
+   BUF is the base part of the insn, target byte order, BUFLEN bytes long.
+   The result is the size of the insn in bytes or zero for an unknown insn
+   or -1 if an error occurs fetching data (memory_error_func will have
+   been called).  */
+
+static int
+print_insn (CGEN_CPU_DESC cd,
+	    bfd_vma pc,
+	    disassemble_info *info,
+	    bfd_byte *buf,
+	    unsigned int buflen)
+{
+  CGEN_INSN_INT insn_value;
+  const CGEN_INSN_LIST *insn_list;
+  CGEN_EXTRACT_INFO ex_info;
+  int basesize;
+
+  /* Extract base part of instruction, just in case CGEN_DIS_* uses it. */
+  basesize = cd->base_insn_bitsize < buflen * 8 ?
+                                     cd->base_insn_bitsize : buflen * 8;
+  insn_value = cgen_get_insn_value (cd, buf, basesize);
+
+
+  /* Fill in ex_info fields like read_insn would.  Don't actually call
+     read_insn, since the incoming buffer is already read (and possibly
+     modified a la m32r).  */
+  ex_info.valid = (1 << buflen) - 1;
+  ex_info.dis_info = info;
+  ex_info.insn_bytes = buf;
+
+  /* The instructions are stored in hash lists.
+     Pick the first one and keep trying until we find the right one.  */
+
+  insn_list = CGEN_DIS_LOOKUP_INSN (cd, (char *) buf, insn_value);
+  while (insn_list != NULL)
+    {
+      const CGEN_INSN *insn = insn_list->insn;
+      CGEN_FIELDS fields;
+      int length;
+      unsigned long insn_value_cropped;
+
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
+      /* Not needed as insn shouldn't be in hash lists if not supported.  */
+      /* Supported by this cpu?  */
+      if (! ncpu32k_cgen_insn_supported (cd, insn))
+        {
+          insn_list = CGEN_DIS_NEXT_INSN (insn_list);
+	  continue;
+        }
+#endif
+
+      /* Basic bit mask must be correct.  */
+      /* ??? May wish to allow target to defer this check until the extract
+	 handler.  */
+
+      /* Base size may exceed this instruction's size.  Extract the
+         relevant part from the buffer. */
+      if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
+					   info->endian == BFD_ENDIAN_BIG);
+      else
+	insn_value_cropped = insn_value;
+
+      if ((insn_value_cropped & CGEN_INSN_BASE_MASK (insn))
+	  == CGEN_INSN_BASE_VALUE (insn))
+	{
+	  /* Printing is handled in two passes.  The first pass parses the
+	     machine insn and extracts the fields.  The second pass prints
+	     them.  */
+
+	  /* Make sure the entire insn is loaded into insn_value, if it
+	     can fit.  */
+	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	    {
+	      unsigned long full_insn_value;
+	      int rc = read_insn (cd, pc, info, buf,
+				  CGEN_INSN_BITSIZE (insn) / 8,
+				  & ex_info, & full_insn_value);
+	      if (rc != 0)
+		return rc;
+	      length = CGEN_EXTRACT_FN (cd, insn)
+		(cd, insn, &ex_info, full_insn_value, &fields, pc);
+	    }
+	  else
+	    length = CGEN_EXTRACT_FN (cd, insn)
+	      (cd, insn, &ex_info, insn_value_cropped, &fields, pc);
+
+	  /* Length < 0 -> error.  */
+	  if (length < 0)
+	    return length;
+	  if (length > 0)
+	    {
+	      CGEN_PRINT_FN (cd, insn) (cd, info, insn, &fields, pc, length);
+	      /* Length is in bits, result is in bytes.  */
+	      return length / 8;
+	    }
+	}
+
+      insn_list = CGEN_DIS_NEXT_INSN (insn_list);
+    }
+
+  return 0;
+}
+
+/* Default value for CGEN_PRINT_INSN.
+   The result is the size of the insn in bytes or zero for an unknown insn
+   or -1 if an error occured fetching bytes.  */
+
+#ifndef CGEN_PRINT_INSN
+#define CGEN_PRINT_INSN default_print_insn
+#endif
+
+static int
+default_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
+{
+  bfd_byte buf[CGEN_MAX_INSN_SIZE];
+  int buflen;
+  int status;
+
+  /* Attempt to read the base part of the insn.  */
+  buflen = cd->base_insn_bitsize / 8;
+  status = (*info->read_memory_func) (pc, buf, buflen, info);
+
+  /* Try again with the minimum part, if min < base.  */
+  if (status != 0 && (cd->min_insn_bitsize < cd->base_insn_bitsize))
+    {
+      buflen = cd->min_insn_bitsize / 8;
+      status = (*info->read_memory_func) (pc, buf, buflen, info);
+    }
+
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, pc, info);
+      return -1;
+    }
+
+  return print_insn (cd, pc, info, buf, buflen);
+}
+
+/* Main entry point.
+   Print one instruction from PC on INFO->STREAM.
+   Return the size of the instruction (in bytes).  */
+
+typedef struct cpu_desc_list
+{
+  struct cpu_desc_list *next;
+  CGEN_BITSET *isa;
+  int mach;
+  int endian;
+  CGEN_CPU_DESC cd;
+} cpu_desc_list;
+
+int
+print_insn_ncpu32k (bfd_vma pc, disassemble_info *info)
+{
+  static cpu_desc_list *cd_list = 0;
+  cpu_desc_list *cl = 0;
+  static CGEN_CPU_DESC cd = 0;
+  static CGEN_BITSET *prev_isa;
+  static int prev_mach;
+  static int prev_endian;
+  int length;
+  CGEN_BITSET *isa;
+  int mach;
+  int endian = (info->endian == BFD_ENDIAN_BIG
+		? CGEN_ENDIAN_BIG
+		: CGEN_ENDIAN_LITTLE);
+  enum bfd_architecture arch;
+
+  /* ??? gdb will set mach but leave the architecture as "unknown" */
+#ifndef CGEN_BFD_ARCH
+#define CGEN_BFD_ARCH bfd_arch_ncpu32k
+#endif
+  arch = info->arch;
+  if (arch == bfd_arch_unknown)
+    arch = CGEN_BFD_ARCH;
+
+  /* There's no standard way to compute the machine or isa number
+     so we leave it to the target.  */
+#ifdef CGEN_COMPUTE_MACH
+  mach = CGEN_COMPUTE_MACH (info);
+#else
+  mach = info->mach;
+#endif
+
+#ifdef CGEN_COMPUTE_ISA
+  {
+    static CGEN_BITSET *permanent_isa;
+
+    if (!permanent_isa)
+      permanent_isa = cgen_bitset_create (MAX_ISAS);
+    isa = permanent_isa;
+    cgen_bitset_clear (isa);
+    cgen_bitset_add (isa, CGEN_COMPUTE_ISA (info));
+  }
+#else
+  isa = info->insn_sets;
+#endif
+
+  /* If we've switched cpu's, try to find a handle we've used before */
+  if (cd
+      && (cgen_bitset_compare (isa, prev_isa) != 0
+	  || mach != prev_mach
+	  || endian != prev_endian))
+    {
+      cd = 0;
+      for (cl = cd_list; cl; cl = cl->next)
+	{
+	  if (cgen_bitset_compare (cl->isa, isa) == 0 &&
+	      cl->mach == mach &&
+	      cl->endian == endian)
+	    {
+	      cd = cl->cd;
+ 	      prev_isa = cd->isas;
+	      break;
+	    }
+	}
+    }
+
+  /* If we haven't initialized yet, initialize the opcode table.  */
+  if (! cd)
+    {
+      const bfd_arch_info_type *arch_type = bfd_lookup_arch (arch, mach);
+      const char *mach_name;
+
+      if (!arch_type)
+	abort ();
+      mach_name = arch_type->printable_name;
+
+      prev_isa = cgen_bitset_copy (isa);
+      prev_mach = mach;
+      prev_endian = endian;
+      cd = ncpu32k_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,
+				 CGEN_CPU_OPEN_BFDMACH, mach_name,
+				 CGEN_CPU_OPEN_ENDIAN, prev_endian,
+				 CGEN_CPU_OPEN_END);
+      if (!cd)
+	abort ();
+
+      /* Save this away for future reference.  */
+      cl = xmalloc (sizeof (struct cpu_desc_list));
+      cl->cd = cd;
+      cl->isa = prev_isa;
+      cl->mach = mach;
+      cl->endian = endian;
+      cl->next = cd_list;
+      cd_list = cl;
+
+      ncpu32k_cgen_init_dis (cd);
+    }
+
+  /* We try to have as much common code as possible.
+     But at this point some targets need to take over.  */
+  /* ??? Some targets may need a hook elsewhere.  Try to avoid this,
+     but if not possible try to move this hook elsewhere rather than
+     have two hooks.  */
+  length = CGEN_PRINT_INSN (cd, pc, info);
+  if (length > 0)
+    return length;
+  if (length < 0)
+    return -1;
+
+  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
+  return cd->default_insn_bitsize / 8;
+}
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-ibld.c binutils-ncpu32k-2.32/opcodes/ncpu32k-ibld.c
--- binutils-2.32/opcodes/ncpu32k-ibld.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-ibld.c	2020-01-30 15:59:04.867706396 +0800
@@ -0,0 +1,880 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Instruction building/extraction support for ncpu32k. -*- C -*-
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN: Cpu tools GENerator.
+   - the resultant file is machine generated, cgen-ibld.in isn't
+
+   Copyright (C) 1996-2019 Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "dis-asm.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+#include "cgen/basic-modes.h"
+#include "opintl.h"
+#include "safe-ctype.h"
+
+#undef  min
+#define min(a,b) ((a) < (b) ? (a) : (b))
+#undef  max
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+/* Used by the ifield rtx function.  */
+#define FLD(f) (fields->f)
+
+static const char * insert_normal
+  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+   unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
+static const char * insert_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *,
+   CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);
+static int extract_normal
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
+   unsigned int, unsigned int, unsigned int, unsigned int,
+   unsigned int, unsigned int, bfd_vma, long *);
+static int extract_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
+   CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
+#if CGEN_INT_INSN_P
+static void put_insn_int_value
+  (CGEN_CPU_DESC, CGEN_INSN_BYTES_PTR, int, int, CGEN_INSN_INT);
+#endif
+#if ! CGEN_INT_INSN_P
+static CGEN_INLINE void insert_1
+  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+static CGEN_INLINE int fill_cache
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
+static CGEN_INLINE long extract_1
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
+#endif
+
+/* Operand insertion.  */
+
+#if ! CGEN_INT_INSN_P
+
+/* Subroutine of insert_normal.  */
+
+static CGEN_INLINE void
+insert_1 (CGEN_CPU_DESC cd,
+	  unsigned long value,
+	  int start,
+	  int length,
+	  int word_length,
+	  unsigned char *bufp)
+{
+  unsigned long x,mask;
+  int shift;
+
+  x = cgen_get_insn_value (cd, bufp, word_length);
+
+  /* Written this way to avoid undefined behaviour.  */
+  mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  if (CGEN_INSN_LSB0_P)
+    shift = (start + 1) - length;
+  else
+    shift = (word_length - (start + length));
+  x = (x & ~(mask << shift)) | ((value & mask) << shift);
+
+  cgen_put_insn_value (cd, bufp, word_length, (bfd_vma) x);
+}
+
+#endif /* ! CGEN_INT_INSN_P */
+
+/* Default insertion routine.
+
+   ATTRS is a mask of the boolean attributes.
+   WORD_OFFSET is the offset in bits from the start of the insn of the value.
+   WORD_LENGTH is the length of the word in bits in which the value resides.
+   START is the starting bit number in the word, architecture origin.
+   LENGTH is the length of VALUE in bits.
+   TOTAL_LENGTH is the total length of the insn in bits.
+
+   The result is an error message or NULL if success.  */
+
+/* ??? This duplicates functionality with bfd's howto table and
+   bfd_install_relocation.  */
+/* ??? This doesn't handle bfd_vma's.  Create another function when
+   necessary.  */
+
+static const char *
+insert_normal (CGEN_CPU_DESC cd,
+	       long value,
+	       unsigned int attrs,
+	       unsigned int word_offset,
+	       unsigned int start,
+	       unsigned int length,
+	       unsigned int word_length,
+	       unsigned int total_length,
+	       CGEN_INSN_BYTES_PTR buffer)
+{
+  static char errbuf[100];
+  /* Written this way to avoid undefined behaviour.  */
+  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+  /* If LENGTH is zero, this operand doesn't contribute to the value.  */
+  if (length == 0)
+    return NULL;
+
+  if (word_length > 8 * sizeof (CGEN_INSN_INT))
+    abort ();
+
+  /* For architectures with insns smaller than the base-insn-bitsize,
+     word_length may be too big.  */
+  if (cd->min_insn_bitsize < cd->base_insn_bitsize)
+    {
+      if (word_offset == 0
+	  && word_length > total_length)
+	word_length = total_length;
+    }
+
+  /* Ensure VALUE will fit.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
+    {
+      long minval = - (1L << (length - 1));
+      unsigned long maxval = mask;
+
+      if ((value > 0 && (unsigned long) value > maxval)
+	  || value < minval)
+	{
+	  /* xgettext:c-format */
+	  sprintf (errbuf,
+		   _("operand out of range (%ld not between %ld and %lu)"),
+		   value, minval, maxval);
+	  return errbuf;
+	}
+    }
+  else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
+    {
+      unsigned long maxval = mask;
+      unsigned long val = (unsigned long) value;
+
+      /* For hosts with a word size > 32 check to see if value has been sign
+	 extended beyond 32 bits.  If so then ignore these higher sign bits
+	 as the user is attempting to store a 32-bit signed value into an
+	 unsigned 32-bit field which is allowed.  */
+      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+	val &= 0xFFFFFFFF;
+
+      if (val > maxval)
+	{
+	  /* xgettext:c-format */
+	  sprintf (errbuf,
+		   _("operand out of range (0x%lx not between 0 and 0x%lx)"),
+		   val, maxval);
+	  return errbuf;
+	}
+    }
+  else
+    {
+      if (! cgen_signed_overflow_ok_p (cd))
+	{
+	  long minval = - (1L << (length - 1));
+	  long maxval =   (1L << (length - 1)) - 1;
+
+	  if (value < minval || value > maxval)
+	    {
+	      sprintf
+		/* xgettext:c-format */
+		(errbuf, _("operand out of range (%ld not between %ld and %ld)"),
+		 value, minval, maxval);
+	      return errbuf;
+	    }
+	}
+    }
+
+#if CGEN_INT_INSN_P
+
+  {
+    int shift_within_word, shift_to_word, shift;
+
+    /* How to shift the value to BIT0 of the word.  */
+    shift_to_word = total_length - (word_offset + word_length);
+
+    /* How to shift the value to the field within the word.  */
+    if (CGEN_INSN_LSB0_P)
+      shift_within_word = start + 1 - length;
+    else
+      shift_within_word = word_length - start - length;
+
+    /* The total SHIFT, then mask in the value.  */
+    shift = shift_to_word + shift_within_word;
+    *buffer = (*buffer & ~(mask << shift)) | ((value & mask) << shift);
+  }
+
+#else /* ! CGEN_INT_INSN_P */
+
+  {
+    unsigned char *bufp = (unsigned char *) buffer + word_offset / 8;
+
+    insert_1 (cd, value, start, length, word_length, bufp);
+  }
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  return NULL;
+}
+
+/* Default insn builder (insert handler).
+   The instruction is recorded in CGEN_INT_INSN_P byte order (meaning
+   that if CGEN_INSN_BYTES_PTR is an int * and thus, the value is
+   recorded in host byte order, otherwise BUFFER is an array of bytes
+   and the value is recorded in target byte order).
+   The result is an error message or NULL if success.  */
+
+static const char *
+insert_insn_normal (CGEN_CPU_DESC cd,
+		    const CGEN_INSN * insn,
+		    CGEN_FIELDS * fields,
+		    CGEN_INSN_BYTES_PTR buffer,
+		    bfd_vma pc)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  unsigned long value;
+  const CGEN_SYNTAX_CHAR_TYPE * syn;
+
+  CGEN_INIT_INSERT (cd);
+  value = CGEN_INSN_BASE_VALUE (insn);
+
+  /* If we're recording insns as numbers (rather than a string of bytes),
+     target byte order handling is deferred until later.  */
+
+#if CGEN_INT_INSN_P
+
+  put_insn_int_value (cd, buffer, cd->base_insn_bitsize,
+		      CGEN_FIELDS_BITSIZE (fields), value);
+
+#else
+
+  cgen_put_insn_value (cd, buffer, min ((unsigned) cd->base_insn_bitsize,
+					(unsigned) CGEN_FIELDS_BITSIZE (fields)),
+		       value);
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  /* ??? It would be better to scan the format's fields.
+     Still need to be able to insert a value based on the operand though;
+     e.g. storing a branch displacement that got resolved later.
+     Needs more thought first.  */
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); * syn; ++ syn)
+    {
+      const char *errmsg;
+
+      if (CGEN_SYNTAX_CHAR_P (* syn))
+	continue;
+
+      errmsg = (* cd->insert_operand) (cd, CGEN_SYNTAX_FIELD (*syn),
+				       fields, buffer, pc);
+      if (errmsg)
+	return errmsg;
+    }
+
+  return NULL;
+}
+
+#if CGEN_INT_INSN_P
+/* Cover function to store an insn value into an integral insn.  Must go here
+   because it needs <prefix>-desc.h for CGEN_INT_INSN_P.  */
+
+static void
+put_insn_int_value (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+		    CGEN_INSN_BYTES_PTR buf,
+		    int length,
+		    int insn_length,
+		    CGEN_INSN_INT value)
+{
+  /* For architectures with insns smaller than the base-insn-bitsize,
+     length may be too big.  */
+  if (length > insn_length)
+    *buf = value;
+  else
+    {
+      int shift = insn_length - length;
+      /* Written this way to avoid undefined behaviour.  */
+      CGEN_INSN_INT mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+      *buf = (*buf & ~(mask << shift)) | ((value & mask) << shift);
+    }
+}
+#endif
+
+/* Operand extraction.  */
+
+#if ! CGEN_INT_INSN_P
+
+/* Subroutine of extract_normal.
+   Ensure sufficient bytes are cached in EX_INFO.
+   OFFSET is the offset in bytes from the start of the insn of the value.
+   BYTES is the length of the needed value.
+   Returns 1 for success, 0 for failure.  */
+
+static CGEN_INLINE int
+fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	    CGEN_EXTRACT_INFO *ex_info,
+	    int offset,
+	    int bytes,
+	    bfd_vma pc)
+{
+  /* It's doubtful that the middle part has already been fetched so
+     we don't optimize that case.  kiss.  */
+  unsigned int mask;
+  disassemble_info *info = (disassemble_info *) ex_info->dis_info;
+
+  /* First do a quick check.  */
+  mask = (1 << bytes) - 1;
+  if (((ex_info->valid >> offset) & mask) == mask)
+    return 1;
+
+  /* Search for the first byte we need to read.  */
+  for (mask = 1 << offset; bytes > 0; --bytes, ++offset, mask <<= 1)
+    if (! (mask & ex_info->valid))
+      break;
+
+  if (bytes)
+    {
+      int status;
+
+      pc += offset;
+      status = (*info->read_memory_func)
+	(pc, ex_info->insn_bytes + offset, bytes, info);
+
+      if (status != 0)
+	{
+	  (*info->memory_error_func) (status, pc, info);
+	  return 0;
+	}
+
+      ex_info->valid |= ((1 << bytes) - 1) << offset;
+    }
+
+  return 1;
+}
+
+/* Subroutine of extract_normal.  */
+
+static CGEN_INLINE long
+extract_1 (CGEN_CPU_DESC cd,
+	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
+	   int start,
+	   int length,
+	   int word_length,
+	   unsigned char *bufp,
+	   bfd_vma pc ATTRIBUTE_UNUSED)
+{
+  unsigned long x;
+  int shift;
+
+  x = cgen_get_insn_value (cd, bufp, word_length);
+
+  if (CGEN_INSN_LSB0_P)
+    shift = (start + 1) - length;
+  else
+    shift = (word_length - (start + length));
+  return x >> shift;
+}
+
+#endif /* ! CGEN_INT_INSN_P */
+
+/* Default extraction routine.
+
+   INSN_VALUE is the first base_insn_bitsize bits of the insn in host order,
+   or sometimes less for cases like the m32r where the base insn size is 32
+   but some insns are 16 bits.
+   ATTRS is a mask of the boolean attributes.  We only need `SIGNED',
+   but for generality we take a bitmask of all of them.
+   WORD_OFFSET is the offset in bits from the start of the insn of the value.
+   WORD_LENGTH is the length of the word in bits in which the value resides.
+   START is the starting bit number in the word, architecture origin.
+   LENGTH is the length of VALUE in bits.
+   TOTAL_LENGTH is the total length of the insn in bits.
+
+   Returns 1 for success, 0 for failure.  */
+
+/* ??? The return code isn't properly used.  wip.  */
+
+/* ??? This doesn't handle bfd_vma's.  Create another function when
+   necessary.  */
+
+static int
+extract_normal (CGEN_CPU_DESC cd,
+#if ! CGEN_INT_INSN_P
+		CGEN_EXTRACT_INFO *ex_info,
+#else
+		CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
+#endif
+		CGEN_INSN_INT insn_value,
+		unsigned int attrs,
+		unsigned int word_offset,
+		unsigned int start,
+		unsigned int length,
+		unsigned int word_length,
+		unsigned int total_length,
+#if ! CGEN_INT_INSN_P
+		bfd_vma pc,
+#else
+		bfd_vma pc ATTRIBUTE_UNUSED,
+#endif
+		long *valuep)
+{
+  long value, mask;
+
+  /* If LENGTH is zero, this operand doesn't contribute to the value
+     so give it a standard value of zero.  */
+  if (length == 0)
+    {
+      *valuep = 0;
+      return 1;
+    }
+
+  if (word_length > 8 * sizeof (CGEN_INSN_INT))
+    abort ();
+
+  /* For architectures with insns smaller than the insn-base-bitsize,
+     word_length may be too big.  */
+  if (cd->min_insn_bitsize < cd->base_insn_bitsize)
+    {
+      if (word_offset + word_length > total_length)
+	word_length = total_length - word_offset;
+    }
+
+  /* Does the value reside in INSN_VALUE, and at the right alignment?  */
+
+  if (CGEN_INT_INSN_P || (word_offset == 0 && word_length == total_length))
+    {
+      if (CGEN_INSN_LSB0_P)
+	value = insn_value >> ((word_offset + start + 1) - length);
+      else
+	value = insn_value >> (total_length - ( word_offset + start + length));
+    }
+
+#if ! CGEN_INT_INSN_P
+
+  else
+    {
+      unsigned char *bufp = ex_info->insn_bytes + word_offset / 8;
+
+      if (word_length > 8 * sizeof (CGEN_INSN_INT))
+	abort ();
+
+      if (fill_cache (cd, ex_info, word_offset / 8, word_length / 8, pc) == 0)
+	return 0;
+
+      value = extract_1 (cd, ex_info, start, length, word_length, bufp, pc);
+    }
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  /* Written this way to avoid undefined behaviour.  */
+  mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+  value &= mask;
+  /* sign extend? */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED)
+      && (value & (1L << (length - 1))))
+    value |= ~mask;
+
+  *valuep = value;
+
+  return 1;
+}
+
+/* Default insn extractor.
+
+   INSN_VALUE is the first base_insn_bitsize bits, translated to host order.
+   The extracted fields are stored in FIELDS.
+   EX_INFO is used to handle reading variable length insns.
+   Return the length of the insn in bits, or 0 if no match,
+   or -1 if an error occurs fetching data (memory_error_func will have
+   been called).  */
+
+static int
+extract_insn_normal (CGEN_CPU_DESC cd,
+		     const CGEN_INSN *insn,
+		     CGEN_EXTRACT_INFO *ex_info,
+		     CGEN_INSN_INT insn_value,
+		     CGEN_FIELDS *fields,
+		     bfd_vma pc)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+
+  CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);
+
+  CGEN_INIT_EXTRACT (cd);
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
+    {
+      int length;
+
+      if (CGEN_SYNTAX_CHAR_P (*syn))
+	continue;
+
+      length = (* cd->extract_operand) (cd, CGEN_SYNTAX_FIELD (*syn),
+					ex_info, insn_value, fields, pc);
+      if (length <= 0)
+	return length;
+    }
+
+  /* We recognized and successfully extracted this insn.  */
+  return CGEN_INSN_BITSIZE (insn);
+}
+
+/* Machine generated code added here.  */
+
+const char * ncpu32k_cgen_insert_operand
+  (CGEN_CPU_DESC, int, CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);
+
+/* Main entry point for operand insertion.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `parse_insn_normal', but keeping it
+   separate makes clear the interface between `parse_insn_normal' and each of
+   the handlers.  It's also needed by GAS to insert operands that couldn't be
+   resolved during parsing.  */
+
+const char *
+ncpu32k_cgen_insert_operand (CGEN_CPU_DESC cd,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     CGEN_INSN_BYTES_PTR buffer,
+			     bfd_vma pc ATTRIBUTE_UNUSED)
+{
+  const char * errmsg = NULL;
+  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      errmsg = insert_normal (cd, fields->f_rd, 0, 0, 11, 6, 32, total_length, buffer);
+      break;
+    case NCPU32K_OPERAND_REL26 :
+      {
+        long value = fields->f_rel26;
+        value = ((SI) (((value) - (pc))) >> (2));
+        errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 31, 26, 32, total_length, buffer);
+      }
+      break;
+    case NCPU32K_OPERAND_RS1 :
+      errmsg = insert_normal (cd, fields->f_rs1, 0, 0, 17, 6, 32, total_length, buffer);
+      break;
+    case NCPU32K_OPERAND_RS2 :
+      errmsg = insert_normal (cd, fields->f_rs2, 0, 0, 23, 6, 32, total_length, buffer);
+      break;
+    case NCPU32K_OPERAND_SIMM14 :
+      errmsg = insert_normal (cd, fields->f_simm14, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_SIGN_OPT), 0, 31, 14, 32, total_length, buffer);
+      break;
+    case NCPU32K_OPERAND_UIMM14 :
+      errmsg = insert_normal (cd, fields->f_uimm14, 0, 0, 31, 14, 32, total_length, buffer);
+      break;
+    case NCPU32K_OPERAND_UIMM18 :
+      errmsg = insert_normal (cd, fields->f_uimm18, 0, 0, 29, 18, 32, total_length, buffer);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while building insn.\n"),
+	       opindex);
+      abort ();
+  }
+
+  return errmsg;
+}
+
+int ncpu32k_cgen_extract_operand
+  (CGEN_CPU_DESC, int, CGEN_EXTRACT_INFO *, CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
+
+/* Main entry point for operand extraction.
+   The result is <= 0 for error, >0 for success.
+   ??? Actual values aren't well defined right now.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `print_insn_normal', but keeping it
+   separate makes clear the interface between `print_insn_normal' and each of
+   the handlers.  */
+
+int
+ncpu32k_cgen_extract_operand (CGEN_CPU_DESC cd,
+			     int opindex,
+			     CGEN_EXTRACT_INFO *ex_info,
+			     CGEN_INSN_INT insn_value,
+			     CGEN_FIELDS * fields,
+			     bfd_vma pc)
+{
+  /* Assume success (for those operands that are nops).  */
+  int length = 1;
+  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 11, 6, 32, total_length, pc, & fields->f_rd);
+      break;
+    case NCPU32K_OPERAND_REL26 :
+      {
+        long value;
+        length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 31, 26, 32, total_length, pc, & value);
+        value = ((((value) << (2))) + (pc));
+        fields->f_rel26 = value;
+      }
+      break;
+    case NCPU32K_OPERAND_RS1 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 17, 6, 32, total_length, pc, & fields->f_rs1);
+      break;
+    case NCPU32K_OPERAND_RS2 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 23, 6, 32, total_length, pc, & fields->f_rs2);
+      break;
+    case NCPU32K_OPERAND_SIMM14 :
+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_SIGN_OPT), 0, 31, 14, 32, total_length, pc, & fields->f_simm14);
+      break;
+    case NCPU32K_OPERAND_UIMM14 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 31, 14, 32, total_length, pc, & fields->f_uimm14);
+      break;
+    case NCPU32K_OPERAND_UIMM18 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 29, 18, 32, total_length, pc, & fields->f_uimm18);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while decoding insn.\n"),
+	       opindex);
+      abort ();
+    }
+
+  return length;
+}
+
+cgen_insert_fn * const ncpu32k_cgen_insert_handlers[] =
+{
+  insert_insn_normal,
+};
+
+cgen_extract_fn * const ncpu32k_cgen_extract_handlers[] =
+{
+  extract_insn_normal,
+};
+
+int ncpu32k_cgen_get_int_operand     (CGEN_CPU_DESC, int, const CGEN_FIELDS *);
+bfd_vma ncpu32k_cgen_get_vma_operand (CGEN_CPU_DESC, int, const CGEN_FIELDS *);
+
+/* Getting values from cgen_fields is handled by a collection of functions.
+   They are distinguished by the type of the VALUE argument they return.
+   TODO: floating point, inlining support, remove cases where result type
+   not appropriate.  */
+
+int
+ncpu32k_cgen_get_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     const CGEN_FIELDS * fields)
+{
+  int value;
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      value = fields->f_rd;
+      break;
+    case NCPU32K_OPERAND_REL26 :
+      value = fields->f_rel26;
+      break;
+    case NCPU32K_OPERAND_RS1 :
+      value = fields->f_rs1;
+      break;
+    case NCPU32K_OPERAND_RS2 :
+      value = fields->f_rs2;
+      break;
+    case NCPU32K_OPERAND_SIMM14 :
+      value = fields->f_simm14;
+      break;
+    case NCPU32K_OPERAND_UIMM14 :
+      value = fields->f_uimm14;
+      break;
+    case NCPU32K_OPERAND_UIMM18 :
+      value = fields->f_uimm18;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while getting int operand.\n"),
+		       opindex);
+      abort ();
+  }
+
+  return value;
+}
+
+bfd_vma
+ncpu32k_cgen_get_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     const CGEN_FIELDS * fields)
+{
+  bfd_vma value;
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      value = fields->f_rd;
+      break;
+    case NCPU32K_OPERAND_REL26 :
+      value = fields->f_rel26;
+      break;
+    case NCPU32K_OPERAND_RS1 :
+      value = fields->f_rs1;
+      break;
+    case NCPU32K_OPERAND_RS2 :
+      value = fields->f_rs2;
+      break;
+    case NCPU32K_OPERAND_SIMM14 :
+      value = fields->f_simm14;
+      break;
+    case NCPU32K_OPERAND_UIMM14 :
+      value = fields->f_uimm14;
+      break;
+    case NCPU32K_OPERAND_UIMM18 :
+      value = fields->f_uimm18;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while getting vma operand.\n"),
+		       opindex);
+      abort ();
+  }
+
+  return value;
+}
+
+void ncpu32k_cgen_set_int_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, int);
+void ncpu32k_cgen_set_vma_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, bfd_vma);
+
+/* Stuffing values in cgen_fields is handled by a collection of functions.
+   They are distinguished by the type of the VALUE argument they accept.
+   TODO: floating point, inlining support, remove cases where argument type
+   not appropriate.  */
+
+void
+ncpu32k_cgen_set_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     int value)
+{
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      fields->f_rd = value;
+      break;
+    case NCPU32K_OPERAND_REL26 :
+      fields->f_rel26 = value;
+      break;
+    case NCPU32K_OPERAND_RS1 :
+      fields->f_rs1 = value;
+      break;
+    case NCPU32K_OPERAND_RS2 :
+      fields->f_rs2 = value;
+      break;
+    case NCPU32K_OPERAND_SIMM14 :
+      fields->f_simm14 = value;
+      break;
+    case NCPU32K_OPERAND_UIMM14 :
+      fields->f_uimm14 = value;
+      break;
+    case NCPU32K_OPERAND_UIMM18 :
+      fields->f_uimm18 = value;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while setting int operand.\n"),
+		       opindex);
+      abort ();
+  }
+}
+
+void
+ncpu32k_cgen_set_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     bfd_vma value)
+{
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      fields->f_rd = value;
+      break;
+    case NCPU32K_OPERAND_REL26 :
+      fields->f_rel26 = value;
+      break;
+    case NCPU32K_OPERAND_RS1 :
+      fields->f_rs1 = value;
+      break;
+    case NCPU32K_OPERAND_RS2 :
+      fields->f_rs2 = value;
+      break;
+    case NCPU32K_OPERAND_SIMM14 :
+      fields->f_simm14 = value;
+      break;
+    case NCPU32K_OPERAND_UIMM14 :
+      fields->f_uimm14 = value;
+      break;
+    case NCPU32K_OPERAND_UIMM18 :
+      fields->f_uimm18 = value;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while setting vma operand.\n"),
+		       opindex);
+      abort ();
+  }
+}
+
+/* Function to call before using the instruction builder tables.  */
+
+void
+ncpu32k_cgen_init_ibld_table (CGEN_CPU_DESC cd)
+{
+  cd->insert_handlers = & ncpu32k_cgen_insert_handlers[0];
+  cd->extract_handlers = & ncpu32k_cgen_extract_handlers[0];
+
+  cd->insert_operand = ncpu32k_cgen_insert_operand;
+  cd->extract_operand = ncpu32k_cgen_extract_operand;
+
+  cd->get_int_operand = ncpu32k_cgen_get_int_operand;
+  cd->set_int_operand = ncpu32k_cgen_set_int_operand;
+  cd->get_vma_operand = ncpu32k_cgen_get_vma_operand;
+  cd->set_vma_operand = ncpu32k_cgen_set_vma_operand;
+}
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-opc.c binutils-ncpu32k-2.32/opcodes/ncpu32k-opc.c
--- binutils-2.32/opcodes/ncpu32k-opc.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-opc.c	2020-01-30 16:01:41.871697563 +0800
@@ -0,0 +1,542 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Instruction opcode table for ncpu32k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+#include "libiberty.h"
+
+/* -- opc.c */
+/* -- */
+/* The hash functions are recorded here to help keep assembler code out of
+   the disassembler and vice versa.  */
+
+static int asm_hash_insn_p        (const CGEN_INSN *);
+static unsigned int asm_hash_insn (const char *);
+static int dis_hash_insn_p        (const CGEN_INSN *);
+static unsigned int dis_hash_insn (const char *, CGEN_INSN_INT);
+
+/* Instruction formats.  */
+
+#define F(f) & ncpu32k_cgen_ifld_table[NCPU32K_##f]
+static const CGEN_IFMT ifmt_empty ATTRIBUTE_UNUSED = {
+  0, 0, 0x0, { { 0 } }
+};
+
+static const CGEN_IFMT ifmt_nop ATTRIBUTE_UNUSED = {
+  32, 32, 0xffffffff, { { F (F_RES_ATTR) }, { F (F_RES_RS2) }, { F (F_RES_RS1) }, { F (F_RES_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_mov ATTRIBUTE_UNUSED = {
+  32, 32, 0xfffc003f, { { F (F_RES_ATTR) }, { F (F_RES_RS2) }, { F (F_RS1) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_and ATTRIBUTE_UNUSED = {
+  32, 32, 0xff00003f, { { F (F_RES_ATTR) }, { F (F_RS2) }, { F (F_RS1) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_and_i ATTRIBUTE_UNUSED = {
+  32, 32, 0x3f, { { F (F_UIMM14) }, { F (F_RS1) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_xor_i ATTRIBUTE_UNUSED = {
+  32, 32, 0x3f, { { F (F_SIMM14) }, { F (F_RS1) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_mhi ATTRIBUTE_UNUSED = {
+  32, 32, 0xc000003f, { { F (F_RES_IMM2) }, { F (F_UIMM18) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_cmpeq ATTRIBUTE_UNUSED = {
+  32, 32, 0xff000fff, { { F (F_RES_ATTR) }, { F (F_RS2) }, { F (F_RS1) }, { F (F_RES_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_jmp_i ATTRIBUTE_UNUSED = {
+  32, 32, 0x3f, { { F (F_REL26) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_syscall ATTRIBUTE_UNUSED = {
+  32, 32, 0x3ffff, { { F (F_UIMM14) }, { F (F_RES_RS1) }, { F (F_RES_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_ret ATTRIBUTE_UNUSED = {
+  32, 32, 0xffffffff, { { F (F_RES_IMM14) }, { F (F_RES_RS1) }, { F (F_RES_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+#undef F
+
+#define A(a) (1 << CGEN_INSN_##a)
+#define OPERAND(op) NCPU32K_OPERAND_##op
+#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+
+/* The instruction table.  */
+
+static const CGEN_OPCODE ncpu32k_cgen_insn_opcode_table[MAX_INSNS] =
+{
+  /* Special null first entry.
+     A `num' value of zero is thus invalid.
+     Also, the special `invalid' insn resides here.  */
+  { { 0, 0, 0, 0 }, {{0}}, 0, {0}},
+/* nop */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_nop, { 0x0 }
+  },
+/* mov $rd,$rs1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), 0 } },
+    & ifmt_mov, { 0x2 }
+  },
+/* and $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x0 }
+  },
+/* and $rd,$rs1,$uimm14 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (UIMM14), 0 } },
+    & ifmt_and_i, { 0x1 }
+  },
+/* or $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x2 }
+  },
+/* or $rd,$rs1,$uimm14 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (UIMM14), 0 } },
+    & ifmt_and_i, { 0x3 }
+  },
+/* xor $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x4 }
+  },
+/* xor $rd,$rs1,$simm14 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (SIMM14), 0 } },
+    & ifmt_xor_i, { 0x5 }
+  },
+/* lsl $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x6 }
+  },
+/* lsl $rd,$rs1,${uimm14} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (UIMM14), 0 } },
+    & ifmt_and_i, { 0x7 }
+  },
+/* lsr $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x8 }
+  },
+/* lsr $rd,$rs1,${uimm14} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (UIMM14), 0 } },
+    & ifmt_and_i, { 0x9 }
+  },
+/* asr $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x1a }
+  },
+/* asr $rd,$rs1,${uimm14} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (UIMM14), 0 } },
+    & ifmt_and_i, { 0x1b }
+  },
+/* add $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x1c }
+  },
+/* add $rd,$rs1,$simm14 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (SIMM14), 0 } },
+    & ifmt_xor_i, { 0x1d }
+  },
+/* sub $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x1e }
+  },
+/* mul $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x1f }
+  },
+/* div $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x20 }
+  },
+/* divu $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x21 }
+  },
+/* mod $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x22 }
+  },
+/* modu $rd,$rs1,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (RS2), 0 } },
+    & ifmt_and, { 0x23 }
+  },
+/* mhi $rd,${uimm18} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (UIMM18), 0 } },
+    & ifmt_mhi, { 0x2a }
+  },
+/* rmsr $rd,$rs1,${uimm14} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (UIMM14), 0 } },
+    & ifmt_and_i, { 0x15 }
+  },
+/* wmsr $rd,$rs1,${uimm14} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), ',', OP (UIMM14), 0 } },
+    & ifmt_and_i, { 0x14 }
+  },
+/* cmp $rs1,eq,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RS1), ',', 'e', 'q', ',', OP (RS2), 0 } },
+    & ifmt_cmpeq, { 0xc }
+  },
+/* cmp $rs1,gt,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RS1), ',', 'g', 't', ',', OP (RS2), 0 } },
+    & ifmt_cmpeq, { 0x100000c }
+  },
+/* cmp $rs1,gtu,$rs2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RS1), ',', 'g', 't', 'u', ',', OP (RS2), 0 } },
+    & ifmt_cmpeq, { 0x200000c }
+  },
+/* jmp $rd,$rs1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS1), 0 } },
+    & ifmt_mov, { 0xa }
+  },
+/* jmp r0,${rel26} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', 'r', '0', ',', OP (REL26), 0 } },
+    & ifmt_jmp_i, { 0xb }
+  },
+/* jmp lnk,${rel26} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', 'l', 'n', 'k', ',', OP (REL26), 0 } },
+    & ifmt_jmp_i, { 0x18 }
+  },
+/* bt ${rel26} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (REL26), 0 } },
+    & ifmt_jmp_i, { 0xd }
+  },
+/* bf ${rel26} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (REL26), 0 } },
+    & ifmt_jmp_i, { 0xe }
+  },
+/* ldb $rd,${simm14}($rs1) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM14), '(', OP (RS1), ')', 0 } },
+    & ifmt_xor_i, { 0x24 }
+  },
+/* ldbu $rd,${simm14}($rs1) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM14), '(', OP (RS1), ')', 0 } },
+    & ifmt_xor_i, { 0x25 }
+  },
+/* ldh $rd,${simm14}($rs1) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM14), '(', OP (RS1), ')', 0 } },
+    & ifmt_xor_i, { 0x26 }
+  },
+/* ldhu $rd,${simm14}($rs1) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM14), '(', OP (RS1), ')', 0 } },
+    & ifmt_xor_i, { 0x27 }
+  },
+/* ldw $rd,${simm14}($rs1) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM14), '(', OP (RS1), ')', 0 } },
+    & ifmt_xor_i, { 0xf }
+  },
+/* ldwu $rd,${simm14}($rs1) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM14), '(', OP (RS1), ')', 0 } },
+    & ifmt_xor_i, { 0xf }
+  },
+/* stb ${simm14}($rd),$rs1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (SIMM14), '(', OP (RD), ')', ',', OP (RS1), 0 } },
+    & ifmt_xor_i, { 0x28 }
+  },
+/* sth ${simm14}($rd),$rs1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (SIMM14), '(', OP (RD), ')', ',', OP (RS1), 0 } },
+    & ifmt_xor_i, { 0x29 }
+  },
+/* stw ${simm14}($rd),$rs1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (SIMM14), '(', OP (RD), ')', ',', OP (RS1), 0 } },
+    & ifmt_xor_i, { 0x10 }
+  },
+/* syscall ${uimm14} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (UIMM14), 0 } },
+    & ifmt_syscall, { 0x12 }
+  },
+/* ret */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_ret, { 0x13 }
+  },
+/* mbarr */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_ret, { 0x11 }
+  },
+/* ldwa $rd,${simm14}($rs1) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM14), '(', OP (RS1), ')', 0 } },
+    & ifmt_xor_i, { 0x32 }
+  },
+/* stwa ${simm14}($rd),$rs1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (SIMM14), '(', OP (RD), ')', ',', OP (RS1), 0 } },
+    & ifmt_xor_i, { 0x33 }
+  },
+};
+
+#undef A
+#undef OPERAND
+#undef MNEM
+#undef OP
+
+/* Formats for ALIAS macro-insns.  */
+
+#define F(f) & ncpu32k_cgen_ifld_table[NCPU32K_##f]
+#undef F
+
+/* Each non-simple macro entry points to an array of expansion possibilities.  */
+
+#define A(a) (1 << CGEN_INSN_##a)
+#define OPERAND(op) NCPU32K_OPERAND_##op
+#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+
+/* The macro instruction table.  */
+
+static const CGEN_IBASE ncpu32k_cgen_macro_insn_table[] =
+{
+};
+
+/* The macro instruction opcode table.  */
+
+static const CGEN_OPCODE ncpu32k_cgen_macro_insn_opcode_table[] =
+{
+};
+
+#undef A
+#undef OPERAND
+#undef MNEM
+#undef OP
+
+#ifndef CGEN_ASM_HASH_P
+#define CGEN_ASM_HASH_P(insn) 1
+#endif
+
+#ifndef CGEN_DIS_HASH_P
+#define CGEN_DIS_HASH_P(insn) 1
+#endif
+
+/* Return non-zero if INSN is to be added to the hash table.
+   Targets are free to override CGEN_{ASM,DIS}_HASH_P in the .opc file.  */
+
+static int
+asm_hash_insn_p (const CGEN_INSN *insn ATTRIBUTE_UNUSED)
+{
+  return CGEN_ASM_HASH_P (insn);
+}
+
+static int
+dis_hash_insn_p (const CGEN_INSN *insn)
+{
+  /* If building the hash table and the NO-DIS attribute is present,
+     ignore.  */
+  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_NO_DIS))
+    return 0;
+  return CGEN_DIS_HASH_P (insn);
+}
+
+#ifndef CGEN_ASM_HASH
+#define CGEN_ASM_HASH_SIZE 127
+#ifdef CGEN_MNEMONIC_OPERANDS
+#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE)
+#else
+#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE) /*FIXME*/
+#endif
+#endif
+
+/* It doesn't make much sense to provide a default here,
+   but while this is under development we do.
+   BUFFER is a pointer to the bytes of the insn, target order.
+   VALUE is the first base_insn_bitsize bits as an int in host order.  */
+
+#ifndef CGEN_DIS_HASH
+#define CGEN_DIS_HASH_SIZE 256
+#define CGEN_DIS_HASH(buf, value) (*(unsigned char *) (buf))
+#endif
+
+/* The result is the hash value of the insn.
+   Targets are free to override CGEN_{ASM,DIS}_HASH in the .opc file.  */
+
+static unsigned int
+asm_hash_insn (const char *mnem)
+{
+  return CGEN_ASM_HASH (mnem);
+}
+
+/* BUF is a pointer to the bytes of the insn, target order.
+   VALUE is the first base_insn_bitsize bits as an int in host order.  */
+
+static unsigned int
+dis_hash_insn (const char *buf ATTRIBUTE_UNUSED,
+		     CGEN_INSN_INT value ATTRIBUTE_UNUSED)
+{
+  return CGEN_DIS_HASH (buf, value);
+}
+
+/* Set the recorded length of the insn in the CGEN_FIELDS struct.  */
+
+static void
+set_fields_bitsize (CGEN_FIELDS *fields, int size)
+{
+  CGEN_FIELDS_BITSIZE (fields) = size;
+}
+
+/* Function to call before using the operand instance table.
+   This plugs the opcode entries and macro instructions into the cpu table.  */
+
+void
+ncpu32k_cgen_init_opcode_table (CGEN_CPU_DESC cd)
+{
+  int i;
+  int num_macros = (sizeof (ncpu32k_cgen_macro_insn_table) /
+		    sizeof (ncpu32k_cgen_macro_insn_table[0]));
+  const CGEN_IBASE *ib = & ncpu32k_cgen_macro_insn_table[0];
+  const CGEN_OPCODE *oc = & ncpu32k_cgen_macro_insn_opcode_table[0];
+  CGEN_INSN *insns = xmalloc (num_macros * sizeof (CGEN_INSN));
+
+  /* This test has been added to avoid a warning generated
+     if memset is called with a third argument of value zero.  */
+  if (num_macros >= 1)
+    memset (insns, 0, num_macros * sizeof (CGEN_INSN));
+  for (i = 0; i < num_macros; ++i)
+    {
+      insns[i].base = &ib[i];
+      insns[i].opcode = &oc[i];
+      ncpu32k_cgen_build_insn_regex (& insns[i]);
+    }
+  cd->macro_insn_table.init_entries = insns;
+  cd->macro_insn_table.entry_size = sizeof (CGEN_IBASE);
+  cd->macro_insn_table.num_init_entries = num_macros;
+
+  oc = & ncpu32k_cgen_insn_opcode_table[0];
+  insns = (CGEN_INSN *) cd->insn_table.init_entries;
+  for (i = 0; i < MAX_INSNS; ++i)
+    {
+      insns[i].opcode = &oc[i];
+      ncpu32k_cgen_build_insn_regex (& insns[i]);
+    }
+
+  cd->sizeof_fields = sizeof (CGEN_FIELDS);
+  cd->set_fields_bitsize = set_fields_bitsize;
+
+  cd->asm_hash_p = asm_hash_insn_p;
+  cd->asm_hash = asm_hash_insn;
+  cd->asm_hash_size = CGEN_ASM_HASH_SIZE;
+
+  cd->dis_hash_p = dis_hash_insn_p;
+  cd->dis_hash = dis_hash_insn;
+  cd->dis_hash_size = CGEN_DIS_HASH_SIZE;
+}
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-opc.h binutils-ncpu32k-2.32/opcodes/ncpu32k-opc.h
--- binutils-2.32/opcodes/ncpu32k-opc.h	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-opc.h	2020-01-30 15:59:04.835706398 +0800
@@ -0,0 +1,103 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Instruction opcode header for ncpu32k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef NCPU32K_OPC_H
+#define NCPU32K_OPC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* -- opc.h */
+
+#undef  CGEN_DIS_HASH_SIZE
+#define CGEN_DIS_HASH_SIZE 256
+#undef  CGEN_DIS_HASH
+#define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] & 0x3f) /* opcode[5..0] */
+
+/* -- */
+/* Enum declaration for ncpu32k instruction types.  */
+typedef enum cgen_insn_type {
+  NCPU32K_INSN_INVALID, NCPU32K_INSN_NOP, NCPU32K_INSN_MOV, NCPU32K_INSN_AND
+ , NCPU32K_INSN_AND_I, NCPU32K_INSN_OR, NCPU32K_INSN_OR_I, NCPU32K_INSN_XOR
+ , NCPU32K_INSN_XOR_I, NCPU32K_INSN_LSL, NCPU32K_INSN_LSL_I, NCPU32K_INSN_LSR
+ , NCPU32K_INSN_LSR_I, NCPU32K_INSN_ASR, NCPU32K_INSN_ASR_I, NCPU32K_INSN_ADD
+ , NCPU32K_INSN_ADD_I, NCPU32K_INSN_SUB, NCPU32K_INSN_MUL, NCPU32K_INSN_DIV
+ , NCPU32K_INSN_DIVU, NCPU32K_INSN_MOD, NCPU32K_INSN_MODU, NCPU32K_INSN_MHI
+ , NCPU32K_INSN_RMSR, NCPU32K_INSN_WMSR, NCPU32K_INSN_CMPEQ, NCPU32K_INSN_CMPGT
+ , NCPU32K_INSN_CMP, NCPU32K_INSN_JMP, NCPU32K_INSN_JMP_I, NCPU32K_INSN_JMP_I_LNK
+ , NCPU32K_INSN_BT, NCPU32K_INSN_BF, NCPU32K_INSN_LDB, NCPU32K_INSN_LDBU
+ , NCPU32K_INSN_LDH, NCPU32K_INSN_LDHU, NCPU32K_INSN_LDW, NCPU32K_INSN_LDWU
+ , NCPU32K_INSN_STB, NCPU32K_INSN_STH, NCPU32K_INSN_STW, NCPU32K_INSN_SYSCALL
+ , NCPU32K_INSN_RET, NCPU32K_INSN_MBARR, NCPU32K_INSN_LDWA, NCPU32K_INSN_STWA
+} CGEN_INSN_TYPE;
+
+/* Index of `invalid' insn place holder.  */
+#define CGEN_INSN_INVALID NCPU32K_INSN_INVALID
+
+/* Total number of insns in table.  */
+#define MAX_INSNS ((int) NCPU32K_INSN_STWA + 1)
+
+/* This struct records data prior to insertion or after extraction.  */
+struct cgen_fields
+{
+  int length;
+  long f_nil;
+  long f_anyof;
+  long f_opcode;
+  long f_rd;
+  long f_res_rd;
+  long f_rs1;
+  long f_res_rs1;
+  long f_rs2;
+  long f_res_rs2;
+  long f_res_attr;
+  long f_uimm14;
+  long f_simm14;
+  long f_res_imm14;
+  long f_uimm18;
+  long f_res_imm2;
+  long f_rel26;
+};
+
+#define CGEN_INIT_PARSE(od) \
+{\
+}
+#define CGEN_INIT_INSERT(od) \
+{\
+}
+#define CGEN_INIT_EXTRACT(od) \
+{\
+}
+#define CGEN_INIT_PRINT(od) \
+{\
+}
+
+
+   #ifdef __cplusplus
+   }
+   #endif
+
+#endif /* NCPU32K_OPC_H */
diff -Nur -x cgen -x tags -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-opinst.c binutils-ncpu32k-2.32/opcodes/ncpu32k-opinst.c
--- binutils-2.32/opcodes/ncpu32k-opinst.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-opinst.c	2020-01-30 15:59:04.855706397 +0800
@@ -0,0 +1,331 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Semantic operand instances for ncpu32k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+
+/* Operand references.  */
+
+#define OP_ENT(op) NCPU32K_OPERAND_##op
+#define INPUT CGEN_OPINST_INPUT
+#define OUTPUT CGEN_OPINST_OUTPUT
+#define END CGEN_OPINST_END
+#define COND_REF CGEN_OPINST_COND_REF
+
+static const CGEN_OPINST sfmt_empty_ops[] ATTRIBUTE_UNUSED = {
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_nop_ops[] ATTRIBUTE_UNUSED = {
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_mov_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_and_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "rs2", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS2), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_and_i_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "uimm14", HW_H_UIMM14, CGEN_MODE_UINT, OP_ENT (UIMM14), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_xor_i_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_add_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "msr_psr_oe", HW_H_PSB_PSR_OE, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "msr_psr_ov", HW_H_PSB_PSR_OV, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, COND_REF },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "rs2", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS2), 0, 0 },
+  { OUTPUT, "msr_psr_cy", HW_H_PSB_PSR_CY, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "msr_psr_ov", HW_H_PSB_PSR_OV, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_add_i_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "msr_psr_oe", HW_H_PSB_PSR_OE, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "msr_psr_ov", HW_H_PSB_PSR_OV, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, COND_REF },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "msr_psr_cy", HW_H_PSB_PSR_CY, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "msr_psr_ov", HW_H_PSB_PSR_OV, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_div_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "msr_psr_cy", HW_H_PSB_PSR_CY, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "msr_psr_oe", HW_H_PSB_PSR_OE, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, COND_REF },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, COND_REF },
+  { INPUT, "rs2", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS2), 0, 0 },
+  { OUTPUT, "msr_psr_cy", HW_H_PSB_PSR_CY, CGEN_MODE_USI, 0, 0, COND_REF },
+  { OUTPUT, "msr_psr_ov", HW_H_PSB_PSR_OV, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, COND_REF },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_mhi_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "uimm18", HW_H_UIMM18, CGEN_MODE_UINT, OP_ENT (UIMM18), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_wmsr_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "uimm14", HW_H_UIMM14, CGEN_MODE_UINT, OP_ENT (UIMM14), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_cmpeq_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "rs2", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS2), 0, 0 },
+  { OUTPUT, "msr_psr_cc", HW_H_PSB_PSR_CC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_jmp_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { OUTPUT, "h_gpr_USI_rd", HW_H_GPR, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_jmp_i_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rel26", HW_H_IADDR, CGEN_MODE_USI, OP_ENT (REL26), 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_jmp_i_lnk_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "rel26", HW_H_IADDR, CGEN_MODE_USI, OP_ENT (REL26), 0, 0 },
+  { OUTPUT, "h_gpr_USI_1", HW_H_GPR, CGEN_MODE_USI, 0, 1, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_bt_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "msr_psr_cc", HW_H_PSB_PSR_CC, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "rel26", HW_H_IADDR, CGEN_MODE_USI, OP_ENT (REL26), 0, COND_REF },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, COND_REF },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldb_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_QI_c_call__AI_@cpu@_get_load_store_addr_rs1_ext__SI_simm14_1", HW_H_MEMORY, CGEN_MODE_QI, 0, 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldbu_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_UQI_c_call__AI_@cpu@_get_load_store_addr_rs1_ext__SI_simm14_1", HW_H_MEMORY, CGEN_MODE_UQI, 0, 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldh_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_HI_c_call__AI_@cpu@_get_load_store_addr_rs1_ext__SI_simm14_2", HW_H_MEMORY, CGEN_MODE_HI, 0, 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldhu_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_UHI_c_call__AI_@cpu@_get_load_store_addr_rs1_ext__SI_simm14_2", HW_H_MEMORY, CGEN_MODE_UHI, 0, 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldw_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_SI_c_call__AI_@cpu@_get_load_store_addr_rs1_ext__SI_simm14_4", HW_H_MEMORY, CGEN_MODE_SI, 0, 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldwu_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_USI_c_call__AI_@cpu@_get_load_store_addr_rs1_ext__SI_simm14_4", HW_H_MEMORY, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_stb_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "h_memory_UQI_addr", HW_H_MEMORY, CGEN_MODE_UQI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_sth_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "h_memory_UHI_addr", HW_H_MEMORY, CGEN_MODE_UHI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_stw_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "h_memory_USI_addr", HW_H_MEMORY, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_syscall_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldwa_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_USI_c_call__AI_@cpu@_get_load_store_addr_rs1_ext__SI_simm14_4", HW_H_MEMORY, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, 0 },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "atomic_addr", HW_H_ATOMIC_ADDR, CGEN_MODE_SI, 0, 0, 0 },
+  { OUTPUT, "atomic_flag", HW_H_ATOMIC_FLAG, CGEN_MODE_BI, 0, 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_stwa_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "atomic_addr", HW_H_ATOMIC_ADDR, CGEN_MODE_SI, 0, 0, 0 },
+  { INPUT, "atomic_flag", HW_H_ATOMIC_FLAG, CGEN_MODE_BI, 0, 0, 0 },
+  { INPUT, "msr_psr_cc", HW_H_PSB_PSR_CC, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs1", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS1), 0, COND_REF },
+  { INPUT, "simm14", HW_H_SIMM14, CGEN_MODE_INT, OP_ENT (SIMM14), 0, 0 },
+  { OUTPUT, "atomic_flag", HW_H_ATOMIC_FLAG, CGEN_MODE_BI, 0, 0, 0 },
+  { OUTPUT, "h_memory_USI_addr", HW_H_MEMORY, CGEN_MODE_USI, 0, 0, COND_REF },
+  { OUTPUT, "msr_psr_cc", HW_H_PSB_PSR_CC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+#undef OP_ENT
+#undef INPUT
+#undef OUTPUT
+#undef END
+#undef COND_REF
+
+/* Operand instance lookup table.  */
+
+static const CGEN_OPINST *ncpu32k_cgen_opinst_table[MAX_INSNS] = {
+  0,
+  & sfmt_nop_ops[0],
+  & sfmt_mov_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_xor_i_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_add_i_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_div_ops[0],
+  & sfmt_div_ops[0],
+  & sfmt_div_ops[0],
+  & sfmt_div_ops[0],
+  & sfmt_mhi_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_wmsr_ops[0],
+  & sfmt_cmpeq_ops[0],
+  & sfmt_cmpeq_ops[0],
+  & sfmt_cmpeq_ops[0],
+  & sfmt_jmp_ops[0],
+  & sfmt_jmp_i_ops[0],
+  & sfmt_jmp_i_lnk_ops[0],
+  & sfmt_bt_ops[0],
+  & sfmt_bt_ops[0],
+  & sfmt_ldb_ops[0],
+  & sfmt_ldbu_ops[0],
+  & sfmt_ldh_ops[0],
+  & sfmt_ldhu_ops[0],
+  & sfmt_ldw_ops[0],
+  & sfmt_ldwu_ops[0],
+  & sfmt_stb_ops[0],
+  & sfmt_sth_ops[0],
+  & sfmt_stw_ops[0],
+  & sfmt_syscall_ops[0],
+  & sfmt_nop_ops[0],
+  & sfmt_nop_ops[0],
+  & sfmt_ldwa_ops[0],
+  & sfmt_stwa_ops[0],
+};
+
+/* Function to call before using the operand instance table.  */
+
+void
+ncpu32k_cgen_init_opinst_table (CGEN_CPU_DESC cd)
+{
+  int i;
+  const CGEN_OPINST **oi = & ncpu32k_cgen_opinst_table[0];
+  CGEN_INSN *insns = (CGEN_INSN *) cd->insn_table.init_entries;
+  for (i = 0; i < MAX_INSNS; ++i)
+    insns[i].opinst = oi[i];
+}
