diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/archures.c binutils-ncpu32k-2.32/bfd/archures.c
--- binutils-2.32/bfd/archures.c	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/archures.c	2019-08-12 18:03:26.089312117 +0800
@@ -542,6 +542,10 @@
 .#define bfd_mach_ck803		5
 .#define bfd_mach_ck807		6
 .#define bfd_mach_ck810		7
+.
+.  bfd_arch_ncpu32k,   {* nano-CPU32k.  *}
+.#define bfd_mach_ncpu32k	1
+.
 .  bfd_arch_last
 .  };
 */
@@ -633,6 +637,7 @@
 extern const bfd_arch_info_type bfd_ft32_arch;
 extern const bfd_arch_info_type bfd_msp430_arch;
 extern const bfd_arch_info_type bfd_mt_arch;
+extern const bfd_arch_info_type bfd_ncpu32k_arch;
 extern const bfd_arch_info_type bfd_nds32_arch;
 extern const bfd_arch_info_type bfd_nfp_arch;
 extern const bfd_arch_info_type bfd_nios2_arch;
@@ -724,6 +729,7 @@
     &bfd_ft32_arch,
     &bfd_msp430_arch,
     &bfd_mt_arch,
+    &bfd_ncpu32k_arch,
     &bfd_nds32_arch,
     &bfd_nfp_arch,
     &bfd_nios2_arch,
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/bfd-in2.h binutils-ncpu32k-2.32/bfd/bfd-in2.h
--- binutils-2.32/bfd/bfd-in2.h	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/bfd-in2.h	2019-08-12 22:10:20.113679439 +0800
@@ -2441,6 +2441,10 @@
 #define bfd_mach_ck803         5
 #define bfd_mach_ck807         6
 #define bfd_mach_ck810         7
+
+  bfd_arch_ncpu32k,   /* nano-CPU32k.  */
+#define bfd_mach_ncpu32k       1
+
   bfd_arch_last
   };
 
@@ -5643,6 +5647,14 @@
   BFD_RELOC_NIOS2_R2_T1X1I6,
   BFD_RELOC_NIOS2_R2_T1X1I6_2,
 
+/* nano-cpu32k Relocations.  */
+  BFD_RELOC_NCPU32K_REL_16,
+  BFD_RELOC_NCPU32K_REL_21,
+  BFD_RELOC_NCPU32K_GLOB_DAT,
+  BFD_RELOC_NCPU32K_JMP_SLOT,
+  BFD_RELOC_NCPU32K_RELATIVE,
+  BFD_RELOC_NCPU32K_COPY,
+
 /* PRU LDI 16-bit unsigned data-memory relocation.  */
   BFD_RELOC_PRU_U16,
 
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/config.bfd binutils-ncpu32k-2.32/bfd/config.bfd
--- binutils-2.32/bfd/config.bfd	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/config.bfd	2019-07-31 11:43:11.643909611 +0800
@@ -183,6 +183,7 @@
 s12z*)         targ_archs=bfd_s12z_arch ;;
 microblaze*)	 targ_archs=bfd_microblaze_arch ;;
 mips*)		 targ_archs=bfd_mips_arch ;;
+ncpu32k*)	 targ_archs=bfd_ncpu32k_arch ;;
 nds32*)		 targ_archs=bfd_nds32_arch ;;
 nfp)		 targ_archs=bfd_nfp_arch ;;
 nios2*)          targ_archs=bfd_nios2_arch ;;
@@ -987,6 +988,10 @@
     targ_selvecs=msp430_elf32_ti_vec
     ;;
 
+  ncpu32k-*-elf | ncpu32k-*-linux*)
+    targ_defvec=ncpu32k_elf32_vec
+    ;;
+
   nds32*le-*-linux*)
     targ_defvec=nds32_elf32_linux_le_vec
     targ_selvecs=nds32_elf32_linux_be_vec
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/configure binutils-ncpu32k-2.32/bfd/configure
--- binutils-2.32/bfd/configure	2019-02-02 23:47:56.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/configure	2019-08-12 16:28:20.113170635 +0800
@@ -14805,6 +14805,7 @@
     msp430_elf32_vec)		 tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
     msp430_elf32_ti_vec)	 tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
     mt_elf32_vec)		 tb="$tb elf32-mt.lo elf32.lo $elf" ;;
+    ncpu32k_elf32_vec)		 tb="$tb elf32-ncpu32k.lo elf32.lo $elf" ;;
     nds32_elf32_be_vec)		 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_le_vec)		 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_linux_be_vec)	 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/configure.ac binutils-ncpu32k-2.32/bfd/configure.ac
--- binutils-2.32/bfd/configure.ac	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/configure.ac	2019-07-31 11:41:39.743907332 +0800
@@ -573,6 +573,7 @@
     msp430_elf32_vec)		 tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
     msp430_elf32_ti_vec)	 tb="$tb elf32-msp430.lo elf32.lo $elf" ;;
     mt_elf32_vec)		 tb="$tb elf32-mt.lo elf32.lo $elf" ;;
+    ncpu32k_elf32_vec)		 tb="$tb elf32-ncpu32k.lo elf32.lo $elf" ;;
     nds32_elf32_be_vec)		 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_le_vec)		 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
     nds32_elf32_linux_be_vec)	 tb="$tb elf32-nds32.lo elf32.lo $elf" ;;
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/cpu-ncpu32k.c binutils-ncpu32k-2.32/bfd/cpu-ncpu32k.c
--- binutils-2.32/bfd/cpu-ncpu32k.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/cpu-ncpu32k.c	2019-07-30 21:45:04.460689102 +0800
@@ -0,0 +1,39 @@
+/* BFD support for the ncpu32k architecture.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_ncpu32k_arch =
+  {
+    32,		  /* 32 bits in a word.  */
+    32,		  /* 32 bits in an address.  */
+    8,		  /* 8 bits in a byte.  */
+    bfd_arch_ncpu32k,
+    bfd_mach_ncpu32k,
+    "ncpu32k",
+    "ncpu32k",
+    4,
+    TRUE,
+    bfd_default_compatible,
+    bfd_default_scan,
+    bfd_arch_default_fill,
+    NULL
+  };
+
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/elf32-ncpu32k.c binutils-ncpu32k-2.32/bfd/elf32-ncpu32k.c
--- binutils-2.32/bfd/elf32-ncpu32k.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/elf32-ncpu32k.c	2019-08-12 22:01:59.821667034 +0800
@@ -0,0 +1,2205 @@
+/* nano-CPU32k-specific support for 32-bit ELF.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   largely based on elf32-or1k.c elf32-m32r.c and elf32-microblaze.c.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/ncpu32k.h"
+#include "libiberty.h"
+
+#define NCPU32K_NREG_RV 10
+#define NCPU32K_NREG_RVH 11
+#define NCPU32K_NREG_TLS 12
+#define NCPU32K_NREG_GOT 14
+
+#define N_ONES(X)	(((bfd_vma)2 << (X)) - 1)
+
+#define PLT_ENTRY_SIZE 16
+
+#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so.1"
+
+static reloc_howto_type ncpu32k_elf_howto_table[] =
+{
+  /* This reloc does nothing.  */
+  HOWTO (R_NCPU32K_NONE,	/* type */
+	 0,			/* rightshift */
+	 3,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_NONE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_16,
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_8,
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_8",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xff,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A PC relative 21 bit relocation, right shifted by 1.  */
+  HOWTO (R_NCPU32K_INSN_REL_21, /* type */
+	 1,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 21,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 6,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_INSN_REL_21", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xfffff800,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* A PC relative 16 bit relocation, right shifted by 1.  */
+  HOWTO (R_NCPU32K_INSN_REL_16, /* type */
+	 1,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 16,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_INSN_REL_16", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff0000,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* GNU extension to record C++ vtable hierarchy.  */
+  HOWTO (R_NCPU32K_GNU_VTINHERIT, /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_NCPU32K_GNU_VTINHERIT", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* GNU extension to record C++ vtable member usage.  */
+  HOWTO (R_NCPU32K_GNU_VTENTRY, /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
+	 "R_NCPU32K_GNU_VTENTRY", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+	 
+  HOWTO (R_NCPU32K_COPY,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_COPY",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_GLOB_DAT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_GLOB_DAT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_JMP_SLOT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_JMP_SLOT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_NCPU32K_RELATIVE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_NCPU32K_RELATIVE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+};
+
+/* Map BFD reloc types to ncpu32k ELF reloc types.  */
+
+struct ncpu32k_reloc_map
+{
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned int ncpu32k_reloc_val;
+};
+
+static const struct ncpu32k_reloc_map ncpu32k_reloc_map[] =
+{
+  { BFD_RELOC_NONE,			R_NCPU32K_NONE },
+  { BFD_RELOC_32,			R_NCPU32K_32 },
+  { BFD_RELOC_16,			R_NCPU32K_16 },
+  { BFD_RELOC_8,			R_NCPU32K_8 },
+  { BFD_RELOC_NCPU32K_REL_21,		R_NCPU32K_INSN_REL_21 },
+  { BFD_RELOC_NCPU32K_REL_16,		R_NCPU32K_INSN_REL_16 },
+  { BFD_RELOC_VTABLE_ENTRY,		R_NCPU32K_GNU_VTENTRY },
+  { BFD_RELOC_VTABLE_INHERIT,		R_NCPU32K_GNU_VTINHERIT },
+  { BFD_RELOC_NCPU32K_GLOB_DAT,		R_NCPU32K_GLOB_DAT },
+  { BFD_RELOC_NCPU32K_COPY,		R_NCPU32K_COPY },
+  { BFD_RELOC_NCPU32K_JMP_SLOT,		R_NCPU32K_JMP_SLOT },
+  { BFD_RELOC_NCPU32K_RELATIVE,		R_NCPU32K_RELATIVE },
+};
+
+#define TLS_UNKNOWN    0
+#define TLS_NONE       1
+#define TLS_GD	       2
+#define TLS_LD	       3
+#define TLS_IE	       4
+#define TLS_LE	       5
+
+/* ELF linker hash entry.  */
+struct elf_ncpu32k_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+
+  /* Track dynamic relocs copied for this symbol.  */
+  struct elf_dyn_relocs *dyn_relocs;
+
+  /* Track type of TLS access.  */
+  unsigned char tls_type;
+};
+
+/* ELF object data.  */
+struct elf_ncpu32k_obj_tdata
+{
+  struct elf_obj_tdata root;
+
+  /* tls_type for each local got entry.  */
+  unsigned char *local_tls_type;
+};
+
+#define elf_ncpu32k_tdata(abfd) \
+  ((struct elf_ncpu32k_obj_tdata *) (abfd)->tdata.any)
+
+#define elf_ncpu32k_local_tls_type(abfd) \
+  (elf_ncpu32k_tdata (abfd)->local_tls_type)
+
+/* ELF linker hash table.  */
+struct elf_ncpu32k_link_hash_table
+{
+  struct elf_link_hash_table root;
+
+  /* Small local sym to section mapping cache.  */
+  struct sym_cache sym_sec;
+
+  bfd_boolean saw_plta;
+};
+
+/* Get the ELF linker hash table from a link_info structure.  */
+#define ncpu32k_elf_hash_table(p) \
+  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
+   == NCPU32K_ELF_DATA ? ((struct elf_ncpu32k_link_hash_table *) ((p)->hash)) : NULL)
+
+static bfd_boolean
+elf_ncpu32k_mkobject (bfd *abfd)
+{
+  return bfd_elf_allocate_object (abfd, sizeof (struct elf_ncpu32k_obj_tdata),
+				  NCPU32K_ELF_DATA);
+}
+
+/* Create an entry in an ncpu32k ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+ncpu32k_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
+			    struct bfd_hash_table *table,
+			    const char *string)
+{
+  struct elf_ncpu32k_link_hash_entry *ret =
+    (struct elf_ncpu32k_link_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (ret == NULL)
+    ret = bfd_hash_allocate (table,
+			     sizeof (struct elf_ncpu32k_link_hash_entry));
+  if (ret == NULL)
+    return NULL;
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct elf_ncpu32k_link_hash_entry *)
+	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
+				     table, string));
+  if (ret != NULL)
+    {
+      struct elf_ncpu32k_link_hash_entry *eh;
+
+      eh = (struct elf_ncpu32k_link_hash_entry *) ret;
+      eh->dyn_relocs = NULL;
+      eh->tls_type = TLS_UNKNOWN;
+    }
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+/* Create an ncpu32k ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+ncpu32k_elf_link_hash_table_create (bfd *abfd)
+{
+  struct elf_ncpu32k_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct elf_ncpu32k_link_hash_table);
+
+  ret = bfd_zmalloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
+				      ncpu32k_elf_link_hash_newfunc,
+				      sizeof (struct elf_ncpu32k_link_hash_entry),
+				      NCPU32K_ELF_DATA))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  return &ret->root.root;
+}
+
+static reloc_howto_type *
+ncpu32k_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
+			bfd_reloc_code_real_type bcode)
+{
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (ncpu32k_reloc_map); i++)
+    if (ncpu32k_reloc_map[i].bfd_reloc_val == bcode)
+      {
+	unsigned int ocode = ncpu32k_reloc_map[i].ncpu32k_reloc_val;
+	if (ocode < (unsigned int) R_NCPU32K_max)
+	  return &ncpu32k_elf_howto_table[ocode];
+	else
+	  break;
+      }
+
+  return NULL;
+}
+
+static reloc_howto_type *
+ncpu32k_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0; i < R_NCPU32K_max; i++)
+    if (ncpu32k_elf_howto_table[i].name != NULL
+	&& strcasecmp (ncpu32k_elf_howto_table[i].name, r_name) == 0)
+      return &ncpu32k_elf_howto_table[i];
+
+  return NULL;
+}
+
+/* Set the howto pointer for an ncpu32k ELF reloc.  */
+
+static bfd_boolean
+ncpu32k_info_to_howto_rela (bfd * abfd,
+			 arelent * cache_ptr,
+			 Elf_Internal_Rela * dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  if (r_type >= (unsigned int) R_NCPU32K_max)
+    {
+      /* xgettext:c-format */
+      _bfd_error_handler (_("%pB: unsupported relocation type %#x"),
+			  abfd, r_type);
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }
+  cache_ptr->howto = & ncpu32k_elf_howto_table[r_type];
+  return TRUE;
+}
+
+
+/* Return the relocation value for @tpoff relocations..  */
+static bfd_vma
+tpoff (struct bfd_link_info *info, bfd_vma address)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+
+  /* The thread pointer on ncpu32k stores the address after the TCB where
+     the data is, just compute the difference. No need to compensate
+     for the size of TCB.  */
+  return (address - elf_hash_table (info)->tls_sec->vma);
+}
+
+/* Like _bfd_final_link_relocate, but handles non-contiguous fields.  */
+
+static bfd_reloc_status_type
+ncpu32k_final_link_relocate (reloc_howto_type *howto, bfd *input_bfd,
+			  asection *input_section, bfd_byte *contents,
+			  bfd_vma offset, bfd_vma value)
+{
+  bfd_reloc_status_type status = bfd_reloc_ok;
+  int size = bfd_get_reloc_size (howto);
+  bfd_vma x, place;
+
+  /* Sanity check the address.  */
+  if (offset + size > bfd_get_section_limit_octets (input_bfd, input_section))
+    return bfd_reloc_outofrange;
+
+  place = (input_section->output_section->vma
+	   + input_section->output_offset
+	   + (howto->pcrel_offset ? offset : 0));
+
+  switch (howto->type)
+    {
+    case R_NCPU32K_INSN_REL_16:
+    case R_NCPU32K_INSN_REL_21:
+      value -= place;
+      /* Diagnose mis-aligned (non 2 byte) branch targets.  */
+      if (value & 1)
+	status = bfd_reloc_dangerous;
+      break;
+
+    default:
+      if (howto->pc_relative)
+	value -= place;
+      break;
+    }
+
+  status = bfd_check_overflow (howto->complain_on_overflow,
+			       howto->bitsize,
+			       howto->rightshift,
+			       bfd_arch_bits_per_address (input_bfd),
+			       value);
+  value >>= howto->rightshift;
+
+  /* If we're overwriting the entire destination,
+     then no need to read the current contents.  */
+  if (size == 0 || howto->dst_mask == N_ONES (size))
+    x = 0;
+  else
+    {
+      BFD_ASSERT (size == 4);
+      x = bfd_get_32 (input_bfd, contents + offset);
+    }
+
+  switch (howto->type)
+    {
+    default:
+      {
+	bfd_vma fieldmask = howto->dst_mask;
+	value <<= howto->bitpos;
+	x = (x & ~fieldmask) | (value & fieldmask);
+      }
+      break;
+    }
+
+  /* Put the relocated value back in the object file.  */
+  switch (size)
+    {
+    case 0:
+      break;
+    case 1:
+      bfd_put_8 (input_bfd, x, contents + offset);
+      break;
+    case 2:
+      bfd_put_16 (input_bfd, x, contents + offset);
+      break;
+    case 4:
+      bfd_put_32 (input_bfd, x, contents + offset);
+      break;
+#ifdef BFD64
+    case 8:
+      bfd_put_64 (input_bfd, x, contents + offset);
+      break;
+#endif
+    default:
+      _bfd_error_handler
+	(_("%pB: Cannot handle relocation value size of %d"),
+	 input_bfd, size);
+      abort ();
+    }
+  return status;
+}
+
+/* Relocate an ncpu32k ELF section.
+
+   The RELOCATE_SECTION function is called by the new ELF backend linker
+   to handle the relocations for a section.
+
+   The relocs are always passed as Rela structures; if the section
+   actually uses Rel structures, the r_addend field will always be
+   zero.
+
+   This function is responsible for adjusting the section contents as
+   necessary, and (if using Rela relocs and generating a relocatable
+   output file) adjusting the reloc addend as necessary.
+
+   This function does not have to worry about setting the reloc
+   address or the reloc symbol index.
+
+   LOCAL_SYMS is a pointer to the swapped in local symbols.
+
+   LOCAL_SECTIONS is an array giving the section in the input file
+   corresponding to the st_shndx field of each local symbol.
+
+   The global hash table entry for the global symbols can be found
+   via elf_sym_hashes (input_bfd).
+
+   When generating relocatable output, this function must handle
+   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
+   going to be the section symbol corresponding to the output
+   section, which means that the addend must be adjusted
+   accordingly.  */
+
+static bfd_boolean
+ncpu32k_elf_relocate_section (bfd *output_bfd,
+			   struct bfd_link_info *info,
+			   bfd *input_bfd,
+			   asection *input_section,
+			   bfd_byte *contents,
+			   Elf_Internal_Rela *relocs,
+			   Elf_Internal_Sym *local_syms,
+			   asection **local_sections)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+  struct elf_ncpu32k_link_hash_table *htab = ncpu32k_elf_hash_table (info);
+  bfd *dynobj;
+  asection *sreloc;
+  bfd_vma *local_got_offsets;
+  asection *sgot, *splt;
+  bfd_vma plt_base, got_base, got_sym_value;
+  bfd_boolean ret_val = TRUE;
+
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+  local_got_offsets = elf_local_got_offsets (input_bfd);
+
+  sreloc = elf_section_data (input_section)->sreloc;
+
+  splt = htab->root.splt;
+  plt_base = 0;
+  if (splt != NULL)
+    plt_base = splt->output_section->vma + splt->output_offset;
+
+  sgot = htab->root.sgot;
+  got_sym_value = got_base = 0;
+  if (sgot != NULL)
+    {
+      struct elf_link_hash_entry *hgot = htab->root.hgot;
+      got_sym_value = (hgot->root.u.def.value
+		       + hgot->root.u.def.section->output_section->vma
+		       + hgot->root.u.def.section->output_offset);
+    got_base = sgot->output_section->vma + sgot->output_offset;
+    }
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+  relend = relocs + input_section->reloc_count;
+
+  for (rel = relocs; rel < relend; rel++)
+    {
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      struct elf_link_hash_entry *h;
+      bfd_vma relocation;
+      bfd_reloc_status_type r;
+      const char *name = NULL;
+      int r_type;
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      if (r_type == R_NCPU32K_GNU_VTINHERIT
+	  || r_type == R_NCPU32K_GNU_VTENTRY)
+	continue;
+
+      if (r_type < 0 || r_type >= (int) R_NCPU32K_max)
+	{
+	  _bfd_error_handler
+	    (_("%pB: unknown relocation type %d"),
+	     input_bfd, (int) r_type);
+	  bfd_set_error (bfd_error_bad_value);
+	  ret_val = FALSE;
+	  continue;
+	}
+
+      howto = ncpu32k_elf_howto_table + ELF32_R_TYPE (rel->r_info);
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+
+	  name = bfd_elf_string_from_elf_section
+	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
+	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
+	}
+      else
+	{
+	  bfd_boolean unresolved_reloc, warned, ignored;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned, ignored);
+	  name = h->root.root.string;
+	}
+
+      if (sec != NULL && discarded_section (sec))
+	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+					 rel, 1, relend, howto, 0, contents);
+
+      if (bfd_link_relocatable (info))
+	continue;
+
+      switch (howto->type)
+	{
+        case R_NCPU32K_INSN_REL_16:
+	case R_NCPU32K_INSN_REL_21:
+	  /* For a non-shared link, these will reference either the plt
+	     or a .dynbss copy of the symbol.  */
+	  if (bfd_link_pic (info) && !SYMBOL_REFERENCES_LOCAL (info, h))
+	    {
+	      _bfd_error_handler
+		(_("%pB: pc-relative relocation against dynamic symbol %s"),
+		 input_bfd, name);
+	      ret_val = FALSE;
+	      bfd_set_error (bfd_error_bad_value);
+	    }
+	  break;
+
+	case R_NCPU32K_32:
+	  /* R_NCPU32K_16? */
+	  {
+	    /* r_symndx will be STN_UNDEF (zero) only for relocs against symbols
+	       from removed linkonce sections, or sections discarded by
+	       a linker script.  */
+	    if (r_symndx == STN_UNDEF
+		|| (input_section->flags & SEC_ALLOC) == 0)
+	      break;
+
+	    /* Emit a direct relocation if the symbol is dynamic,
+	       or a RELATIVE reloc for shared objects.  We can omit
+	       RELATIVE relocs to local undefweak symbols.  */
+	    if (bfd_link_pic (info)
+		? (h == NULL
+		     || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
+		     || h->root.type != bfd_link_hash_undefweak)
+		: (h != NULL
+		    && h->dynindx != -1
+		    && !h->non_got_ref
+		   && ((h->def_dynamic && !h->def_regular)
+			|| h->root.type == bfd_link_hash_undefweak
+			|| h->root.type == bfd_link_hash_undefined)))
+	      {
+		Elf_Internal_Rela outrel;
+		bfd_byte *loc;
+		bfd_boolean skip;
+
+		/* When generating a shared object, these relocations
+		   are copied into the output file to be resolved at run
+		   time.  */
+
+		BFD_ASSERT (sreloc != NULL);
+
+		skip = FALSE;
+
+		outrel.r_offset =
+		  _bfd_elf_section_offset (output_bfd, info, input_section,
+					   rel->r_offset);
+		if (outrel.r_offset == (bfd_vma) -1)
+		  skip = TRUE;
+		else if (outrel.r_offset == (bfd_vma) -2)
+		  skip = TRUE;
+		outrel.r_offset += (input_section->output_section->vma
+				    + input_section->output_offset);
+
+		if (skip)
+		  memset (&outrel, 0, sizeof outrel);
+		else if (SYMBOL_REFERENCES_LOCAL (info, h))
+		  {
+		    outrel.r_info = ELF32_R_INFO (0, R_NCPU32K_RELATIVE);
+		    outrel.r_addend = relocation + rel->r_addend;
+		  }
+		else
+		  {
+		    BFD_ASSERT (h->dynindx != -1);
+		    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
+		    outrel.r_addend = rel->r_addend;
+		  }
+
+		loc = sreloc->contents;
+		loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
+		bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
+		break;
+	      }
+	    break;
+	  }
+
+	default:
+	  break;
+	}
+
+      r = ncpu32k_final_link_relocate (howto, input_bfd, input_section, contents,
+				    rel->r_offset, relocation + rel->r_addend);
+
+      if (r != bfd_reloc_ok)
+	{
+	  const char *msg = NULL;
+
+	  switch (r)
+	    {
+	    case bfd_reloc_overflow:
+	      (*info->callbacks->reloc_overflow)
+		(info, (h ? &h->root : NULL), name, howto->name,
+		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
+	      break;
+
+	    case bfd_reloc_undefined:
+	      (*info->callbacks->undefined_symbol)
+		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
+	      break;
+
+	    case bfd_reloc_outofrange:
+	      msg = _("internal error: out of range error");
+	      break;
+
+	    case bfd_reloc_notsupported:
+	      msg = _("internal error: unsupported relocation error");
+	      break;
+
+	    case bfd_reloc_dangerous:
+	      msg = _("internal error: dangerous relocation");
+	      break;
+
+	    default:
+	      msg = _("internal error: unknown error");
+	      break;
+	    }
+
+	  if (msg)
+	    (*info->callbacks->warning) (info, msg, name, input_bfd,
+					 input_section, rel->r_offset);
+	}
+    }
+
+  return ret_val;
+}
+
+/* Return the section that should be marked against GC for a given
+   relocation.  */
+
+static asection *
+ncpu32k_elf_gc_mark_hook (asection *sec,
+		       struct bfd_link_info *info,
+		       Elf_Internal_Rela *rel,
+		       struct elf_link_hash_entry *h,
+		       Elf_Internal_Sym *sym)
+{
+  if (h != NULL)
+    switch (ELF32_R_TYPE (rel->r_info))
+      {
+      case R_NCPU32K_GNU_VTINHERIT:
+      case R_NCPU32K_GNU_VTENTRY:
+	return NULL;
+      }
+
+  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
+}
+
+/* Look through the relocs for a section during the first phase.  */
+
+static bfd_boolean
+ncpu32k_elf_check_relocs (bfd *abfd,
+		       struct bfd_link_info *info,
+		       asection *sec,
+		       const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+
+  const Elf_Internal_Rela *rel_end;
+  struct elf_ncpu32k_link_hash_table *htab;
+  bfd *dynobj;
+  asection *sreloc = NULL;
+
+  if (bfd_link_relocatable (info))
+    return TRUE;
+
+  /* Don't do anything special with non-loaded, non-alloced sections.
+     In particular, any relocs in such sections should not affect GOT
+     and PLT reference counting (ie. we don't allow them to create GOT
+     or PLT entries), there's no possibility or desire to optimize TLS
+     relocs, and there's not much point in propagating relocs to shared
+     libs that the dynamic linker won't relocate.  */
+  if ((sec->flags & SEC_ALLOC) == 0)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      struct elf_link_hash_entry *h;
+      unsigned long r_symndx;
+      unsigned char tls_type;
+      int r_type;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx < symtab_hdr->sh_info)
+	h = NULL;
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      switch (r_type)
+	{
+	default:
+	  tls_type = TLS_NONE;
+	}
+
+      /* Record TLS type.  */
+      if (h != NULL)
+	  ((struct elf_ncpu32k_link_hash_entry *) h)->tls_type = tls_type;
+      else
+	{
+	  unsigned char *local_tls_type;
+
+	  /* This is a TLS type record for a local symbol.  */
+	  local_tls_type = (unsigned char *) elf_ncpu32k_local_tls_type (abfd);
+	  if (local_tls_type == NULL)
+	    {
+	      bfd_size_type size;
+
+	      size = symtab_hdr->sh_info;
+	      local_tls_type = bfd_zalloc (abfd, size);
+	      if (local_tls_type == NULL)
+		return FALSE;
+	      elf_ncpu32k_local_tls_type (abfd) = local_tls_type;
+	    }
+	  local_tls_type[r_symndx] = tls_type;
+	}
+
+      switch (r_type)
+	{
+	  /* This relocation describes the C++ object vtable hierarchy.
+	     Reconstruct it for later use during GC.  */
+	case R_NCPU32K_GNU_VTINHERIT:
+	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	  /* This relocation describes which C++ vtable entries are actually
+	     used.  Record for later use during GC.  */
+	case R_NCPU32K_GNU_VTENTRY:
+	  BFD_ASSERT (h != NULL);
+	  if (h != NULL
+	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+	    return FALSE;
+	  break;
+
+        case R_NCPU32K_INSN_REL_16:
+	case R_NCPU32K_INSN_REL_21:
+	case R_NCPU32K_32:
+	  {
+	    if (h != NULL && !bfd_link_pic (info))
+	      {
+		/* We may need a copy reloc.  */
+		h->non_got_ref = 1;
+
+		/* We may also need a .plt entry.  */
+		h->plt.refcount += 1;
+		if (r_type != R_NCPU32K_INSN_REL_16 && r_type != R_NCPU32K_INSN_REL_21)
+		  h->pointer_equality_needed = 1;
+	      }
+
+	    /* If we are creating a shared library, and this is a reloc
+	       against a global symbol, or a non PC relative reloc
+	       against a local symbol, then we need to copy the reloc
+	       into the shared library.  However, if we are linking with
+	       -Bsymbolic, we do not need to copy a reloc against a
+	       global symbol which is defined in an object we are
+	       including in the link (i.e., DEF_REGULAR is set).  At
+	       this point we have not seen all the input files, so it is
+	       possible that DEF_REGULAR is not set now but will be set
+	       later (it is never cleared).  In case of a weak definition,
+	       DEF_REGULAR may be cleared later by a strong definition in
+	       a shared library.  We account for that possibility below by
+	       storing information in the relocs_copied field of the hash
+	       table entry.  A similar situation occurs when creating
+	       shared libraries and symbol visibility changes render the
+	       symbol local.
+
+	       If on the other hand, we are creating an executable, we
+	       may need to keep relocations for symbols satisfied by a
+	       dynamic library if we manage to avoid copy relocs for the
+	       symbol.  */
+
+	    if ((bfd_link_pic (info)
+		 && (sec->flags & SEC_ALLOC) != 0
+		 && ((r_type != R_NCPU32K_INSN_REL_16 && r_type != R_NCPU32K_INSN_REL_21)
+		     || (h != NULL
+			 && (!SYMBOLIC_BIND (info, h)
+			     || h->root.type == bfd_link_hash_defweak
+			     || !h->def_regular))))
+		|| (!bfd_link_pic (info)
+		    && (sec->flags & SEC_ALLOC) != 0
+		    && h != NULL
+		    && (h->root.type == bfd_link_hash_defweak
+			|| !h->def_regular)))
+	      {
+		struct elf_dyn_relocs *p;
+		struct elf_dyn_relocs **head;
+
+		/* When creating a shared object, we must copy these
+		   relocs into the output file.  We create a reloc
+		   section in dynobj and make room for the reloc.  */
+		if (sreloc == NULL)
+		  {
+		    const char *name;
+		    unsigned int strndx = elf_elfheader (abfd)->e_shstrndx;
+		    unsigned int shnam = _bfd_elf_single_rel_hdr (sec)->sh_name;
+
+		    name = bfd_elf_string_from_elf_section (abfd, strndx, shnam);
+		    if (name == NULL)
+		      return FALSE;
+
+		    if (strncmp (name, ".rela", 5) != 0
+			|| strcmp (bfd_get_section_name (abfd, sec),
+				   name + 5) != 0)
+		      {
+			_bfd_error_handler
+			  /* xgettext:c-format */
+			  (_("%pB: bad relocation section name `%s\'"),
+			   abfd, name);
+		      }
+
+		    if (htab->root.dynobj == NULL)
+		      htab->root.dynobj = abfd;
+		    dynobj = htab->root.dynobj;
+
+		    sreloc = bfd_get_section_by_name (dynobj, name);
+		    if (sreloc == NULL)
+		      {
+			sreloc = _bfd_elf_make_dynamic_reloc_section
+			  (sec, dynobj, 2, abfd, /*rela?*/ TRUE);
+
+			if (sreloc == NULL)
+			  return FALSE;
+		      }
+		    elf_section_data (sec)->sreloc = sreloc;
+		  }
+
+		/* If this is a global symbol, we count the number of
+		   relocations we need for this symbol.  */
+		if (h != NULL)
+		  head = &((struct elf_ncpu32k_link_hash_entry *) h)->dyn_relocs;
+		else
+		  {
+		    /* Track dynamic relocs needed for local syms too.
+		       We really need local syms available to do this
+		       easily.  Oh well.  */
+
+		    asection *s;
+		    Elf_Internal_Sym *isym;
+		    void *vpp;
+
+		    isym = bfd_sym_from_r_symndx (&htab->sym_sec,
+						  abfd, r_symndx);
+		    if (isym == NULL)
+		      return FALSE;
+
+		    s = bfd_section_from_elf_index (abfd, isym->st_shndx);
+		    if (s == NULL)
+		      return FALSE;
+
+		    vpp = &elf_section_data (s)->local_dynrel;
+		    head = (struct elf_dyn_relocs **) vpp;
+		  }
+
+		p = *head;
+		if (p == NULL || p->sec != sec)
+		  {
+		    bfd_size_type amt = sizeof *p;
+		    p = ((struct elf_dyn_relocs *)
+			 bfd_alloc (htab->root.dynobj, amt));
+		    if (p == NULL)
+		      return FALSE;
+		    p->next = *head;
+		    *head = p;
+		    p->sec = sec;
+		    p->count = 0;
+		    p->pc_count = 0;
+		  }
+
+		p->count += 1;
+		if (r_type == R_NCPU32K_INSN_REL_16 || r_type == R_NCPU32K_INSN_REL_21)
+		  p->pc_count += 1;
+	      }
+	  }
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Generate instructions of PLT */
+
+#define NCPU32K_ROP_INSN16(RS,RD,OPC)		((OPC) | ((RD) << 6) | ((RS) << 11))
+#define NCPU32K_IMM_INSN32(IMM,RS,RD,OPC)	((OPC) | ((RD) << 6) | ((RS) << 11) | ((IMM) << 16))
+#define NCPU32K_REL_INSN32(REL,RD,OPC)		((OPC) | ((RD) << 6) | ((REL) << 11))
+
+#define NCPU32K_MHI(RD,IMM)		NCPU32K_IMM_INSN32(IMM, 0,RD,0x00000025)
+#define NCPU32K_PCRP(RD,IMM)		NCPU32K_IMM_INSN32(IMM, 0,RD,0x0000002d)
+#define NCPU32K_LDWU(RD,A,IMM)		NCPU32K_IMM_INSN32(IMM, A,RD,0x00000010)
+#define NCPU32K_MOV(RD,IMM)		NCPU32K_IMM_INSN32(IMM, 0,RD,0x00000003) /* or.i */
+#define NCPU32K_JMP(RS)			NCPU32K_ROP_INSN16(RS,  1,0x000a) /* lnk=1 */
+#define NCPU32K_NOP			NCPU32K_ROP_INSN16(0,   0,0x0002) /* or */
+
+/* Finish up the dynamic sections.  */
+
+static bfd_boolean
+ncpu32k_elf_finish_dynamic_sections (bfd *output_bfd,
+				  struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  asection *sdyn, *sgot;
+  struct elf_ncpu32k_link_hash_table *htab;
+
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+
+  sgot = htab->root.sgotplt;
+  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+
+  if (htab->root.dynamic_sections_created)
+    {
+      asection *splt;
+      Elf32_External_Dyn *dyncon, *dynconend;
+
+      BFD_ASSERT (sgot != NULL && sdyn != NULL);
+
+      dyncon = (Elf32_External_Dyn *) sdyn->contents;
+      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
+
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+	  asection *s;
+
+	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      continue;
+
+	    case DT_PLTGOT:
+	      s = htab->root.sgotplt;
+	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	      break;
+
+	    case DT_JMPREL:
+	      s = htab->root.srelplt;
+	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
+	      break;
+
+	    case DT_PLTRELSZ:
+	      s = htab->root.srelplt;
+	      dyn.d_un.d_val = s->size;
+	      break;
+	    }
+	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+	}
+
+
+      /* Fill in the first entry in the procedure linkage table.  */
+      splt = htab->root.splt;
+      if (splt && splt->size > 0)
+	{
+	  bfd_vma got_addr = sgot->output_section->vma + sgot->output_offset;
+
+	  /* r15 is used to store the branch address. */
+
+	  /* Note we force 16 byte alignment on the .got, so that
+	     the movhi/adrp can be shared between the two loads.  */
+
+	  if (htab->saw_plta)
+	    {
+	      bfd_vma pc = splt->output_section->vma + splt->output_offset;
+	      unsigned pa = ((got_addr >> 13) - (pc >> 13)) & 0x1fffff;
+	      unsigned po = got_addr & 0x1fff;
+	      bfd_put_32 (output_bfd, NCPU32K_PCRP(NCPU32K_NREG_RVH, pa), splt->contents);
+	      bfd_put_32 (output_bfd, NCPU32K_LDWU(15,NCPU32K_NREG_RVH, (po + 8)), splt->contents);
+	      bfd_put_32 (output_bfd, NCPU32K_LDWU(NCPU32K_NREG_RVH,NCPU32K_NREG_RVH, (po + 4)), splt->contents);
+	    }
+	  else if (bfd_link_pic (info))
+	    {
+	      bfd_put_32 (output_bfd, NCPU32K_LDWU(15, NCPU32K_NREG_GOT, 8), splt->contents);			/* .got+8 */
+	      bfd_put_32 (output_bfd, NCPU32K_LDWU(NCPU32K_NREG_RVH, NCPU32K_NREG_GOT, 4), splt->contents);	/* .got+4 */
+	    }
+	  else
+	    {
+	      unsigned ha = ((got_addr + 0x8000) >> 16) & 0xffff;
+	      unsigned lo = got_addr & 0xffff;
+	      bfd_put_32 (output_bfd, NCPU32K_MHI(NCPU32K_NREG_RVH, ha), splt->contents);
+	      bfd_put_32 (output_bfd, NCPU32K_LDWU(15,NCPU32K_NREG_RVH, lo + 8), splt->contents);
+	      bfd_put_32 (output_bfd, NCPU32K_LDWU(NCPU32K_NREG_RVH,NCPU32K_NREG_RVH, lo + 4), splt->contents);
+	    }
+
+	  bfd_put_16 (output_bfd, NCPU32K_JMP(15), splt->contents);
+
+	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;
+	}
+    }
+
+  /* Set the first entry in the global offset table to the address of
+     the dynamic section.  */
+  if (sgot && sgot->size > 0)
+    {
+      if (sdyn == NULL)
+	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
+      else
+	bfd_put_32 (output_bfd,
+		    sdyn->output_section->vma + sdyn->output_offset,
+		    sgot->contents);
+      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
+    }
+
+  if (htab->root.sgot && htab->root.sgot->size > 0)
+    elf_section_data (htab->root.sgot->output_section)->this_hdr.sh_entsize = 4;
+
+  return TRUE;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static bfd_boolean
+ncpu32k_elf_finish_dynamic_symbol (bfd *output_bfd,
+				struct bfd_link_info *info,
+				struct elf_link_hash_entry *h,
+				Elf_Internal_Sym *sym)
+{
+  struct elf_ncpu32k_link_hash_table *htab;
+  bfd_byte *loc;
+
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  if (h->plt.offset != (bfd_vma) -1)
+    {
+      asection *splt;
+      asection *sgot;
+      asection *srela;
+      bfd_vma plt_base_addr;
+      bfd_vma plt_addr;
+      bfd_vma plt_index;
+      bfd_vma plt_reloc;
+      bfd_vma got_base_addr;
+      bfd_vma got_offset;
+      bfd_vma got_addr;
+      Elf_Internal_Rela rela;
+
+      /* This symbol has an entry in the procedure linkage table.  Set
+	 it up.  */
+      BFD_ASSERT (h->dynindx != -1);
+
+      splt = htab->root.splt;
+      sgot = htab->root.sgotplt;
+      srela = htab->root.srelplt;
+      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);
+
+      plt_base_addr = splt->output_section->vma + splt->output_offset;
+      got_base_addr = sgot->output_section->vma + sgot->output_offset;
+
+      /* Get the index in the procedure linkage table which
+	 corresponds to this symbol.  This is the index of this symbol
+	 in all the symbols for which we are making plt entries.  The
+	 first entry in the procedure linkage table is reserved.  */
+      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
+      plt_addr = plt_base_addr + h->plt.offset;
+      plt_reloc = plt_index * sizeof (Elf32_External_Rela);
+
+      /* Get the offset into the .got table of the entry that
+	corresponds to this function.  Each .got entry is 4 bytes.
+	The first three are reserved.  */
+      got_offset = (plt_index + 3) * 4;
+      got_addr = got_base_addr + got_offset;
+
+      /* Fill in the entry in the procedure linkage table.  */
+      if (htab->saw_plta)
+	{
+	  unsigned pa = ((got_addr >> 13) - (plt_addr >> 13)) & 0x1fffff;
+	  unsigned po = (got_addr & 0x1fff);
+	  bfd_put_32 (output_bfd, NCPU32K_PCRP(NCPU32K_NREG_RVH, pa), splt->contents + h->plt.offset);
+	  bfd_put_32 (output_bfd, NCPU32K_LDWU(NCPU32K_NREG_RVH,NCPU32K_NREG_RVH, po), splt->contents + h->plt.offset);
+	  bfd_put_32 (output_bfd, NCPU32K_MOV(NCPU32K_NREG_RV, plt_reloc), splt->contents + h->plt.offset);
+	}
+      else if (bfd_link_pic (info))
+	{
+	  bfd_put_32 (output_bfd, NCPU32K_LDWU(NCPU32K_NREG_RVH,NCPU32K_NREG_GOT, got_offset), splt->contents + h->plt.offset);
+	  bfd_put_32 (output_bfd, NCPU32K_MOV(NCPU32K_NREG_RV, plt_reloc), splt->contents + h->plt.offset);
+	}
+      else
+	{
+	  unsigned ha = ((got_addr + 0x8000) >> 16) & 0xffff;
+	  unsigned lo = got_addr & 0xffff;
+	  bfd_put_32 (output_bfd, NCPU32K_MHI(NCPU32K_NREG_RVH, ha), splt->contents + h->plt.offset);
+	  bfd_put_32 (output_bfd, NCPU32K_LDWU(NCPU32K_NREG_RVH,NCPU32K_NREG_RVH,lo), splt->contents + h->plt.offset);
+	  bfd_put_32 (output_bfd, NCPU32K_MOV(NCPU32K_NREG_RV, plt_reloc), splt->contents + h->plt.offset);
+	}
+
+      bfd_put_32 (output_bfd, NCPU32K_JMP(NCPU32K_NREG_RVH), splt->contents + h->plt.offset);
+
+
+      /* Fill in the entry in the global offset table.  */
+      bfd_put_32 (output_bfd, plt_addr, sgot->contents + got_offset);
+
+      /* Fill in the entry in the .rela.plt section.  */
+      rela.r_offset = got_addr;
+      rela.r_info = ELF32_R_INFO (h->dynindx, R_NCPU32K_JMP_SLOT);
+      rela.r_addend = 0;
+      loc = srela->contents;
+      loc += plt_index * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+
+      if (!h->def_regular)
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value alone.  */
+	  sym->st_shndx = SHN_UNDEF;
+	}
+    }
+
+  if (h->got.offset != (bfd_vma) -1
+      && (h->got.offset & 2) == 0) /* Homemade TLS check.  */
+    {
+      asection *sgot;
+      asection *srela;
+      Elf_Internal_Rela rela;
+
+      /* This symbol has an entry in the global offset table.  Set it
+	 up.  */
+      sgot = htab->root.sgot;
+      srela = htab->root.srelgot;
+      BFD_ASSERT (sgot != NULL && srela != NULL);
+
+      rela.r_offset = (sgot->output_section->vma
+		       + sgot->output_offset
+		       + (h->got.offset &~ 1));
+
+      /* If this is a -Bsymbolic link, and the symbol is defined
+	 locally, we just want to emit a RELATIVE reloc.  Likewise if
+	 the symbol was forced to be local because of a version file.
+	 The entry in the global offset table will already have been
+	 initialized in the relocate_section function.  */
+      if (bfd_link_pic (info) && SYMBOL_REFERENCES_LOCAL (info, h))
+	{
+	  rela.r_info = ELF32_R_INFO (0, R_NCPU32K_RELATIVE);
+	  rela.r_addend = (h->root.u.def.value
+			   + h->root.u.def.section->output_section->vma
+			   + h->root.u.def.section->output_offset);
+	}
+      else
+	{
+	  BFD_ASSERT ((h->got.offset & 1) == 0);
+	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
+	  rela.r_info = ELF32_R_INFO (h->dynindx, R_NCPU32K_GLOB_DAT);
+	  rela.r_addend = 0;
+	}
+
+      loc = srela->contents;
+      loc += srela->reloc_count * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+      ++srela->reloc_count;
+    }
+
+  if (h->needs_copy)
+    {
+      asection *s;
+      Elf_Internal_Rela rela;
+
+      /* This symbols needs a copy reloc.  Set it up.  */
+      BFD_ASSERT (h->dynindx != -1
+		  && (h->root.type == bfd_link_hash_defined
+		      || h->root.type == bfd_link_hash_defweak));
+
+      rela.r_offset = (h->root.u.def.value
+		       + h->root.u.def.section->output_section->vma
+		       + h->root.u.def.section->output_offset);
+      rela.r_info = ELF32_R_INFO (h->dynindx, R_NCPU32K_COPY);
+      rela.r_addend = 0;
+      if (h->root.u.def.section == htab->root.sdynrelro)
+	s = htab->root.sreldynrelro;
+      else
+	s = htab->root.srelbss;
+      loc = s->contents + s->reloc_count * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+      ++s->reloc_count;
+    }
+
+  /* Mark some specially defined symbols as absolute.  */
+  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
+      || h == htab->root.hgot)
+    sym->st_shndx = SHN_ABS;
+
+  return TRUE;
+}
+
+static enum elf_reloc_type_class
+ncpu32k_elf_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
+			   const asection *rel_sec ATTRIBUTE_UNUSED,
+			   const Elf_Internal_Rela *rela)
+{
+  switch ((int) ELF32_R_TYPE (rela->r_info))
+    {
+    case R_NCPU32K_RELATIVE:	return reloc_class_relative;
+    case R_NCPU32K_JMP_SLOT:	return reloc_class_plt;
+    case R_NCPU32K_COPY:	return reloc_class_copy;
+    default:			return reloc_class_normal;
+    }
+}
+
+/* Find dynamic relocs for H that apply to read-only sections.  */
+
+static asection *
+readonly_dynrelocs (struct elf_link_hash_entry *h)
+{
+  struct elf_dyn_relocs *p;
+  struct elf_ncpu32k_link_hash_entry *eh = (struct elf_ncpu32k_link_hash_entry *) h;
+
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *s = p->sec->output_section;
+
+      if (s != NULL && (s->flags & SEC_READONLY) != 0)
+	return p->sec;
+    }
+  return NULL;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+ncpu32k_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
+				struct elf_link_hash_entry *h)
+{
+  struct elf_ncpu32k_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s, *srel;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+	      && (h->needs_plt
+		  || h->is_weakalias
+		  || (h->def_dynamic
+		      && h->ref_regular
+		      && !h->def_regular)));
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later,
+     when we know the address of the .got section.  */
+  if (h->type == STT_FUNC
+      || h->needs_plt)
+    {
+      if (! bfd_link_pic (info)
+	  && !h->def_dynamic
+	  && !h->ref_dynamic
+	  && h->root.type != bfd_link_hash_undefweak
+	  && h->root.type != bfd_link_hash_undefined)
+	{
+	  /* This case can occur if we saw a PLT reloc in an input
+	     file, but the symbol was never referred to by a dynamic
+	     object.  In such a case, we don't actually need to build
+	     a procedure linkage table, and we can just do a PCREL
+	     reloc instead.  */
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+
+      return TRUE;
+    }
+  else
+    h->plt.offset = (bfd_vma) -1;
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->is_weakalias)
+    {
+      struct elf_link_hash_entry *def = weakdef (h);
+      BFD_ASSERT (def->root.type == bfd_link_hash_defined);
+      h->root.u.def.section = def->root.u.def.section;
+      h->root.u.def.value = def->root.u.def.value;
+      return TRUE;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (bfd_link_pic (info))
+    return TRUE;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (!h->non_got_ref)
+    return TRUE;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  /* If we don't find any dynamic relocs in read-only sections, then
+     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
+  if (!readonly_dynrelocs (h))
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  /* We must generate a R_NCPU32K_COPY reloc to tell the dynamic linker
+     to copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
+     .rela.bss section we are going to use.  */
+  if ((h->root.u.def.section->flags & SEC_READONLY) != 0)
+    {
+      s = htab->root.sdynrelro;
+      srel = htab->root.sreldynrelro;
+    }
+  else
+    {
+      s = htab->root.sdynbss;
+      srel = htab->root.srelbss;
+    }
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
+    {
+      srel->size += sizeof (Elf32_External_Rela);
+      h->needs_copy = 1;
+    }
+
+  return _bfd_elf_adjust_dynamic_copy (info, h, s);
+}
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   dynamic relocs.  */
+
+static bfd_boolean
+allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
+{
+  struct bfd_link_info *info;
+  struct elf_ncpu32k_link_hash_table *htab;
+  struct elf_ncpu32k_link_hash_entry *eh;
+  struct elf_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  info = (struct bfd_link_info *) inf;
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  eh = (struct elf_ncpu32k_link_hash_entry *) h;
+
+  if (htab->root.dynamic_sections_created
+      && h->plt.refcount > 0)
+    {
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h))
+	{
+	  asection *s = htab->root.splt;
+
+	  /* If this is the first .plt entry, make room for the special
+	     first entry.  */
+	  if (s->size == 0)
+	    s->size = PLT_ENTRY_SIZE;
+
+	  h->plt.offset = s->size;
+
+	  /* If this symbol is not defined in a regular file, and we are
+	     not generating a shared library, then set the symbol to this
+	     location in the .plt.  This is required to make function
+	     pointers compare as equal between the normal executable and
+	     the shared library.  */
+	  if (! bfd_link_pic (info)
+	      && !h->def_regular)
+	    {
+	      h->root.u.def.section = s;
+	      h->root.u.def.value = h->plt.offset;
+	    }
+
+	  /* Make room for this entry.  */
+	  s->size += PLT_ENTRY_SIZE;
+
+	  /* We also need to make an entry in the .got.plt section, which
+	     will be placed in the .got section by the linker script.  */
+	  htab->root.sgotplt->size += 4;
+
+	  /* We also need to make an entry in the .rel.plt section.  */
+	  htab->root.srelplt->size += sizeof (Elf32_External_Rela);
+	}
+      else
+	{
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+    }
+  else
+    {
+      h->plt.offset = (bfd_vma) -1;
+      h->needs_plt = 0;
+    }
+
+  if (h->got.refcount > 0)
+    {
+      asection *s;
+      bfd_boolean dyn;
+      unsigned char tls_type;
+
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      s = htab->root.sgot;
+
+      h->got.offset = s->size;
+
+      tls_type = ((struct elf_ncpu32k_link_hash_entry *) h)->tls_type;
+
+      /* TLS GD requires two GOT and two relocs.  */
+      if (tls_type == TLS_GD)
+	s->size += 8;
+      else
+	s->size += 4;
+      dyn = htab->root.dynamic_sections_created;
+      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h))
+	{
+	  if (tls_type == TLS_GD)
+	    htab->root.srelgot->size += 2 * sizeof (Elf32_External_Rela);
+	  else
+	    htab->root.srelgot->size += sizeof (Elf32_External_Rela);
+	}
+    }
+  else
+    h->got.offset = (bfd_vma) -1;
+
+  if (eh->dyn_relocs == NULL)
+    return TRUE;
+
+  /* In the shared -Bsymbolic case, discard space allocated for
+     dynamic pc-relative relocs against symbols which turn out to be
+     defined in regular objects.  For the normal shared case, discard
+     space for pc-relative relocs that have become local due to symbol
+     visibility changes.  */
+
+  if (bfd_link_pic (info))
+    {
+      if (SYMBOL_CALLS_LOCAL (info, h))
+	{
+	  struct elf_dyn_relocs **pp;
+
+	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)
+	    {
+	      p->count -= p->pc_count;
+	      p->pc_count = 0;
+	      if (p->count == 0)
+		*pp = p->next;
+	      else
+		pp = &p->next;
+	    }
+	}
+
+      /* Also discard relocs on undefined weak syms with non-default
+	 visibility.  */
+      if (eh->dyn_relocs != NULL
+	  && h->root.type == bfd_link_hash_undefweak)
+	{
+	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
+	    eh->dyn_relocs = NULL;
+
+	  /* Make sure undefined weak symbols are output as a dynamic
+	     symbol in PIEs.  */
+	  else if (h->dynindx == -1
+		   && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+	}
+    }
+  else
+    {
+      /* For the non-shared case, discard space for relocs against
+	 symbols which turn out to need copy relocs or are not
+	 dynamic.  */
+
+      if (!h->non_got_ref
+	  && ((h->def_dynamic
+	       && !h->def_regular)
+	      || (htab->root.dynamic_sections_created
+		  && (h->root.type == bfd_link_hash_undefweak
+		      || h->root.type == bfd_link_hash_undefined))))
+	{
+	  /* Make sure this symbol is output as a dynamic symbol.
+	     Undefined weak syms won't yet be marked as dynamic.  */
+	  if (h->dynindx == -1
+	      && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+
+	  /* If that succeeded, we know we'll be keeping all the
+	     relocs.  */
+	  if (h->dynindx != -1)
+	    goto keep;
+	}
+
+      eh->dyn_relocs = NULL;
+
+    keep: ;
+    }
+
+  /* Finally, allocate space.  */
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *sreloc = elf_section_data (p->sec)->sreloc;
+      sreloc->size += p->count * sizeof (Elf32_External_Rela);
+    }
+
+  return TRUE;
+}
+
+/* Set DF_TEXTREL if we find any dynamic relocs that apply to
+   read-only sections.  */
+
+static bfd_boolean
+maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)
+{
+  asection *sec;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  sec = readonly_dynrelocs (h);
+  if (sec != NULL)
+    {
+      struct bfd_link_info *info = (struct bfd_link_info *) info_p;
+
+      info->flags |= DF_TEXTREL;
+      info->callbacks->minfo
+	(_("%pB: dynamic relocation against `%pT' in read-only section `%pA'\n"),
+	 sec->owner, h->root.root.string, sec);
+
+      /* Not an error, just cut short the traversal.  */
+      return FALSE;
+    }
+  return TRUE;
+}
+
+/* Set the sizes of the dynamic sections.  */
+
+static bfd_boolean
+ncpu32k_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
+				struct bfd_link_info *info)
+{
+  struct elf_ncpu32k_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd_boolean relocs;
+  bfd *ibfd;
+
+  htab = ncpu32k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+  BFD_ASSERT (dynobj != NULL);
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (bfd_link_executable (info) && !info->nointerp)
+	{
+	  s = bfd_get_section_by_name (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
+	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
+	}
+    }
+
+  /* Set up .got offsets for local syms, and space for local dynamic
+     relocs.  */
+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link.next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_signed_vma *end_local_got;
+      bfd_size_type locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+      unsigned char *local_tls_type;
+      asection *srel;
+
+      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
+	continue;
+
+      for (s = ibfd->sections; s != NULL; s = s->next)
+	{
+	  struct elf_dyn_relocs *p;
+
+	  for (p = ((struct elf_dyn_relocs *)
+		    elf_section_data (s)->local_dynrel);
+	       p != NULL;
+	       p = p->next)
+	    {
+	      if (! bfd_is_abs_section (p->sec)
+		  && bfd_is_abs_section (p->sec->output_section))
+		{
+		  /* Input section has been discarded, either because
+		     it is a copy of a linkonce section or due to
+		     linker script /DISCARD/, so we'll be discarding
+		     the relocs too.  */
+		}
+	      else if (p->count != 0)
+		{
+		  srel = elf_section_data (p->sec)->sreloc;
+		  srel->size += p->count * sizeof (Elf32_External_Rela);
+		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
+		    info->flags |= DF_TEXTREL;
+		}
+	    }
+	}
+
+      local_got = elf_local_got_refcounts (ibfd);
+      if (!local_got)
+	continue;
+
+      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
+      locsymcount = symtab_hdr->sh_info;
+      end_local_got = local_got + locsymcount;
+      s = htab->root.sgot;
+      srel = htab->root.srelgot;
+      local_tls_type = (unsigned char *) elf_ncpu32k_local_tls_type (ibfd);
+      for (; local_got < end_local_got; ++local_got)
+	{
+	  if (*local_got > 0)
+	    {
+	      *local_got = s->size;
+
+	      /* TLS GD requires two GOT and two relocs.  */
+	      if (local_tls_type != NULL && *local_tls_type == TLS_GD)
+		s->size += 8;
+	      else
+		s->size += 4;
+	      if (bfd_link_pic (info))
+		{
+		  if (local_tls_type != NULL && *local_tls_type == TLS_GD)
+		    srel->size += 2 * sizeof (Elf32_External_Rela);
+		  else
+		    srel->size += sizeof (Elf32_External_Rela);
+		}
+	    }
+	  else
+
+	    *local_got = (bfd_vma) -1;
+
+	  if (local_tls_type)
+	    ++local_tls_type;
+	}
+    }
+
+  /* Allocate global sym .plt and .got entries, and space for global
+     sym dynamic relocs.  */
+  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);
+
+  /* We now have determined the sizes of the various dynamic sections.
+     Allocate memory for them.  */
+  relocs = FALSE;
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      if (s == htab->root.splt
+	  || s == htab->root.sgot
+	  || s == htab->root.sgotplt
+	  || s == htab->root.sdynbss
+	  || s == htab->root.sdynrelro)
+	{
+	  /* Strip this section if we don't need it; see the
+	     comment below.  */
+	}
+      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
+	{
+	  if (s->size != 0 && s != htab->root.srelplt)
+	    relocs = TRUE;
+
+	  /* We use the reloc_count field as a counter if we need
+	     to copy relocs into the output file.  */
+	  s->reloc_count = 0;
+	}
+      else
+	/* It's not one of our sections, so don't allocate space.  */
+	continue;
+
+      if (s->size == 0)
+	{
+	  /* If we don't need this section, strip it from the
+	     output file.  This is mostly to handle .rela.bss and
+	     .rela.plt.  We must create both sections in
+	     create_dynamic_sections, because they must be created
+	     before the linker maps input sections to output
+	     sections.  The linker does that before
+	     adjust_dynamic_symbol is called, and it is that
+	     function which decides whether anything needs to go
+	     into these sections.  */
+	  s->flags |= SEC_EXCLUDE;
+	  continue;
+	}
+
+      if ((s->flags & SEC_HAS_CONTENTS) == 0)
+	continue;
+
+      /* Allocate memory for the section contents.  We use bfd_zalloc
+	 here in case unused entries are not reclaimed before the
+	 section's contents are written out.  This should not happen,
+	 but this way if it does, we get a R_NCPU32K_NONE reloc instead
+	 of garbage.  */
+      s->contents = bfd_zalloc (dynobj, s->size);
+
+      if (s->contents == NULL)
+	return FALSE;
+    }
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in ncpu32k_elf_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) \
+  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
+
+     if (bfd_link_executable (info))
+       {
+	 if (! add_dynamic_entry (DT_DEBUG, 0))
+	   return FALSE;
+       }
+
+     if (htab->root.splt->size != 0)
+       {
+	 if (! add_dynamic_entry (DT_PLTGOT, 0)
+	     || ! add_dynamic_entry (DT_PLTRELSZ, 0)
+	     || ! add_dynamic_entry (DT_PLTREL, DT_RELA)
+	     || ! add_dynamic_entry (DT_JMPREL, 0))
+	   return FALSE;
+	}
+
+     if (relocs)
+       {
+	 if (! add_dynamic_entry (DT_RELA, 0)
+	     || ! add_dynamic_entry (DT_RELASZ, 0)
+	     || ! add_dynamic_entry (DT_RELAENT,
+				     sizeof (Elf32_External_Rela)))
+	   return FALSE;
+
+	 /* If any dynamic relocs apply to a read-only section,
+	    then we need a DT_TEXTREL entry.  */
+	 if ((info->flags & DF_TEXTREL) == 0)
+	   elf_link_hash_traverse (&htab->root, maybe_set_textrel, info);
+
+	 if ((info->flags & DF_TEXTREL) != 0)
+	   {
+	     if (! add_dynamic_entry (DT_TEXTREL, 0))
+	       return FALSE;
+	   }
+       }
+    }
+
+#undef add_dynamic_entry
+  return TRUE;
+}
+
+/* Copy the extra info we tack onto an elf_link_hash_entry.  */
+
+static void
+ncpu32k_elf_copy_indirect_symbol (struct bfd_link_info *info,
+			       struct elf_link_hash_entry *dir,
+			       struct elf_link_hash_entry *ind)
+{
+  struct elf_ncpu32k_link_hash_entry * edir;
+  struct elf_ncpu32k_link_hash_entry * eind;
+
+  edir = (struct elf_ncpu32k_link_hash_entry *) dir;
+  eind = (struct elf_ncpu32k_link_hash_entry *) ind;
+
+  if (eind->dyn_relocs != NULL)
+    {
+      if (edir->dyn_relocs != NULL)
+	{
+	  struct elf_dyn_relocs **pp;
+	  struct elf_dyn_relocs *p;
+
+	  /* Add reloc counts against the indirect sym to the direct sym
+	     list.  Merge any entries against the same section.  */
+	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)
+	    {
+	      struct elf_dyn_relocs *q;
+
+	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
+		if (q->sec == p->sec)
+		  {
+		    q->pc_count += p->pc_count;
+		    q->count += p->count;
+		    *pp = p->next;
+		    break;
+		  }
+	      if (q == NULL)
+		pp = &p->next;
+	    }
+	  *pp = edir->dyn_relocs;
+	}
+
+      edir->dyn_relocs = eind->dyn_relocs;
+      eind->dyn_relocs = NULL;
+    }
+
+  if (ind->root.type == bfd_link_hash_indirect)
+    {
+      if (dir->got.refcount <= 0)
+	{
+	  edir->tls_type = eind->tls_type;
+	  eind->tls_type = TLS_UNKNOWN;
+	}
+    }
+
+  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+}
+
+/* Set the right machine number.  */
+
+static bfd_boolean
+ncpu32k_elf_object_p (bfd *abfd)
+{
+  unsigned long mach = bfd_mach_ncpu32k;
+  return bfd_default_set_arch_mach (abfd, bfd_arch_ncpu32k, mach);
+}
+
+/* Store the machine number in the flags field.  */
+
+static void
+ncpu32k_elf_final_write_processing (bfd *abfd,
+				 bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  switch (bfd_get_mach (abfd))
+    {
+    default:
+    case bfd_mach_ncpu32k:
+      break;
+    }
+}
+
+static bfd_boolean
+ncpu32k_elf_set_private_flags (bfd *abfd, flagword flags)
+{
+  BFD_ASSERT (!elf_flags_init (abfd)
+	      || elf_elfheader (abfd)->e_flags == flags);
+
+  elf_elfheader (abfd)->e_flags = flags;
+  elf_flags_init (abfd) = TRUE;
+  return TRUE;
+}
+
+/* Make sure all input files are consistent with respect to
+   EF_NCPU32K_NODELAY flag setting.  */
+
+static bfd_boolean
+elf32_ncpu32k_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)
+{
+  bfd *obfd = info->output_bfd;
+  flagword out_flags;
+  flagword in_flags;
+
+  in_flags  = elf_elfheader (ibfd)->e_flags;
+  out_flags = elf_elfheader (obfd)->e_flags;
+
+  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return TRUE;
+
+  if (!elf_flags_init (obfd))
+    {
+      elf_flags_init (obfd) = TRUE;
+      elf_elfheader (obfd)->e_flags = in_flags;
+
+      return TRUE;
+    }
+
+  if (in_flags == out_flags)
+    return TRUE;
+  /* check other flags here */
+
+  return TRUE;
+
+}
+
+/* Implement elf_backend_grok_prstatus:
+   Support for core dump NOTE sections.  */
+static bfd_boolean
+ncpu32k_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
+{
+  int offset;
+  size_t size;
+
+  switch (note->descsz)
+    {
+    default:
+      return FALSE;
+
+    case 212: //fixme!	      /* Linux/nano-cpu32k */
+      /* pr_cursig */
+      elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);
+
+      /* pr_pid */
+      elf_tdata (abfd)->core->pid = bfd_get_32 (abfd, note->descdata + 24);
+
+      /* pr_reg */
+      offset = 72;
+      size = 132;
+
+      break;
+    }
+
+  /* Make a ".reg/999" section.  */
+  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
+					  size, note->descpos + offset);
+}
+
+/* Implement elf_backend_grok_psinfo.  */
+static bfd_boolean
+ncpu32k_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
+{
+  switch (note->descsz)
+    {
+    default:
+      return FALSE;
+
+    case 128: //fixme!	      /* Linux/nano-cpu32k elf_prpsinfo */
+      elf_tdata (abfd)->core->program
+	= _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
+      elf_tdata (abfd)->core->command
+	= _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
+    }
+
+  return TRUE;
+}
+
+
+#define ELF_ARCH			bfd_arch_ncpu32k
+#define ELF_MACHINE_CODE		EM_NCPU32K
+#define ELF_TARGET_ID			NCPU32K_ELF_DATA
+#define ELF_MAXPAGESIZE			0x2000
+
+#define TARGET_LITTLE_SYM		ncpu32k_elf32_vec
+#define TARGET_LITTLE_NAME		"elf32-ncpu32k"
+
+#define elf_info_to_howto_rel		NULL
+#define elf_info_to_howto		ncpu32k_info_to_howto_rela
+#define elf_backend_relocate_section	ncpu32k_elf_relocate_section
+#define elf_backend_gc_mark_hook	ncpu32k_elf_gc_mark_hook
+#define elf_backend_check_relocs	ncpu32k_elf_check_relocs
+#define elf_backend_reloc_type_class	ncpu32k_elf_reloc_type_class
+#define elf_backend_can_gc_sections	1
+#define elf_backend_rela_normal		1
+
+#define bfd_elf32_mkobject		     elf_ncpu32k_mkobject
+
+#define bfd_elf32_bfd_merge_private_bfd_data elf32_ncpu32k_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags ncpu32k_elf_set_private_flags
+#define bfd_elf32_bfd_reloc_type_lookup ncpu32k_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup ncpu32k_reloc_name_lookup
+
+#define elf_backend_object_p		    ncpu32k_elf_object_p
+#define elf_backend_final_write_processing  ncpu32k_elf_final_write_processing
+#define elf_backend_can_refcount		1
+
+#define elf_backend_plt_readonly		1
+#define elf_backend_want_got_plt		1
+#define elf_backend_want_plt_sym		0
+#define elf_backend_got_header_size		12
+#define elf_backend_dtrel_excludes_plt		1
+#define elf_backend_want_dynrelro		1
+
+#define bfd_elf32_bfd_link_hash_table_create	ncpu32k_elf_link_hash_table_create
+#define elf_backend_copy_indirect_symbol	ncpu32k_elf_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections	_bfd_elf_create_dynamic_sections
+#define elf_backend_finish_dynamic_sections	ncpu32k_elf_finish_dynamic_sections
+#define elf_backend_size_dynamic_sections	ncpu32k_elf_size_dynamic_sections
+#define elf_backend_adjust_dynamic_symbol	ncpu32k_elf_adjust_dynamic_symbol
+#define elf_backend_finish_dynamic_symbol	ncpu32k_elf_finish_dynamic_symbol
+
+#define elf_backend_grok_prstatus	  ncpu32k_grok_prstatus
+#define elf_backend_grok_psinfo		  ncpu32k_grok_psinfo
+
+#include "elf32-target.h"
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/elf-bfd.h binutils-ncpu32k-2.32/bfd/elf-bfd.h
--- binutils-2.32/bfd/elf-bfd.h	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/elf-bfd.h	2019-07-31 11:42:15.279908213 +0800
@@ -503,6 +503,7 @@
   MICROBLAZE_ELF_DATA,
   MIPS_ELF_DATA,
   MN10300_ELF_DATA,
+  NCPU32K_ELF_DATA,
   NDS32_ELF_DATA,
   NIOS2_ELF_DATA,
   OR1K_ELF_DATA,
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/libbfd.h binutils-ncpu32k-2.32/bfd/libbfd.h
--- binutils-2.32/bfd/libbfd.h	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/libbfd.h	2019-08-12 22:10:20.121679439 +0800
@@ -2801,6 +2801,12 @@
   "BFD_RELOC_NIOS2_R2_L5I4X1",
   "BFD_RELOC_NIOS2_R2_T1X1I6",
   "BFD_RELOC_NIOS2_R2_T1X1I6_2",
+  "BFD_RELOC_NCPU32K_REL_16",
+  "BFD_RELOC_NCPU32K_REL_21",
+  "BFD_RELOC_NCPU32K_GLOB_DAT",
+  "BFD_RELOC_NCPU32K_JMP_SLOT",
+  "BFD_RELOC_NCPU32K_RELATIVE",
+  "BFD_RELOC_NCPU32K_COPY",
   "BFD_RELOC_PRU_U16",
   "BFD_RELOC_PRU_U16_PMEMIMM",
   "BFD_RELOC_PRU_LDI32",
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/Makefile.am binutils-ncpu32k-2.32/bfd/Makefile.am
--- binutils-2.32/bfd/Makefile.am	2019-01-20 00:01:32.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/Makefile.am	2019-08-12 16:25:58.353167120 +0800
@@ -137,6 +137,7 @@
 	cpu-moxie.lo \
 	cpu-msp430.lo \
 	cpu-mt.lo \
+	cpu-ncpu32k.lo \
 	cpu-nds32.lo \
 	cpu-nfp.lo \
 	cpu-nios2.lo \
@@ -223,6 +224,7 @@
 	cpu-moxie.c \
 	cpu-msp430.c \
 	cpu-mt.c \
+	cpu-ncpu32k.c \
 	cpu-nds32.c \
 	cpu-nfp.c \
 	cpu-ns32k.c \
@@ -335,6 +337,7 @@
 	elf32-moxie.lo \
 	elf32-msp430.lo \
 	elf32-mt.lo \
+	elf32-ncpu32k.lo \
 	elf32-nds32.lo \
 	elf32-nios2.lo \
 	elf32-or1k.lo \
@@ -472,6 +475,7 @@
 	elf32-moxie.c \
 	elf32-msp430.c \
 	elf32-mt.c \
+	elf32-ncpu32k.c \
 	elf32-nds32.c \
 	elf32-nios2.c \
 	elf32-or1k.c \
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/Makefile.in binutils-ncpu32k-2.32/bfd/Makefile.in
--- binutils-2.32/bfd/Makefile.in	2019-02-02 23:47:56.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/Makefile.in	2019-08-12 16:27:08.929168870 +0800
@@ -560,6 +560,7 @@
 	cpu-moxie.lo \
 	cpu-msp430.lo \
 	cpu-mt.lo \
+	cpu-ncpu32k.lo \
 	cpu-nds32.lo \
 	cpu-nfp.lo \
 	cpu-nios2.lo \
@@ -646,6 +647,7 @@
 	cpu-moxie.c \
 	cpu-msp430.c \
 	cpu-mt.c \
+	cpu-ncpu32k.c \
 	cpu-nds32.c \
 	cpu-nfp.c \
 	cpu-ns32k.c \
@@ -759,6 +761,7 @@
 	elf32-moxie.lo \
 	elf32-msp430.lo \
 	elf32-mt.lo \
+	elf32-ncpu32k.lo \
 	elf32-nds32.lo \
 	elf32-nios2.lo \
 	elf32-or1k.lo \
@@ -896,6 +899,7 @@
 	elf32-moxie.c \
 	elf32-msp430.c \
 	elf32-mt.c \
+	elf32-ncpu32k.c \
 	elf32-nds32.c \
 	elf32-nios2.c \
 	elf32-or1k.c \
@@ -1362,6 +1366,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-moxie.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-msp430.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-mt.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-ncpu32k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-nds32.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-nfp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-nios2.Plo@am__quote@
@@ -1454,6 +1459,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-moxie.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-msp430.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-mt.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-ncpu32k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-nds32.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-nios2.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-or1k.Plo@am__quote@
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/reloc.c binutils-ncpu32k-2.32/bfd/reloc.c
--- binutils-2.32/bfd/reloc.c	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/reloc.c	2019-08-12 22:09:42.409678504 +0800
@@ -6463,6 +6463,21 @@
   Relocations used by the Altera Nios II core.
 
 ENUM
+  BFD_RELOC_NCPU32K_REL_16
+ENUMX
+  BFD_RELOC_NCPU32K_REL_21
+ENUMX
+  BFD_RELOC_NCPU32K_GLOB_DAT
+ENUMX
+  BFD_RELOC_NCPU32K_JMP_SLOT
+ENUMX
+  BFD_RELOC_NCPU32K_RELATIVE
+ENUMX
+  BFD_RELOC_NCPU32K_COPY
+ENUMDOC
+  nano-cpu32k Relocations.
+
+ENUM
   BFD_RELOC_PRU_U16
 ENUMDOC
   PRU LDI 16-bit unsigned data-memory relocation.
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/bfd/targets.c binutils-ncpu32k-2.32/bfd/targets.c
--- binutils-2.32/bfd/targets.c	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/bfd/targets.c	2019-08-12 15:34:49.533091027 +0800
@@ -738,6 +738,7 @@
 extern const bfd_target msp430_elf32_vec;
 extern const bfd_target msp430_elf32_ti_vec;
 extern const bfd_target mt_elf32_vec;
+extern const bfd_target ncpu32k_elf32_vec;
 extern const bfd_target nds32_elf32_be_vec;
 extern const bfd_target nds32_elf32_le_vec;
 extern const bfd_target nds32_elf32_linux_be_vec;
@@ -1117,6 +1118,8 @@
 
 	&mt_elf32_vec,
 
+	&ncpu32k_elf32_vec,
+
 	&nds32_elf32_be_vec,
 	&nds32_elf32_le_vec,
 	&nds32_elf32_linux_be_vec,
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/binutils/readelf.c binutils-ncpu32k-2.32/binutils/readelf.c
--- binutils-2.32/binutils/readelf.c	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/binutils/readelf.c	2019-08-12 15:45:38.381107115 +0800
@@ -132,6 +132,7 @@
 #include "elf/moxie.h"
 #include "elf/mt.h"
 #include "elf/msp430.h"
+#include "elf/ncpu32k.h"
 #include "elf/nds32.h"
 #include "elf/nfp.h"
 #include "elf/nios2.h"
@@ -828,6 +829,7 @@
     case EM_MSP430:
     case EM_MSP430_OLD:
     case EM_MT:
+    case EM_NCPU32K:
     case EM_NDS32:
     case EM_NIOS32:
     case EM_OR1K:
@@ -1381,6 +1383,10 @@
 	  rtype = elf_msp430_reloc_type (type);
 	  break;
 
+	case EM_NCPU32K:
+	  rtype = elf_ncpu32k_reloc_type (type);
+	  break;
+
 	case EM_NDS32:
 	  rtype = elf_nds32_reloc_type (type);
 	  break;
@@ -2508,6 +2514,7 @@
     case EM_CYGNUS_FRV:		return "Fujitsu FR-V";
     case EM_S12Z:               return "Freescale S12Z";
     case EM_CSKY:		return "C-SKY";
+    case EM_NCPU32K:		return "nano-cpu32k";
 
     default:
       snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
@@ -3461,6 +3468,9 @@
 	    }
 	  break;
 
+        case EM_NCPU32K:
+          break;
+
 	case EM_NDS32:
 	  decode_NDS32_machine_flags (e_flags, buf, sizeof buf);
 	  break;
@@ -12459,6 +12469,8 @@
       return reloc_type == 1; /* R_MSP430_32 or R_MSP320_ABS32.  */
     case EM_MT:
       return reloc_type == 2; /* R_MT_32.  */
+    case EM_NCPU32K:
+      return reloc_type == 1; /* R_NCPU32K_32.  */
     case EM_NDS32:
       return reloc_type == 20; /* R_NDS32_RELA.  */
     case EM_ALTERA_NIOS2:
@@ -12577,6 +12589,8 @@
       return reloc_type == 36; /* R_AVR_32_PCREL.  */
     case EM_MICROBLAZE:
       return reloc_type == 2;  /* R_MICROBLAZE_32_PCREL.  */
+    case EM_NCPU32K:
+      return reloc_type == 9; /* R_NCPU32K_32_PCREL.  */
     case EM_OR1K:
       return reloc_type == 9; /* R_OR1K_32_PCREL.  */
     case EM_PARISC:
@@ -12767,6 +12781,8 @@
       return reloc_type == 19; /* R_NDS32_RELA.  */
     case EM_ALTERA_NIOS2:
       return reloc_type == 13; /* R_NIOS2_BFD_RELOC_16.  */
+    case EM_NCPU32K:
+      return reloc_type == 2; /* R_NCPU32K_16.  */
     case EM_NIOS32:
       return reloc_type == 9; /* R_NIOS_16.  */
     case EM_OR1K:
@@ -12989,6 +13005,7 @@
     case EM_MIPS:    /* R_MIPS_NONE.  */
     case EM_MN10300: /* R_MN10300_NONE.  */
     case EM_MOXIE:   /* R_MOXIE_NONE.  */
+    case EM_NCPU32K: /* R_NCPU32K_NONE. */
     case EM_NIOS32:  /* R_NIOS_NONE.  */
     case EM_OR1K:    /* R_OR1K_NONE. */
     case EM_PARISC:  /* R_PARISC_NONE.  */
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/config.guess binutils-ncpu32k-2.32/config.guess
--- binutils-2.32/config.guess	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/config.guess	2019-07-31 11:34:32.199896731 +0800
@@ -419,6 +419,9 @@
 	fi
 	echo "$SUN_ARCH"-pc-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
 	exit ;;
+    nano*cpu*32k*:Linux:*:*)
+	echo ncpu32k-unknown-linux-"$LIBC"
+	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/config.sub binutils-ncpu32k-2.32/config.sub
--- binutils-2.32/config.sub	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/config.sub	2019-08-12 15:36:41.857093812 +0800
@@ -1215,6 +1215,7 @@
 			| moxie \
 			| mt \
 			| msp430 \
+			| ncpu32* \
 			| nds32 | nds32le | nds32be \
 			| nfp \
 			| nios | nios2 | nios2eb | nios2el \
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/cpu/ncpu32k.cpu binutils-ncpu32k-2.32/cpu/ncpu32k.cpu
--- binutils-2.32/cpu/ncpu32k.cpu	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/cpu/ncpu32k.cpu	2019-08-12 18:59:31.317395560 +0800
@@ -0,0 +1,1075 @@
+; nano-cpu32k architecture -*- Scheme -*-
+; Copyright (C) 2019 cassuto <diyer175@hotmail.com>
+;***************************************************************************
+;
+; This program is free software; you can redistribute it and/or modify
+; it under the terms of the GNU General Public License as published by
+; the Free Software Foundation; either version 3 of the License, or
+; (at your option) any later version.
+;
+; This program is distributed in the hope that it will be useful,
+; but WITHOUT ANY WARRANTY; without even the implied warranty of
+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+; GNU General Public License for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with this program; if not, see <http://www.gnu.org/licenses/>
+
+(include "simplify.inc")
+
+(define-arch
+  (name ncpu32k)
+  (comment "nano-CPU32k")
+  (default-alignment aligned)
+  (insn-lsb0? #t)
+  (machs ncpu32k-mach)
+  (isas ncpu32k-isa)
+)
+
+; Instruction set parameters.
+(define-isa
+  ; Name of the ISA.
+  (name ncpu32k-isa)
+  ; Minimum insturction length. (Variable Length 16/32 bits)
+  (base-insn-bitsize 16)
+  )
+
+(define-cpu
+  (name ncpu32k)
+  (comment "nano-CPU 32k family")
+  (insn-endian little)
+  (data-endian little)
+  (word-bitsize 32)
+  (file-transform "")
+  )
+
+(define-mach
+  (name ncpu32k-mach)
+  (comment "nano-CPU 32k machine")
+  (cpu ncpu32k)
+  (bfd-name "ncpu32k")
+  )
+
+(define-model
+  (name ncpu32000) (comment "nano-CPU 32000 model")
+  (attrs)
+  (mach ncpu32k-mach)
+  (unit u-exec "Execution Unit" () 1 1 () () () ())
+  )
+
+
+;***************************************************************************
+; Registers
+;***************************************************************************
+
+(define-hardware
+  (name h-pc)
+  (comment "program counter")
+  (attrs PC)
+  (type pc UWI)
+  (get () (raw-reg h-pc))
+  (set (newval) (sequence ()
+                 (set (reg h-sys-ppc) (raw-reg h-pc))
+                 (set (raw-reg h-pc) newval)
+                ))
+  )
+
+
+(define-pmacro REG-INDICES
+  ((r0 0)
+   (r1 1)
+   (r2 2)
+   (r3 3)
+   (r4 4)
+   (r5 5)
+   (r6 6)
+   (r7 7)
+   (r8 8)
+   (r9 9)
+   (r10 10)
+   (r11 11)
+   (r12 12)
+   (r13 13)
+   (r14 14)
+   (r15 15)
+   (r16 16)
+   (r17 17)
+   (r18 18)
+   (r19 19)
+   (r20 20)
+   (r21 21)
+   (r22 22)
+   (r23 23)
+   (r24 24)
+   (r25 25)
+   (r26 26)
+   (r27 27)
+   (r28 28)
+   (r29 29)
+   (r30 30)
+   (r31 31)
+   ; aliases
+   (nil 0)
+   (lnk 1)
+   (sp 2)
+   (fp 3)
+   (v0 4)
+   (v1 5)
+   (v2 6)
+   (v3 7)
+   (v4 8)
+   (v5 9)
+   (rv 10)
+   (rvh 11))
+  )
+
+;
+; FRS
+;
+(define-hardware
+  (name h-frs)
+  (comment "floating point registers (single, virtual)")
+  (attrs VIRTUAL)
+  (type register SF (32))
+  (indices keyword "" REG-INDICES)
+  (get (index) (subword SF (trunc SI (reg h-gpr index)) 0))
+  (set (index newval) (set UWI (reg h-gpr index) (zext UWI (subword SI newval 0))))
+  )
+
+;
+; FRD
+;
+(define-hardware
+  (name h-frd) (comment "floating point registers (double, virtual)")
+  (attrs VIRTUAL)
+  (type register DF (32))
+  (indices keyword "" REG-INDICES)
+  (get (index) (subword DF (trunc DI (reg h-gpr index)) 0))
+  (set (index newval) (set UDI (reg h-gpr index) (zext UDI (subword DI newval 0))))
+  )
+
+;
+; SMR
+;
+(define-hardware
+  (name h-smr) (comment "CPU status management registers")
+  (attrs VIRTUAL)
+  (type register UWI (#x20000))
+  (get (index) (c-call UWI "@cpu@_h_smr_get_raw" index))
+  (set (index newval) (c-call VOID "@cpu@_h_smr_set_raw" index newval))
+)
+
+;
+;todo! smr address
+;
+(define-pmacro smr-shift 11)
+(define-pmacro (smr-address smr-entry smr-index)
+  (or (sll UWI (enum UWI (.sym "SMR-ENTRY-" smr-entry)) smr-shift)
+      (enum UWI (.sym "SMR-INDEX-" smr-entry "-" smr-index))))
+
+;
+; GPR
+;
+(define-hardware
+  (name h-gpr) (comment "general registers")
+  (attrs)
+  (type register UWI (32))
+  (indices keyword "" REG-INDICES)
+  (get (index) (reg UWI h-smr (add index (smr-address CCFG GPR0))))
+  (set (index newval) (set UWI (reg UWI h-smr (add index (smr-address CCFG GPR0))) newval))
+  )
+  
+
+;***************************************************************************
+; Exceptions
+;***************************************************************************
+
+(define-normal-enum
+  except-number
+  "Exception numbers"
+  ()
+  EXCEPT-
+  (("ERST"          #x01)
+   ("EBUS"          #x02)
+   ("EINSN"         #x03)
+   ("EEXC"          #x04)
+   ("EIPF"          #x05)
+   ("EDPF"          #x06)
+   ("EITLB"         #x07)
+   ("EDTLB"         #x08)
+   ("EIRQ"          #x09)
+   ("EOVERFLOW"     #x0a)
+   ("EFPU"          #x0b)
+   ("EDALIGN"       #x0c)
+   )
+  )
+
+(define-pmacro (raise-exception exnum)
+  (c-call VOID "@cpu@_exception" pc exnum))
+
+
+;***************************************************************************
+; SMR fields
+;***************************************************************************
+
+(define-normal-enum
+  smr-groups
+  "CPU status management register groups"
+  ()
+  SMR-ENTRY-
+  (("CR"        #x0)
+   ("CSR"       #x1)
+   )
+  )
+
+(define-pmacro (smr-reg-info)
+  (.splice
+   (CR CPUID    #x000 "CPU Identifier Information")
+   (CR EX       #x001 "Exception control")
+   (CR EB       #x002 "Exception Base address")
+   (CR EPC      #x003 "Exception PC")
+   (CR ECSR     #x004 "Exception saved CSR")
+   (CR DPR      #x005 "Device Present")
+   (CR ICC      #x006 "I-Cache control")
+   (CR DCC      #x007 "D-Cache control")
+   (CR IMMUC    #x008 "I-MMU control")
+   (CR DMMUC    #x009 "D-MMU control")
+   (CR TRMUC    #x00a "Timer Unit control")
+   (CR PICUC    #x00b "PIC Unit control")
+   (CR DBGUC    #x00c "Debug Unit control")
+   (CR FPUC     #x00d "Floating Processor Unit control")
+   (CR PMUC     #x00e "Power Management Unit control")
+   (CR PMCUC    #x00f "Performance Counters Unit control")
+   
+   (.unsplice
+    (.map (.pmacro (n) (.splice CR (.sym "GPR" n) (.add n #x400) (.str "General purpose register " n)))
+          (.iota #x200)))
+          
+   (CSR PSR     #x000 "Program Status Register")
+   (CSR MSR     #x001 "Mode Status Register")
+   (CSR FSR     #x002 "Float Status Register")
+   )
+  )
+
+(define-normal-enum
+  smr-reg-indices
+  "CPU status management register indicies"
+  ()
+  SMR-INDEX-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (entry index n comment)
+                                  ((.sym entry "-" index) n))
+                         args)
+                 )
+        (smr-reg-info)
+        )
+  )
+
+(define-pmacro (define-h-smr-reg smr-entry smr-index n smr-comment)
+  (define-hardware
+    (name (.sym "h-" (.downcase smr-entry) "-" (.downcase smr-index)))
+    (comment smr-comment)
+    (attrs VIRTUAL)
+    (type register UWI)
+    (get ()       (reg UWI h-smr (smr-address smr-entry smr-index)))
+    (set (newval) (set (reg UWI h-smr (smr-address smr-entry smr-index)) newval))
+    )
+  )
+(.splice begin (.unsplice (.map (.pmacro (args) (.apply define-h-smr-reg args)) (smr-reg-info))))
+
+(define-pmacro (smr-field-info)
+   ;
+   ; <entry> <index> <field> <field-msb> <field-lsb> <comment>
+   ;  |        |         |        |           |          |
+   ;  |   ------  --------        |           |          |
+   ;  |   |       |     -----------           |          |
+   ;  |   |       |     |  --------------------          |
+   ;  |   |       |     |  |        ----------------------
+   ;  |   |       |     |  |        |
+  (( CR CPUID    VER    8  0  "Version Data")
+   ( CR CPUID    REV    14 9  "Revision Data")
+   ( CR CPUID    PXB32  15 15 "OPNEPXb-32bit Instructions Support")
+   ( CR CPUID    PXB64  16 16 "OPNEPXb-64bit Instructions Support")
+   ( CR CPUID    FPX32  17 17 "FPX-32bit Instructions Support")
+   ( CR CPUID    FPX64  18 18 "FPX-64bit Instructions Support")
+   ( CR CPUID    VX64   19 19 "VX-64bit Instructions Support")
+   
+   ( CR EX       IE     0  0  "Interrupt exception Enable")
+   ( CR EX       OE     1  1  "ALU Overflow exception Enable")
+   ( CR EX       EF     2  2  "Exception flag")
+   
+   ( CR DPR      ICP    0  0  "I-Cache present")
+   ( CR DPR      DCP    1  1  "D-Cache present")
+   ( CR DPR      IMMUP  2  2  "I-MMU present")
+   ( CR DPR      DMMUP  3  3  "D-MMU present")
+   ( CR DPR      TMRUP  4  4  "Timer Unit present")
+   ( CR DPR      PICU   5  5  "PIC Unit present")
+   ( CR DPR      DGBUP  6  6  "Debugging Unit present")
+   ( CR DPR      FPUP   7  7  "Float Point Unit present")
+   ( CR DPR      PMUP   8  8  "Power Management Unit present")
+   ( CR DPR      PMCUP  9  9  "Performance Counter Unit present")
+   
+   ( CR FPUC     RM     1  0  "Rounding Mode")
+   
+   (MSR PSR      CF     0  0  "Condition Flag")
+   (MSR PSR      CY     1  1  "Carry (Unsigned overflow)")
+   (MSR PSR      OV     2  2  "Overflow")
+   
+   (MSR SR       RM     0  0  "In Root mode")
+   )
+  )
+
+(define-normal-enum
+  smr-field-msbs
+  "SMR field msb positions"
+  ()
+  SMR-FIELD-MSB-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (entry index field msb lsb comment)
+                                  ((.sym entry "-" index "-" field) msb)
+                                  )
+                         args
+                         )
+                 )
+        (smr-field-info)
+        )
+  )
+
+(define-normal-enum
+  smr-field-lsbs
+  "SMR field lsb positions"
+  ()
+  SMR-FIELD-SIZE-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (entry index field msb lsb comment)
+                                  ((.sym entry "-" index "-" field) lsb)
+                                  )
+                         args
+                         )
+                 )
+        (smr-field-info)
+        )
+  )
+
+(define-normal-enum
+  smr-field-masks
+  "SMR field masks"
+  ()
+  SMR-FIELD-MASK-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (entry index field msb lsb comment)
+                                  (.splice (.str entry "-" index "-" field) (.sll (.inv (.sll (.inv 0) (.add (.sub msb lsb) 1))) lsb))
+                                  )
+                         args
+                         )
+                 )
+        (smr-field-info)
+        )
+  )
+
+
+(define-pmacro (define-h-smr-field smr-entry smr-index smr-field smr-field-msb smr-field-lsb smr-field-comment)
+  (.let ((smr-field-name (.sym "h-" (.downcase smr-entry) "-" (.downcase smr-index) "-" (.downcase smr-field)))
+         )
+        (begin
+          (define-hardware
+            (name smr-field-name)
+            (comment smr-field-comment)
+            (attrs VIRTUAL (MACH ncpu32k-mach))
+            (type register UWI)
+            (get ()      (c-call UWI  "@cpu@_h_csmr_field_get_raw" (smr-address smr-entry smr-index) smr-field-msb smr-field-lsb))
+            (set (value) (c-call VOID "@cpu@_h-csmr_field_set_raw" (smr-address smr-entry smr-index) smr-field-msb smr-field-lsb value))
+            )
+          )
+        )
+  )
+
+(.splice begin (.unsplice (.map (.pmacro (args) (.apply define-h-smr-field args)) (smr-field-info))) )
+
+
+;***************************************************************************
+
+(define-attr
+  (for insn)
+  (type boolean)
+  (name FORCED-CTI)
+  (comment "forcefully transfer control, mainly for RET instruction.")
+  )
+
+
+; Hardware for immediate operands
+(dnh h-simm16   "16-bit signed immediate"   () (immediate (INT 16)) () () ())
+(dnh h-uimm16   "16-bit unsigned immediate" ()  (immediate (UINT 16)) () () ())
+
+;***************************************************************************
+; Instruction fields.
+;***************************************************************************
+
+(dnf f-opcode   "<opcode>"    ()          5 6)
+(dnf f-rd       "<rd>"        ()          10 5)
+(dnf f-res-rd   "<res>-<rd>"  (RESERVED)  10 5)
+(dnf f-rs       "<rs>"        ()          15 5)
+(dnf f-res-rs   "<res>-<rs>"  (RESERVED)  15 5)
+
+(dnf f-imm16      "imm16"         ()      31 16)
+(dnf f-uimm16     "uimm16"        ()      31 16)
+(df  f-simm16     "simm16"        (SIGN-OPT) 31 16 INT #f #f)
+(dnf f-res-imm16  "<res>-<imm16>" (RESERVED) 31 16)
+
+; <address> PC relative, 16-bit
+(df f-rel16
+    "rel16"
+    (PCREL-ADDR)
+    31
+    16
+    INT
+    ((value pc) (sra SI (sub IAI value pc) (const 1)))
+    ((value pc) (add IAI (sll IAI value (const 1)) pc))
+    )
+
+; <address> PC relative, 21-bit
+(df f-rel21
+    "rel21"
+    (PCREL-ADDR)
+    31
+    21
+    INT
+    ((value pc) (sra SI (sub IAI value pc) (const 1)))
+    ((value pc) (add IAI (sll IAI value (const 1)) pc))
+    )
+
+;***************************************************************************
+; Enums.
+;***************************************************************************
+
+; <opcode> [5..0]
+(define-normal-insn-enum insn-opcode "<opcode> insn opcodes" ()
+  OPC_
+  f-opcode
+  (
+   ; BASE insn group
+   ("AND"               #x00)
+   ("AND.I"             #x01)
+   ("OR"                #x02)
+   ("OR.I"              #x03)
+   ("XOR"               #x04)
+   ("XOR.I"             #x05)
+   ("LSL"               #x06)
+   ("LSL.I"             #x07)
+   ("LSR"               #x08)
+   ("LSR.I"             #x09)
+   ("JMP"               #x0a)
+   ("JMP.I"             #x0b)
+   ("BEQ"               #x0c)
+   ("BNE"               #x0d)
+   ("BGT"               #x0e)
+   ("BLE"               #x0f)
+   ("LDWU"              #x10)
+   ("STW"               #x11)
+   ("BARR"              #x12)
+   ("EXC"               #x13)
+   ("RET"               #x14)
+   ("WSMR"              #x15)
+   ("RSMR"              #x16)
+   
+   ; VIRT insn group
+   ("ASR"               #x17)
+   ("ASR.I"             #x18)
+   ("ADD"               #x19)
+   ("ADD.I"             #x1a)
+   ("SUB"               #x1b)
+   ("MUL"               #x1c)
+   ("MULU"              #x1d)
+   ("DIV"               #x1e)
+   ("DIVU"              #x1f)
+   ("MOD"               #x20)
+   ("LDB"               #x21)
+   ("LDBU"              #x22)
+   ("LDH"               #x23)
+   ("LDHU"              #x24)
+   ("STB"               #x25)
+   ("STH"               #x26)
+   ("MHI"               #x27)
+   ("FADD"              #x28)
+   ("FSUB"              #x29)
+   ("FMUL"              #x2a)
+   ("FDIV"              #x2b)
+   ("FCMPEQ"            #x2c)
+   ("FCMPGT"            #x2d)
+   ("FMOV"              #x2e)
+   ("PCRP"              #x2f)
+
+   )
+)
+
+;***************************************************************************
+; Instruction operands.
+;***************************************************************************
+
+; operands for insns
+(dnop rs  "source operand"      ()  h-gpr   f-rs)
+(dnop rd  "destination operand" ()  h-gpr   f-rd)
+
+(define-operand
+  (name simm16)
+  (comment "16-bit signed immediate")
+  (attrs SIGN-OPT)
+  (type h-simm16)
+  (index f-simm16)
+  (handlers (parse "simm16"))
+  )
+
+(define-operand
+  (name uimm16)
+  (comment "16-bit unsigned immediate")
+  (attrs)
+  (type h-uimm16)
+  (index f-uimm16)
+  (handlers (parse "uimm16"))
+  )
+
+(define-operand
+  (name rel16)
+  (comment "pc-rel 16 bit address")
+  (attrs)
+  (type h-iaddr)
+  (index f-rel16)
+  (handlers (parse "rel16"))
+  )
+  
+(define-operand
+  (name rel21)
+  (comment "pc-rel 21 bit address")
+  (attrs)
+  (type h-iaddr)
+  (index f-rel21)
+  (handlers (parse "rel21"))
+  )
+  
+; operands in SMR (for semantics description only)
+(dnop msr-psr-cy "PSR carry bit"        (SEM-ONLY) h-msr-psr-cy      f-nil)
+(dnop msr-psr-ov "PSR overflow bit"     (SEM-ONLY) h-msr-psr-ov      f-nil)
+(dnop cr-ex-oe "EX overflow exception enable bit" (SEM-ONLY) h-cr-ex-oe f-nil)
+
+
+;***************************************************************************
+; Internal pseudo macros
+;***************************************************************************
+
+(define-pmacro (rop-alu-insn mnemonic)
+  (begin
+     (dni mnemonic
+          (.str mnemonic " reg/reg")
+          ()
+          (.str mnemonic " $rd,$rs")
+          (+ (.sym OPC_ (.upcase mnemonic)) rd rs)
+          (set rd (mnemonic rd rs))
+          ()
+     )
+  )
+)
+(define-pmacro (uimm-alu-insn  mnemonic binop)
+    (begin
+      (dni (.sym mnemonic ".i")
+           (.str mnemonic " reg/reg/uimm16")
+           ()
+           (.str mnemonic " $rd,$rs,$uimm16")
+           (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs uimm16)
+           (set rd (binop rs (zext UWI uimm16)))
+           ()
+     )
+    )
+  )
+(define-pmacro (simm-alu-insn  mnemonic binop)
+    (begin
+      (dni (.sym mnemonic ".i")
+          (.str mnemonic " reg/reg/simm16")
+          ()
+          (.str mnemonic " $rd,$rs,$simm16")
+          (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs simm16)
+          (set rd (binop rs (ext WI simm16)))
+          ()
+     )
+    )
+  )
+
+
+(define-pmacro (rop-alu-carry-insn mnemonic)
+  (begin
+    (dni mnemonic
+         (.str mnemonic " reg/reg")
+         ()
+         (.str mnemonic " $rd,$rs")
+         (+ (.sym OPC_ (.upcase mnemonic)) rd rs)
+         (sequence ()
+                   (sequence ()
+                             (set BI msr-psr-cy ((.sym mnemonic "c-cflag") WI rd rs 0))
+                             (set BI msr-psr-ov ((.sym mnemonic "c-oflag") WI rd rs 0))
+                             (set rd (mnemonic WI rd rs))
+                             )
+                   (if (andif msr-psr-ov cr-ex-oe)
+                       (raise-exception EXCEPT-EOVERFLOW))
+                   )
+         ()
+         )
+    )
+  )
+(define-pmacro (simm-alu-carry-insn mnemonic binop)
+  (begin
+    (dni (.sym mnemonic ".i")
+         (.str mnemonic " reg/reg/simm16")
+         ()
+         (.str mnemonic " $rd,$rs,$simm16")
+         (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs simm16)
+         (sequence ()
+                   (sequence ()
+                             (set BI msr-psr-cy ((.sym binop "c-cflag") WI rs (ext WI simm16) 0))
+                             (set BI msr-psr-ov ((.sym binop "c-oflag") WI rs (ext WI simm16) 0))
+                             (set rd (binop WI rs (ext WI simm16)))
+                             )
+                   (if (andif msr-psr-ov cr-ex-oe)
+                       (raise-exception EXCEPT-EOVERFLOW))
+                   )
+         ()
+         )
+    )
+  )
+
+  
+;***************************************************************************
+; Pseudo Instructions
+;***************************************************************************
+
+(dni nop "nop"
+     ()
+     "nop"
+     (+ OPC_OR (f-res-rd 0) (f-res-rs 0))
+     (nop)
+     ()
+)
+
+(dni mov
+  (.str "mov reg/reg")
+  ()
+  (.str "mov $rd,$rs")
+  (+ OPC_OR.I rd rs (f-res-imm16 0))
+  (set rd rs)
+  ()
+)
+
+(dni mov.i
+  (.str "mov reg/uimm16")
+  ()
+  (.str "mov $rd,$uimm16")
+  (+ OPC_OR.I rd (f-res-rs 0) uimm16)
+  (set rd rs)
+  ()
+)
+
+(dni movh "mov hi(reg)/reg"
+     ()
+     "mov hi($rd),$rs"
+     (+ OPC_LSL rd rs (f-res-imm16 16))
+     (set UWI rd (sll UWI rs (const 16)))
+     ()
+)
+
+
+;***************************************************************************
+; ALU Logic Instructions
+;***************************************************************************
+
+(rop-alu-insn and)
+(uimm-alu-insn and and)
+
+(rop-alu-insn or)
+(uimm-alu-insn or or)
+
+(rop-alu-insn xor)
+(simm-alu-insn xor xor)
+
+(define-pmacro (rop-shift-insn mnemonic binop)
+  (begin
+     (dni mnemonic
+          (.str mnemonic " reg/reg")
+          ()
+          (.str mnemonic " $rd,$rs")
+          (+ (.sym OPC_ (.upcase mnemonic)) rd rs)
+          (set UWI rd (binop rd rs))
+          ()
+     )
+   )
+)
+(define-pmacro (uimm-shift-insn mnemonic binop)
+    (dni (.sym mnemonic ".i")
+          (.str mnemonic " reg/reg/uimm16")
+          ()
+          (.str mnemonic " $rd,$rs,${uimm16}")
+          (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs uimm16)
+          (set rd (binop rs uimm16))
+          ()
+     )
+ )
+
+
+(rop-shift-insn lsl sll)
+(uimm-shift-insn lsl sll)
+
+(rop-shift-insn lsr srl)
+(uimm-shift-insn lsr srl)
+
+(rop-shift-insn asr sra)
+(uimm-shift-insn asr sra)
+
+
+;***************************************************************************
+; ALU Integer Instructions
+;***************************************************************************
+
+(rop-alu-carry-insn add)
+(simm-alu-carry-insn add add)
+
+(rop-alu-carry-insn sub)
+
+(dni mul "mul reg/reg"
+  ()
+  ("mul $rd,$rs")
+  (+ OPC_MUL rd rs)
+  (sequence ()
+            (sequence ()
+                      ; 2's complement overflow
+                      (set BI msr-psr-ov (mul-o2flag WI rd rs))
+                      ; 1's complement overflow
+                      (set BI msr-psr-cy (mul-o1flag WI rd rs))
+                      (set rd (mul WI rd rs))
+                      )
+            (if (andif msr-psr-ov cr-ex-oe)
+                (raise-exception EXCEPT-EOVERFLOW))
+            )
+  ()
+)
+
+(dni mulu "mulu reg/reg"
+  ()
+  ("mulu $rd,$rs")
+  (+ OPC_MULU rd rs)
+  (sequence ()
+            (sequence ()
+                      ; 2's complement overflow
+                      (set BI msr-psr-ov 0)
+                      ; 1's complement overflow
+                      (set BI msr-psr-cy (mul-o1flag UWI rd rs))
+                      (set rd (mul UWI rd rs))
+                      )
+            (if (andif msr-psr-ov cr-ex-oe)
+                (raise-exception EXCEPT-EOVERFLOW))
+            )
+  ()
+)
+
+(dni div "div (signed) reg/reg"
+  ()
+  "div $rd,$rs"
+  (+ OPC_DIV rd rs)
+  (sequence ()
+            (if (ne rs 0)
+                (sequence ()
+                          (set BI msr-psr-cy 0)
+                          (set WI rd (div WI rd rs))
+                          )
+                (set BI msr-psr-cy 1)
+                )
+            (set BI msr-psr-ov 0)
+            (if (andif msr-psr-cy cr-ex-oe)
+                (raise-exception EXCEPT-EOVERFLOW))
+            )
+  ()
+)
+
+(dni divu "div (unsigned) reg/reg"
+  ()
+  "divu $rd,$rs"
+  (+ OPC_DIVU rd rs)
+  (sequence ()
+            (if (ne rs 0)
+                (sequence ()
+                          (set BI msr-psr-cy 0)
+                          (set rd (udiv UWI rd rs))
+                          )
+                (set BI msr-psr-cy 1)
+                )
+            (set BI msr-psr-ov 0)
+            (if (andif msr-psr-cy cr-ex-oe)
+                (raise-exception EXCEPT-EOVERFLOW))
+            )
+  ()
+)
+
+(dni mod "mod (signed) reg/reg"
+  ()
+  "mod $rd,$rs"
+  (+ OPC_MOD rd rs)
+  (sequence ()
+            (if (ne rs 0)
+                (sequence ()
+                          (set BI msr-psr-cy 0)
+                          (set WI rd (mod WI rd rs))
+                          )
+                (set BI msr-psr-cy 1)
+                )
+            (set BI msr-psr-ov 0)
+            (if (andif msr-psr-cy cr-ex-oe)
+                (raise-exception EXCEPT-EOVERFLOW))
+            )
+  ()
+)
+
+
+;***************************************************************************
+; trans Instructions
+;***************************************************************************
+
+(dni mhi "mhi"
+     ()
+     "mov hi($rd),${uimm16}"
+     (+ OPC_MHI rd (f-res-rs 0) uimm16)
+     (set UWI rd (sll UWI (zext UWI uimm16) (const 16)))
+     ()
+)
+
+(dni rsmr "rsmr"
+     ()
+     "rsmr $rd,$rs,${uimm16}"
+     (+ OPC_RSMR rd rs uimm16)
+     (set UWI rd (c-call UWI "@cpu@_rsmr" (or rs (zext UWI uimm16))))
+     ()
+)
+
+(dni wsmr "wsmr"
+     ()
+     "wsmr $rd,$rs,${uimm16}"
+     (+ OPC_WSMR rd rs uimm16)
+     (c-call VOID "@cpu@_wsmr" (or rd (zext WI uimm16)) rs)
+     ()
+)
+
+;***************************************************************************
+; Branch Instructions
+;***************************************************************************
+
+(define-pmacro (cti-link-return lnk offset)
+  (set IAI (reg h-gpr lnk) (add pc offset))
+  )
+(define-pmacro (cti-transfer-control condition target)
+  (sequence ()
+    (if condition
+        (delay 1 (set IAI pc target))
+        )
+    )
+  )
+
+(define-pmacro
+  (define-cti
+    cti-name
+    cti-comment
+    cti-attrs
+    cti-syntax
+    cti-format
+    cti-semantics)
+  (begin
+    (dni
+      cti-name
+      cti-comment
+      cti-attrs
+      cti-syntax
+      cti-format
+      (cti-semantics)
+      ()
+      )
+    )
+  )
+  
+
+(define-cti
+  jmp
+  "jmp reg and link (absolute)"
+  (!COND-CTI UNCOND-CTI)
+  "jmp $rd,$rs"
+  (+ OPC_JMP rd rs)
+  (.pmacro ()
+           (sequence ()
+                     (cti-link-return rd 2)
+                     (cti-transfer-control 1 rs)
+                     )
+           )
+  )
+
+(define-cti
+  jmp.i
+  "jmp segment (pc-relative rel21)"
+  (!COND-CTI UNCOND-CTI)
+  "jmp $rd,${rel21}"
+  (+ OPC_JMP.I rd rel21)
+  (.pmacro ()
+           (sequence ()
+                     (cti-link-return rd 4)
+                     (cti-transfer-control 1 rel21)
+                     )
+           )
+   )
+
+(define-cti
+  beq
+  "branch if rd==rs (pc relative addressing)"
+  (COND-CTI !UNCOND-CTI)
+  "beq $rd,$rs,${rel16}"
+  (+ OPC_BEQ rd rs simm16)
+  (.pmacro ()
+           (cti-transfer-control (eq WI rd rs) rel16)
+           )
+  )
+
+(define-cti
+  bne
+  "branch if rd!=rs (pc relative addressing)"
+  (COND-CTI !UNCOND-CTI)
+  "bne $rd,$rs,${rel16}"
+  (+ OPC_BNE rd rs simm16)
+  (.pmacro ()
+           (cti-transfer-control (ne WI rd rs) rel16)
+           )
+  )
+  
+(define-cti
+  bgt
+  "branch if rd>rs (pc relative addressing)"
+  (COND-CTI !UNCOND-CTI)
+  "bgt $rd,$rs,${rel16}"
+  (+ OPC_BGT rd rs rel16)
+  (.pmacro ()
+           (cti-transfer-control (gt WI rd rs) rel16)
+           )
+  )
+  
+(define-cti
+  ble
+  "branch if rd<=rs (pc relative addressing)"
+  (COND-CTI !UNCOND-CTI)
+  "ble $rd,$rs,${rel16}"
+  (+ OPC_BLE rd rs rel16)
+  (.pmacro ()
+           (cti-transfer-control (le WI rd rs) rel16)
+           )
+  )
+
+;***************************************************************************
+; Load/Store Instructions
+;***************************************************************************
+
+(define-pmacro (load-store-addr base offset size)
+  (c-call AI "@cpu@_get_load_store_addr" base (ext SI offset) size))
+
+(dni ldb "ldb reg/simm16(reg) (signed)"
+     ()
+     "ld $rd,@byte,${simm16}($rs)"
+     (+ OPC_LDB rd rs simm16)
+     (set WI rd (ext WI (mem QI (load-store-addr rs simm16 1))))
+     ()
+)
+
+(dni ldbu "ldbu reg/simm16(reg) (signed)"
+     ()
+     "ldu $rd,@byte,${simm16}($rs)"
+     (+ OPC_LDBU rd rs simm16)
+     (set UWI rd (zext UWI (mem UQI (load-store-addr rs simm16 1))))
+     ()
+)
+
+(dni ldh "ldh reg/simm16(reg) (signed)"
+     ()
+     "ld $rd,@hword,${simm16}($rs)"
+     (+ OPC_LDH rd rs simm16)
+     (set WI rd (ext WI (mem HI (load-store-addr rs simm16 2))))
+     ()
+)
+
+(dni ldhu "ldhu reg/simm16(reg) (signed)"
+     ()
+     "ldu $rd,@hword,${simm16}($rs)"
+     (+ OPC_LDHU rd rs simm16)
+     (set UWI rd (zext UWI (mem UHI (load-store-addr rs simm16 2))))
+     ()
+)
+
+(dni ldwu "ldwu reg/simm16(reg) (signed)"
+     ()
+     "ldu $rd,@word,${simm16}($rs)"
+     (+ OPC_LDWU rd rs simm16)
+     (set WI rd (ext WI (mem SI (load-store-addr rs simm16 4))))
+     ()
+)
+
+(define-pmacro (store-insn mnemonic tp opc-op mode size)
+  (begin
+     (dni mnemonic
+          (.str mnemonic " simm16(reg)/reg")
+          ()
+          (.str "st @" tp ",${simm16}($rd),$rs")
+          (+ opc-op rd rs simm16)
+          (sequence ((SI addr))
+                    (set addr (load-store-addr rd simm16 size))
+                    (set mode (mem mode addr) (trunc mode rs))
+           )
+          ()
+     )
+   )
+)
+
+(store-insn stb "byte"  OPC_STB UQI 1)
+(store-insn sth "hword" OPC_STH UHI 2)
+(store-insn stw "word"  OPC_STW USI 4)
+
+;***************************************************************************
+; Exception Instructions
+;***************************************************************************
+
+(dni exc "exc (trap && syscall)"
+     ()
+
+     "exc ${uimm16}"
+     (+ OPC_EXC (f-res-rd 0) (f-res-rs 0) uimm16)
+     ; Do exception entry handling in C function, PC set based on SR state
+     (raise-exception EXCEPT-EEXC)
+     ()
+)
+
+
+(dni barr "memory barrier"
+     ()
+     "barr"
+     (+ OPC_BARR (f-res-rd 0) (f-res-rs 0) (f-res-imm16 0))
+     (nop)
+     ()
+)
+
+(dni ret "resume from exception"
+     (FORCED-CTI)
+
+     "ret"
+     (+ OPC_RET (f-res-rd 0) (f-res-rs 0) (f-res-imm16 0))
+     (c-call VOID "@cpu@_ret")
+     ()
+)
+
+;***************************************************************************
+; Specific accelerators
+;***************************************************************************
+
+(dni pcrp "pcrp reg/rel21"
+    ()
+    "pcrp $rd,${rel21}"
+    (+ OPC_PCRP rd rel21)
+    (set UWI rd rel21) ;;fixme!
+    ()
+  )
+
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/cpu/ncpu32k.opc binutils-ncpu32k-2.32/cpu/ncpu32k.opc
--- binutils-2.32/cpu/ncpu32k.opc	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/cpu/ncpu32k.opc	2019-08-12 22:13:46.385684554 +0800
@@ -0,0 +1,157 @@
+/* nano-CPU32k opcode support.  -*- C -*-
+   Copyright 2019 Free Software Foundation, Inc.
+
+   This file is part of the GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/>. */
+
+
+/* Each section is delimited with start and end markers.
+
+   <arch>-opc.h additions use: "-- opc.h"
+   <arch>-opc.c additions use: "-- opc.c"
+   <arch>-asm.c additions use: "-- asm.c"
+   <arch>-dis.c additions use: "-- dis.c"
+   <arch>-ibd.h additions use: "-- ibd.h"  */
+
+/* -- opc.h */
+
+#undef  CGEN_DIS_HASH_SIZE
+#define CGEN_DIS_HASH_SIZE 256
+#undef  CGEN_DIS_HASH
+#define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] & 0x3f) // opcode[5..0]
+
+/* -- */
+
+/* -- opc.c */
+/* -- */
+
+/* -- asm.c */
+
+static const char * MISSING_CLOSING_PARENTHESIS = N_("missing `)'");
+
+#define CGEN_VERBOSE_ASSEMBLER_ERRORS
+
+static const char *
+inner_parse_rel (CGEN_CPU_DESC cd,
+	      const char ** strp,
+	      int opindex,
+	      int opinfo,
+	      enum cgen_parse_operand_result * resultp,
+	      bfd_vma * valuep,
+              int bitsize)
+{
+  return cgen_parse_address (cd, strp, opindex, opinfo, resultp, valuep);
+}
+
+static const char *
+parse_rel16 (CGEN_CPU_DESC cd,
+	      const char ** strp,
+	      int opindex,
+	      int opinfo,
+	      enum cgen_parse_operand_result * resultp,
+	      bfd_vma * valuep)
+{
+  return inner_parse_rel(cd, strp, opindex, opinfo, resultp, valuep, 16);
+}
+
+static const char *
+parse_rel21 (CGEN_CPU_DESC cd,
+	      const char ** strp,
+	      int opindex,
+	      int opinfo,
+	      enum cgen_parse_operand_result * resultp,
+	      bfd_vma * valuep)
+{
+  return inner_parse_rel(cd, strp, opindex, opinfo, resultp, valuep, 21);
+}
+
+static const char *
+parse_simm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
+{
+  const char *errmsg;
+  enum cgen_parse_operand_result result_type;
+  long ret;
+
+  if (**strp == '#')
+    ++*strp;
+
+  if (strncasecmp (*strp, "hi(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
+				   & result_type, & value);
+      if (**strp != ')')
+	errmsg = MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret >>= 16;
+	  ret &= 0xffff;
+	  ret = (ret ^ 0x8000) - 0x8000;
+	}
+    }
+  else if (strncasecmp (*strp, "lo(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
+				   & result_type, & value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret &= 0xffff;
+	  ret = (ret ^ 0x8000) - 0x8000;
+	}
+    }
+  else
+    {
+      long value;
+      errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
+      ret = value;
+    }
+
+  if (errmsg == NULL)
+    *valuep = ret;
+
+  return errmsg;
+}
+
+static const char *
+parse_uimm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, unsigned long * valuep)
+{
+  const char *errmsg = parse_simm16(cd, strp, opindex, (long *) valuep);
+
+  if (errmsg == NULL)
+    *valuep &= 0xffff;
+  return errmsg;
+}
+
+/* -- */
+
+/* -- ibd.h */
+
+/* -- */
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/elfcpp/elfcpp.h binutils-ncpu32k-2.32/elfcpp/elfcpp.h
--- binutils-2.32/elfcpp/elfcpp.h	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/elfcpp/elfcpp.h	2019-07-31 11:35:54.387898769 +0800
@@ -286,7 +286,9 @@
   // Vitesse IQ2000
   EM_IQ2000 = 0xfeba,
   // NIOS
-  EM_NIOS32 = 0xfebb
+  EM_NIOS32 = 0xfebb,
+  // NCPU32k
+  EM_NCPU32K = 0x4e43
   // Old AVR objects used 0x1057 (EM_AVR is correct).
   // Old MSP430 objects used 0x1059 (EM_MSP430 is correct).
   // Old FR30 objects used 0x3330 (EM_FR30 is correct).
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/gas/config/tc-ncpu32k.c binutils-ncpu32k-2.32/gas/config/tc-ncpu32k.c
--- binutils-2.32/gas/config/tc-ncpu32k.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/config/tc-ncpu32k.c	2019-08-12 22:19:23.517692913 +0800
@@ -0,0 +1,374 @@
+/* tc-ncpu32k.c -- Assembler for the nano-CPU32k processor.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/> */
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+#include "symcat.h"
+#include "opcodes/ncpu32k-desc.h"
+#include "opcodes/ncpu32k-opc.h"
+#include "cgen.h"
+#include "elf/ncpu32k.h"
+#include "dw2gencfi.h"
+
+/* Structure to hold all of the different components describing
+   an individual instruction.  */
+
+typedef struct
+{
+  const CGEN_INSN *     insn;
+  const CGEN_INSN *     orig_insn;
+  CGEN_FIELDS           fields;
+#if CGEN_INT_INSN_P
+  CGEN_INSN_INT         buffer [1];
+#define INSN_VALUE(buf) (*(buf))
+#else
+  unsigned char         buffer [CGEN_MAX_INSN_SIZE];
+#define INSN_VALUE(buf) (buf)
+#endif
+  char *                addr;
+  fragS *               frag;
+  int                   num_fixups;
+  fixS *                fixups [GAS_CGEN_MAX_FIXUPS];
+  int                   indices [MAX_OPERAND_INSTANCES];
+}
+ncpu32k_insn;
+
+/* Bit length of REL21 field */
+#define N_REL21_BITS 21
+
+const char comment_chars[]        = "#";
+const char line_comment_chars[]   = "#";
+const char line_separator_chars[] = ";";
+const char EXP_CHARS[]            = "eE";
+const char FLT_CHARS[]            = "dD";
+
+#define NCPU32K_SHORTOPTS "m:"
+const char * md_shortopts = NCPU32K_SHORTOPTS;
+
+struct option md_longopts[] =
+{
+  {NULL, no_argument, NULL, 0}
+};
+size_t md_longopts_size = sizeof (md_longopts);
+
+unsigned long ncpu32k_machine = 0; /* default */
+
+int
+md_parse_option (int c ATTRIBUTE_UNUSED, const char * arg ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+void
+md_show_usage (FILE * stream ATTRIBUTE_UNUSED)
+{
+}
+
+static void
+ignore_pseudo (int val ATTRIBUTE_UNUSED)
+{
+  discard_rest_of_line ();
+}
+
+const char ncpu32k_comment_chars [] = ";#";
+
+/* The target specific pseudo-ops which we support.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  { "align",    s_align_bytes,  0 },
+  { "word",     cons,           4 },
+  { "proc",     ignore_pseudo,  0 },
+  { "endproc",  ignore_pseudo,  0 },
+  { NULL,       NULL,           0 }
+};
+
+
+void
+md_begin (void)
+{
+  /* Initialize the `cgen' interface.  */
+
+  /* Set the machine number and endian.  */
+  gas_cgen_cpu_desc = ncpu32k_cgen_cpu_open (CGEN_CPU_OPEN_MACHS, 0,
+                                              CGEN_CPU_OPEN_ENDIAN,
+                                              CGEN_ENDIAN_LITTLE, /* le */
+                                              CGEN_CPU_OPEN_END);
+  ncpu32k_cgen_init_asm (gas_cgen_cpu_desc);
+
+  /* This is a callback from cgen to gas to parse operands.  */
+  cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);
+}
+
+void
+md_assemble (char * str)
+{
+  static int last_insn_had_delay_slot = 0;
+  ncpu32k_insn insn;
+  char *    errmsg;
+
+  /* Initialize GAS's cgen interface for a new instruction.  */
+  gas_cgen_init_parse ();
+
+  insn.insn = ncpu32k_cgen_assemble_insn
+    (gas_cgen_cpu_desc, str, & insn.fields, insn.buffer, & errmsg);
+
+  if (!insn.insn)
+    {
+      as_bad ("%s", errmsg);
+      return;
+    }
+
+  /* Doesn't really matter what we pass for RELAX_P here.  */
+  gas_cgen_finish_insn (insn.insn, insn.buffer,
+                        CGEN_FIELDS_BITSIZE (& insn.fields), 1, NULL);
+
+  last_insn_had_delay_slot
+    = CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_DELAY_SLOT);
+  (void) last_insn_had_delay_slot;
+}
+
+void
+md_operand (expressionS * expressionP)
+{
+  if (* input_line_pointer == '#')
+    {
+      input_line_pointer ++;
+      expression (expressionP);
+    }
+}
+
+valueT
+md_section_align (segT segment, valueT size)
+{
+  int align = bfd_get_section_alignment (stdoutput, segment);
+  return ((size + (1 << align) - 1) & -(1 << align));
+}
+
+symbolS *
+md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+
+/* Interface to relax_segment.  */
+
+const relax_typeS md_relax_table[] =
+{
+/* The fields are:
+   1) most positive reach of this state,
+   2) most negative reach of this state,
+   3) how many bytes this mode will add to the size of the current frag
+   4) which index into the table to try if we can't fit into this one.  */
+
+  /* The first entry must be unused because an `rlx_more' value of zero ends
+     each list.  */
+  {1, 1, 0, 0},
+
+  /* The displacement used by GAS is from the end of the 4 byte insn,
+     so we subtract 4 from the following.  */
+  {(((1 << (N_REL21_BITS-1)) - 1) << 1) - 4, -((1 << (N_REL21_BITS-1)) << 1) - 4, 0, 0}, //fixme?
+};
+
+int
+md_estimate_size_before_relax (fragS * fragP, segT segment ATTRIBUTE_UNUSED)
+{
+  return md_relax_table[fragP->fr_subtype].rlx_length;
+}
+
+/* *fragP has been relaxed to its final size, and now needs to have
+   the bytes inside it modified to conform to the new size.
+
+   Called after relaxation is finished.
+   fragP->fr_type == rs_machine_dependent.
+   fragP->fr_subtype is the subtype of what the address relaxed to.  */
+
+void
+md_convert_frag (bfd *   abfd ATTRIBUTE_UNUSED,
+                 segT    sec  ATTRIBUTE_UNUSED,
+                 fragS * fragP ATTRIBUTE_UNUSED)
+{
+  /* FIXME */
+}
+
+
+/* Functions concerning relocs.  */
+
+/* The location from which a PC relative jump should be calculated,
+   given a PC relative reloc.  */
+
+long
+md_pcrel_from_section (fixS * fixP, segT sec)
+{
+  if (fixP->fx_addsy != (symbolS *) NULL
+      && (! S_IS_DEFINED (fixP->fx_addsy)
+          || (S_GET_SEGMENT (fixP->fx_addsy) != sec)
+          || S_IS_EXTERNAL (fixP->fx_addsy)
+          || S_IS_WEAK (fixP->fx_addsy)))
+    {
+        /* The symbol is undefined (or is defined but not in this section).
+         Let the linker figure it out.  */
+      return 0;
+    }
+
+  return fixP->fx_frag->fr_address + fixP->fx_where;
+}
+
+
+/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.
+   Returns BFD_RELOC_NONE if no reloc type can be found.
+   *FIXP may be modified if desired.  */
+
+bfd_reloc_code_real_type
+md_cgen_lookup_reloc (const CGEN_INSN *    insn ATTRIBUTE_UNUSED,
+                      const CGEN_OPERAND * operand,
+                      fixS *               fixP)
+{
+  if (fixP->fx_cgen.opinfo)
+    return fixP->fx_cgen.opinfo;
+
+  switch (operand->type)
+    {
+    case NCPU32K_OPERAND_REL16:
+      fixP->fx_pcrel = 1;
+      return BFD_RELOC_NCPU32K_REL_16;
+    case NCPU32K_OPERAND_REL21:
+      fixP->fx_pcrel = 1;
+      return BFD_RELOC_NCPU32K_REL_21;
+
+    default: /* avoid -Wall warning */
+      return BFD_RELOC_NONE;
+    }
+}
+
+/* Write a value out to the object file, using the appropriate endianness.  */
+
+void
+md_number_to_chars (char * buf, valueT val, int n)
+{
+  number_to_chars_littleendian (buf, val, n);
+}
+
+/* Turn a string in input_line_pointer into a floating point constant of type
+   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
+   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.  */
+
+/* Equal to MAX_PRECISION in atof-ieee.c.  */
+#define MAX_LITTLENUMS 6
+
+const char *
+md_atof (int type, char * litP, int *  sizeP)
+{
+  return ieee_md_atof (type, litP, sizeP, TRUE);
+}
+
+bfd_boolean
+ncpu32k_fix_adjustable (fixS * fixP)
+{
+  /* We need the symbol name for the VTABLE entries.  */
+  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return FALSE;
+
+  return TRUE;
+}
+
+#define GOT_NAME "_GLOBAL_OFFSET_TABLE_"
+
+arelent *
+tc_gen_reloc (asection * section, fixS * fixp)
+{
+  arelent *reloc;
+  bfd_reloc_code_real_type code;
+
+  reloc = XNEW (arelent);
+
+  reloc->sym_ptr_ptr = XNEW (asymbol *);
+  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
+
+  if (fixp->fx_pcrel)
+    {
+      if (section->use_rela_p)
+        fixp->fx_offset -= md_pcrel_from_section (fixp, section);
+      else
+        fixp->fx_offset = reloc->address;
+    }
+  reloc->addend = fixp->fx_offset;
+
+  code = fixp->fx_r_type;
+  switch (code)
+    {
+    case BFD_RELOC_16:
+      if (fixp->fx_pcrel)
+        code = BFD_RELOC_16_PCREL;
+      break;
+
+    case BFD_RELOC_32:
+      if (fixp->fx_pcrel)
+        code = BFD_RELOC_32_PCREL;
+      break;
+
+    case BFD_RELOC_64:
+      if (fixp->fx_pcrel)
+        code = BFD_RELOC_64_PCREL;
+      break;
+
+    default:
+      break;
+    }
+
+  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);
+  if (reloc->howto == NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+                    _
+                    ("cannot represent %s relocation in this object file format"),
+                    bfd_get_reloc_code_name (code));
+      return NULL;
+    }
+
+  return reloc;
+}
+
+void
+ncpu32k_apply_fix (struct fix *f, valueT *t, segT s)
+{
+  gas_cgen_md_apply_fix (f, t, s);
+
+  switch (f->fx_r_type)
+    {
+    //fixme!
+    default:
+      break;
+    }
+}
+
+void
+ncpu32k_elf_final_processing (void)
+{
+}
+
+/* Standard calling conventions leave the CFA at SP on entry.  */
+
+void
+ncpu32k_cfi_frame_initial_instructions (void)
+{
+    cfi_add_CFA_def_cfa_register (1);
+}
+
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/gas/config/tc-ncpu32k.h binutils-ncpu32k-2.32/gas/config/tc-ncpu32k.h
--- binutils-2.32/gas/config/tc-ncpu32k.h	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/config/tc-ncpu32k.h	2019-07-31 10:31:46.140774819 +0800
@@ -0,0 +1,77 @@
+/* tc-ncpu32k.h -- Header file for tc-ncpu32k.c.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/> */
+
+#define TC_NCPU32K
+
+#define LISTING_HEADER "nano-cpu32k GAS "
+
+/* The target BFD architecture.  */
+#define TARGET_ARCH bfd_arch_ncpu32k
+
+extern unsigned long ncpu32k_machine;
+#define TARGET_MACH (ncpu32k_machine)
+
+#define TARGET_FORMAT           "elf32-ncpu32k"
+#define TARGET_BYTES_BIG_ENDIAN 0 /* le */
+
+extern const char ncpu32k_comment_chars [];
+#define tc_comment_chars ncpu32k_comment_chars
+
+/* Permit temporary numeric labels.  */
+#define LOCAL_LABELS_FB 1
+
+#define DIFF_EXPR_OK    1       /* .-foo gets turned into PC relative relocs.  */
+
+/* Turn off 'Broken Words'.  */
+#define WORKING_DOT_WORD
+
+/* Values passed to md_apply_fix don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+#define md_apply_fix ncpu32k_apply_fix
+extern void ncpu32k_apply_fix (struct fix *, valueT *, segT);
+
+extern bfd_boolean ncpu32k_fix_adjustable (struct fix *);
+#define tc_fix_adjustable(FIX) ncpu32k_fix_adjustable (FIX)
+
+/* Call md_pcrel_from_section(), not md_pcrel_from().  */
+extern long md_pcrel_from_section (struct fix *, segT);
+#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from_section (FIX, SEC)
+
+/* Relax PC relative references. For 8 vs 16 vs 32 bit branch selection.  */
+extern const struct relax_type md_relax_table[];
+#define TC_GENERIC_RELAX_TABLE md_relax_table
+
+#define elf_tc_final_processing ncpu32k_elf_final_processing
+void ncpu32k_elf_final_processing (void);
+
+/* Enable cfi directives.  */
+#define TARGET_USE_CFIPOP 1
+
+/* Stack grows to lower addresses and wants 4 byte boundary.  */
+#define DWARF2_CIE_DATA_ALIGNMENT -4
+
+/* Define the column that represents the PC.  */
+#define DWARF2_DEFAULT_RETURN_COLUMN 1
+
+/* minimum ncpu32k instructions are 2 bytes long.  */
+#define DWARF2_LINE_MIN_INSN_LENGTH     2
+
+#define tc_cfi_frame_initial_instructions \
+    ncpu32k_cfi_frame_initial_instructions
+extern void ncpu32k_cfi_frame_initial_instructions (void);
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/gas/configure binutils-ncpu32k-2.32/gas/configure
--- binutils-2.32/gas/configure	2019-02-02 23:50:20.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/configure	2019-08-12 16:22:55.221162579 +0800
@@ -12852,6 +12852,10 @@
 	using_cgen=yes
 	;;
 
+      ncpu32k)
+	using_cgen=yes
+	;;
+
       nds32)
 	# setup NDS32_LINUX_TOOLCHAIN definition
 	if test "linux" = $em; then
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/gas/configure.ac binutils-ncpu32k-2.32/gas/configure.ac
--- binutils-2.32/gas/configure.ac	2019-02-01 19:19:06.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/configure.ac	2019-07-30 18:22:23.224387558 +0800
@@ -454,6 +454,10 @@
 	using_cgen=yes
 	;;
 
+      ncpu32k)
+	using_cgen=yes
+	;;
+
       nds32)
 	# setup NDS32_LINUX_TOOLCHAIN definition
 	if test "linux" = $em; then
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/gas/configure.tgt binutils-ncpu32k-2.32/gas/configure.tgt
--- binutils-2.32/gas/configure.tgt	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/configure.tgt	2019-07-30 18:19:46.876383681 +0800
@@ -332,6 +332,9 @@
 
   msp430-*-*)				fmt=elf ;;
 
+  ncpu32k-*-elf*)			fmt=elf endian=little ;;
+  ncpu32k-*-linux*)			fmt=elf em=linux endian=little ;;
+
   nds32-*-elf*)				fmt=elf ;;
   nds32-*-linux*)			fmt=elf em=linux ;;
 
@@ -438,7 +441,7 @@
 esac
 
 case ${cpu_type} in
-  aarch64 | alpha | arm | csky | i386 | ia64 | microblaze | mips | ns32k | or1k | or1knd | pdp11 | ppc | riscv | sparc | z80 | z8k)
+  aarch64 | alpha | arm | csky | i386 | ia64 | microblaze | mips | ncpu32k | ns32k | or1k | or1knd | pdp11 | ppc | riscv | sparc | z80 | z8k)
     bfd_gas=yes
     ;;
 esac
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/gas/Makefile.am binutils-ncpu32k-2.32/gas/Makefile.am
--- binutils-2.32/gas/Makefile.am	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/Makefile.am	2019-07-31 11:29:50.671889750 +0800
@@ -168,6 +168,7 @@
 	config/tc-moxie.c \
 	config/tc-msp430.c \
 	config/tc-mt.c \
+	config/tc-ncpu32k.c \
 	config/tc-nds32.c \
 	config/tc-nios2.c \
 	config/tc-ns32k.c \
@@ -242,6 +243,7 @@
 	config/tc-mn10300.h \
 	config/tc-msp430.h \
 	config/tc-mt.h \
+	confog/tc-ncpu32k.h \
 	config/tc-nds32.h \
 	config/tc-nios2.h \
 	config/tc-ns32k.h \
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/gas/Makefile.in binutils-ncpu32k-2.32/gas/Makefile.in
--- binutils-2.32/gas/Makefile.in	2019-02-02 23:50:20.000000000 +0800
+++ binutils-ncpu32k-2.32/gas/Makefile.in	2019-08-12 16:20:58.521159685 +0800
@@ -557,6 +557,7 @@
 	config/tc-moxie.c \
 	config/tc-msp430.c \
 	config/tc-mt.c \
+	config/tc-ncpu32k.c \
 	config/tc-nds32.c \
 	config/tc-nios2.c \
 	config/tc-ns32k.c \
@@ -631,6 +632,7 @@
 	config/tc-mn10300.h \
 	config/tc-msp430.h \
 	config/tc-mt.h \
+	confog/tc-ncpu32k.h \
 	config/tc-nds32.h \
 	config/tc-nios2.h \
 	config/tc-ns32k.h \
@@ -964,6 +966,8 @@
 	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-mt.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
+config/tc-ncpu32k.$(OBJEXT): config/$(am__dirstamp) \
+	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-nds32.$(OBJEXT): config/$(am__dirstamp) \
 	config/$(DEPDIR)/$(am__dirstamp)
 config/tc-nios2.$(OBJEXT): config/$(am__dirstamp) \
@@ -1184,6 +1188,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-moxie.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-msp430.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-mt.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-ncpu32k.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-nds32.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-nios2.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@config/$(DEPDIR)/tc-ns32k.Po@am__quote@
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/include/elf/common.h binutils-ncpu32k-2.32/include/elf/common.h
--- binutils-2.32/include/elf/common.h	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/include/elf/common.h	2019-07-30 18:08:30.384366907 +0800
@@ -440,6 +440,8 @@
    architecture was derived.  */
 #define EM_CSKY_OLD		EM_MCORE
 
+#define EM_NCPU32K		0x4e43	/* nano-CPU32K processor */
+
 /* See the above comment before you add a new EM_* value here.  */
 
 /* Values for e_version.  */
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/include/elf/ncpu32k.h binutils-ncpu32k-2.32/include/elf/ncpu32k.h
--- binutils-2.32/include/elf/ncpu32k.h	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/include/elf/ncpu32k.h	2019-08-12 21:55:02.473656686 +0800
@@ -0,0 +1,41 @@
+/* nano-CPU32k ELF support for BFD.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, see <http://www.gnu.org/licenses/> */
+
+#ifndef _ELF_NCPU32K_H
+#define _ELF_NCPU32K_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocations.  */
+START_RELOC_NUMBERS (elf_ncpu32k_reloc_type)
+  RELOC_NUMBER (R_NCPU32K_NONE,           0)
+  RELOC_NUMBER (R_NCPU32K_32,             1)
+  RELOC_NUMBER (R_NCPU32K_16,             2)
+  RELOC_NUMBER (R_NCPU32K_8,              3)
+  RELOC_NUMBER (R_NCPU32K_INSN_REL_16,    4)
+  RELOC_NUMBER (R_NCPU32K_INSN_REL_21,    5)
+  RELOC_NUMBER (R_NCPU32K_GNU_VTENTRY,    6)
+  RELOC_NUMBER (R_NCPU32K_GNU_VTINHERIT,  7)
+  RELOC_NUMBER (R_NCPU32K_COPY,           8)
+  RELOC_NUMBER (R_NCPU32K_GLOB_DAT,       9)
+  RELOC_NUMBER (R_NCPU32K_JMP_SLOT,      10)
+  RELOC_NUMBER (R_NCPU32K_RELATIVE,      11)
+END_RELOC_NUMBERS (R_NCPU32K_max)
+
+#endif /* _ELF_NCPU32K_H */
+
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/ld/configure.tgt binutils-ncpu32k-2.32/ld/configure.tgt
--- binutils-2.32/ld/configure.tgt	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/ld/configure.tgt	2019-08-12 15:47:09.917109385 +0800
@@ -510,6 +510,9 @@
 msp430-*-*)		targ_emul=msp430elf
 			targ_extra_emuls="msp430X"
 			;;
+ncpu32k-*-elf)
+			targ_emul=elf32ncpu32k ;;
+ncpu32k-*-linux*)	targ_emul=elf32ncpu32k_linux ;;
 nds32*le-*-elf*)	targ_emul=nds32elf
 			targ_extra_emuls="nds32elf16m nds32belf nds32belf16m"
 			;;
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/ld/emulparams/elf32ncpu32k_linux.sh binutils-ncpu32k-2.32/ld/emulparams/elf32ncpu32k_linux.sh
--- binutils-2.32/ld/emulparams/elf32ncpu32k_linux.sh	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/ld/emulparams/elf32ncpu32k_linux.sh	2019-08-12 15:50:56.521115004 +0800
@@ -0,0 +1,6 @@
+. ${srcdir}/emulparams/elf32ncpu32k.sh
+unset EMBEDDED
+GENERATE_SHLIB_SCRIPT=yes
+GENERATE_PIE_SCRIPT=yes
+GENERATE_COMBRELOC_SCRIPT=yes
+TEXT_START_ADDR=0x00002000
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/ld/emulparams/elf32ncpu32k.sh binutils-ncpu32k-2.32/ld/emulparams/elf32ncpu32k.sh
--- binutils-2.32/ld/emulparams/elf32ncpu32k.sh	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/ld/emulparams/elf32ncpu32k.sh	2019-08-12 15:50:24.081114199 +0800
@@ -0,0 +1,14 @@
+SCRIPT_NAME=elf
+MACHINE=
+TEMPLATE_NAME=elf32
+OUTPUT_FORMAT="elf32-ncpu32k"
+NOP=0x00000002
+TEXT_START_ADDR=0x0000
+TARGET_PAGE_SIZE=0x2000
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+EMBEDDED=yes
+ARCH=ncpu32k
+ELFSIZE=32
+INITIAL_READONLY_SECTIONS=".vectors ${RELOCATING-0} : { KEEP (*(.vectors)) }"
+NO_REL_RELOCS=yes
+COMMONPAGESIZE="CONSTANT (COMMONPAGESIZE)"
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/ld/Makefile.am binutils-ncpu32k-2.32/ld/Makefile.am
--- binutils-2.32/ld/Makefile.am	2019-01-20 00:01:33.000000000 +0800
+++ binutils-ncpu32k-2.32/ld/Makefile.am	2019-08-12 19:06:23.541405781 +0800
@@ -258,6 +258,8 @@
 	eelf32moxie.c \
 	emoxiebox.c \
 	eelf32mt.c \
+	eelf32ncpu32k.c \
+	eelf32ncpu32k_linux.c \
 	eelf32or1k.c \
 	eelf32or1k_linux.c \
 	eelf32ppc.c \
@@ -1195,6 +1197,12 @@
 eelf32mt.c: $(srcdir)/emulparams/elf32mt.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
+eelf32ncpu32k.c: $(srcdir)/emulparams/elf32ncpu32k.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ncpu32k_linux.c: $(srcdir)/emulparams/elf32ncpu32k_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
 eelf32or1k.c: $(srcdir)/emulparams/elf32or1k.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/ld/Makefile.in binutils-ncpu32k-2.32/ld/Makefile.in
--- binutils-2.32/ld/Makefile.in	2019-02-02 23:54:43.000000000 +0800
+++ binutils-ncpu32k-2.32/ld/Makefile.in	2019-08-12 19:06:42.841406260 +0800
@@ -744,6 +744,8 @@
 	eelf32moxie.c \
 	emoxiebox.c \
 	eelf32mt.c \
+	eelf32ncpu32k.c \
+	eelf32ncpu32k_linux.c \
 	eelf32or1k.c \
 	eelf32or1k_linux.c \
 	eelf32ppc.c \
@@ -1334,6 +1336,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mipswindiss.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32moxie.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mt.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ncpu32k.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ncpu32k_linux.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32or1k.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32or1k_linux.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppc.Po@am__quote@
@@ -2799,6 +2803,12 @@
 eelf32mt.c: $(srcdir)/emulparams/elf32mt.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
+eelf32ncpu32k.c: $(srcdir)/emulparams/elf32ncpu32k.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
+eelf32ncpu32k_linux.c: $(srcdir)/emulparams/elf32ncpu32k_linux.sh \
+  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+
 eelf32or1k.c: $(srcdir)/emulparams/elf32or1k.sh \
   $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/configure binutils-ncpu32k-2.32/opcodes/configure
--- binutils-2.32/opcodes/configure	2019-02-02 23:49:37.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/configure	2019-08-12 16:24:53.633165515 +0800
@@ -12908,6 +12908,7 @@
 	bfd_mn10300_arch)	ta="$ta m10300-dis.lo m10300-opc.lo" ;;
 	bfd_mt_arch)		ta="$ta mt-asm.lo mt-desc.lo mt-dis.lo mt-ibld.lo mt-opc.lo" using_cgen=yes ;;
 	bfd_msp430_arch)	ta="$ta msp430-dis.lo msp430-decode.lo" ;;
+	bfd_ncpu32k_arch)	ta="$ta ncpu32k-asm.lo ncpu32k-desc.lo ncpu32k-dis.lo ncpu32k-ibld.lo ncpu32k-opc.lo" using_cgen=yes ;;
 	bfd_nds32_arch)		ta="$ta nds32-asm.lo nds32-dis.lo" ;;
 	bfd_nfp_arch)		ta="$ta nfp-dis.lo" ;;
 	bfd_nios2_arch)		ta="$ta nios2-dis.lo nios2-opc.lo" ;;
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/configure.ac binutils-ncpu32k-2.32/opcodes/configure.ac
--- binutils-2.32/opcodes/configure.ac	2019-01-20 00:01:34.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/configure.ac	2019-08-12 16:25:09.521165909 +0800
@@ -299,6 +299,7 @@
 	bfd_mn10300_arch)	ta="$ta m10300-dis.lo m10300-opc.lo" ;;
 	bfd_mt_arch)		ta="$ta mt-asm.lo mt-desc.lo mt-dis.lo mt-ibld.lo mt-opc.lo" using_cgen=yes ;;
 	bfd_msp430_arch)	ta="$ta msp430-dis.lo msp430-decode.lo" ;;
+	bfd_ncpu32k_arch)	ta="$ta ncpu32k-asm.lo ncpu32k-desc.lo ncpu32k-dis.lo ncpu32k-ibld.lo ncpu32k-opc.lo" using_cgen=yes ;;
 	bfd_nds32_arch)		ta="$ta nds32-asm.lo nds32-dis.lo" ;;
 	bfd_nfp_arch)		ta="$ta nfp-dis.lo" ;;
 	bfd_nios2_arch)		ta="$ta nios2-dis.lo nios2-opc.lo" ;;
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/disassemble.c binutils-ncpu32k-2.32/opcodes/disassemble.c
--- binutils-2.32/opcodes/disassemble.c	2019-01-20 00:01:34.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/disassemble.c	2019-08-12 18:09:49.341321620 +0800
@@ -64,6 +64,7 @@
 #define ARCH_moxie
 #define ARCH_mt
 #define ARCH_msp430
+#define ARCH_ncpu32k
 #define ARCH_nds32
 #define ARCH_nfp
 #define ARCH_nios2
@@ -284,6 +285,11 @@
       disassemble = print_insn_msp430;
       break;
 #endif
+#ifdef ARCH_ncpu32k
+    case bfd_arch_ncpu32k:
+      disassemble = print_insn_ncpu32k;
+      break;
+#endif
 #ifdef ARCH_nds32
     case bfd_arch_nds32:
       disassemble = print_insn_nds32;
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/disassemble.h binutils-ncpu32k-2.32/opcodes/disassemble.h
--- binutils-2.32/opcodes/disassemble.h	2019-01-20 00:01:34.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/disassemble.h	2019-07-31 11:40:56.239906253 +0800
@@ -73,6 +73,7 @@
 extern int print_insn_moxie		(bfd_vma, disassemble_info *);
 extern int print_insn_msp430		(bfd_vma, disassemble_info *);
 extern int print_insn_mt                (bfd_vma, disassemble_info *);
+extern int print_insn_ncpu32k		(bfd_vma, disassemble_info *);
 extern int print_insn_nds32		(bfd_vma, disassemble_info *);
 extern int print_insn_nfp		(bfd_vma, disassemble_info *);
 extern int print_insn_ns32k		(bfd_vma, disassemble_info *);
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/Makefile.am binutils-ncpu32k-2.32/opcodes/Makefile.am
--- binutils-2.32/opcodes/Makefile.am	2019-01-20 00:01:34.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/Makefile.am	2019-08-12 18:16:39.529331791 +0800
@@ -200,6 +200,11 @@
 	mt-dis.c \
 	mt-ibld.c \
 	mt-opc.c \
+	ncpu32k-asm.c \
+	ncpu32k-desc.c \
+	ncpu32k-dis.c \
+	ncpu32k-ibld.c \
+	ncpu32k-opc.c \
 	nds32-asm.c \
 	nds32-dis.c \
 	nfp-dis.c \
@@ -351,7 +356,7 @@
 CLEANFILES = \
 	stamp-epiphany stamp-fr30 stamp-frv stamp-ip2k stamp-iq2000 stamp-lm32 \
 	stamp-m32c stamp-m32r stamp-mep stamp-mt \
-	stamp-or1k stamp-xc16x stamp-xstormy16 \
+	stamp-ncpu32k stamp-or1k stamp-xc16x stamp-xstormy16 \
 	libopcodes.a stamp-lib
 
 
@@ -367,7 +372,7 @@
 	$(CGENDIR)/opc-opinst.scm \
 	cgen-asm.in cgen-dis.in cgen-ibld.in
 
-CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt or1k xc16x xstormy16
+CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt ncpu32k or1k xc16x xstormy16
 
 if CGEN_MAINT
 EPIPHANY_DEPS = stamp-epiphany
@@ -380,6 +385,7 @@
 M32R_DEPS = stamp-m32r
 MEP_DEPS = stamp-mep
 MT_DEPS = stamp-mt
+NCPU32K_DEPS = stamp-ncpu32k
 OR1K_DEPS = stamp-or1k
 XC16X_DEPS = stamp-xc16x
 XSTORMY16_DEPS = stamp-xstormy16
@@ -394,6 +400,7 @@
 M32R_DEPS =
 MEP_DEPS =
 MT_DEPS =
+NCPU32K_DEPS =
 OR1K_DEPS =
 XC16X_DEPS =
 XSTORMY16_DEPS =
@@ -488,6 +495,12 @@
 		archfile=$(CPUDIR)/mt.cpu \
 		opcfile=$(CPUDIR)/mt.opc extrafiles=
 
+$(srcdir)/ncpu32k-desc.h $(srcdir)/ncpu32k-desc.c $(srcdir)/ncpu32k-opc.h $(srcdir)/ncpu32k-opc.c $(srcdir)/ncpu32k-ibld.c $(srcdir)/ncpu32k-opinst.c $(srcdir)/ncpu32k-asm.c $(srcdir)/ncpu32k-dis.c: $(NCPU32K_DEPS)
+	@true
+stamp-ncpu32k: $(CGENDEPS) $(CPUDIR)/ncpu32k.cpu $(CPUDIR)/ncpu32k.opc
+	$(MAKE) run-cgen arch=ncpu32k prefix=ncpu32k options=opinst \
+		archfile=$(CPUDIR)/ncpu32k.cpu opcfile=$(CPUDIR)/ncpu32k.opc extrafiles=opinst
+
 $(srcdir)/or1k-desc.h $(srcdir)/or1k-desc.c $(srcdir)/or1k-opc.h $(srcdir)/or1k-opc.c $(srcdir)/or1k-ibld.c $(srcdir)/or1k-opinst.c $(srcdir)/or1k-asm.c $(srcdir)/or1k-dis.c: $(OR1K_DEPS)
 	@true
 stamp-or1k: $(CGENDEPS) $(CPUDIR)/or1k.cpu $(CPUDIR)/or1k.opc $(CPUDIR)/or1kcommon.cpu $(CPUDIR)/or1korbis.cpu $(CPUDIR)/or1korfpx.cpu
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/Makefile.in binutils-ncpu32k-2.32/opcodes/Makefile.in
--- binutils-2.32/opcodes/Makefile.in	2019-02-02 23:49:37.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/Makefile.in	2019-08-12 18:18:13.869334130 +0800
@@ -590,6 +590,11 @@
 	mt-dis.c \
 	mt-ibld.c \
 	mt-opc.c \
+	ncpu32k-asm.c \
+	ncpu32k-desc.c \
+	ncpu32k-dis.c \
+	ncpu32k-ibld.c \
+	ncpu32k-opc.c \
 	nds32-asm.c \
 	nds32-dis.c \
 	nfp-dis.c \
@@ -710,7 +715,7 @@
 CLEANFILES = \
 	stamp-epiphany stamp-fr30 stamp-frv stamp-ip2k stamp-iq2000 stamp-lm32 \
 	stamp-m32c stamp-m32r stamp-mep stamp-mt \
-	stamp-or1k stamp-xc16x stamp-xstormy16 \
+	stamp-ncpu32k stamp-or1k stamp-xc16x stamp-xstormy16 \
 	libopcodes.a stamp-lib
 
 CGENDIR = @cgendir@
@@ -724,7 +729,7 @@
 	$(CGENDIR)/opc-opinst.scm \
 	cgen-asm.in cgen-dis.in cgen-ibld.in
 
-CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt or1k xc16x xstormy16
+CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt ncpu32k or1k xc16x xstormy16
 @CGEN_MAINT_FALSE@EPIPHANY_DEPS = 
 @CGEN_MAINT_TRUE@EPIPHANY_DEPS = stamp-epiphany
 @CGEN_MAINT_FALSE@FR30_DEPS = 
@@ -745,6 +750,8 @@
 @CGEN_MAINT_TRUE@MEP_DEPS = stamp-mep
 @CGEN_MAINT_FALSE@MT_DEPS = 
 @CGEN_MAINT_TRUE@MT_DEPS = stamp-mt
+@CGEN_MAINT_FALSE@NCPU32K_DEPS = 
+@CGEN_MAINT_TRUE@NCPU32K_DEPS = stamp-ncpu32k
 @CGEN_MAINT_FALSE@OR1K_DEPS = 
 @CGEN_MAINT_TRUE@OR1K_DEPS = stamp-or1k
 @CGEN_MAINT_FALSE@XC16X_DEPS = 
@@ -997,6 +1004,11 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mt-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mt-ibld.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mt-opc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncpu32k-asm.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncpu32k-desc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncpu32k-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncpu32k-ibld.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncpu32k-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nds32-asm.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nds32-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nfp-dis.Plo@am__quote@
@@ -1470,6 +1482,12 @@
 		archfile=$(CPUDIR)/mt.cpu \
 		opcfile=$(CPUDIR)/mt.opc extrafiles=
 
+$(srcdir)/ncpu32k-desc.h $(srcdir)/ncpu32k-desc.c $(srcdir)/ncpu32k-opc.h $(srcdir)/ncpu32k-opc.c $(srcdir)/ncpu32k-ibld.c $(srcdir)/ncpu32k-opinst.c $(srcdir)/ncpu32k-asm.c $(srcdir)/ncpu32k-dis.c: $(NCPU32K_DEPS)
+	@true
+stamp-ncpu32k: $(CGENDEPS) $(CPUDIR)/ncpu32k.cpu $(CPUDIR)/ncpu32k.opc
+	$(MAKE) run-cgen arch=ncpu32k prefix=ncpu32k options=opinst \
+		archfile=$(CPUDIR)/ncpu32k.cpu opcfile=$(CPUDIR)/ncpu32k.opc extrafiles=opinst
+
 $(srcdir)/or1k-desc.h $(srcdir)/or1k-desc.c $(srcdir)/or1k-opc.h $(srcdir)/or1k-opc.c $(srcdir)/or1k-ibld.c $(srcdir)/or1k-opinst.c $(srcdir)/or1k-asm.c $(srcdir)/or1k-dis.c: $(OR1K_DEPS)
 	@true
 stamp-or1k: $(CGENDEPS) $(CPUDIR)/or1k.cpu $(CPUDIR)/or1k.opc $(CPUDIR)/or1kcommon.cpu $(CPUDIR)/or1korbis.cpu $(CPUDIR)/or1korfpx.cpu
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-asm.c binutils-ncpu32k-2.32/opcodes/ncpu32k-asm.c
--- binutils-2.32/opcodes/ncpu32k-asm.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-asm.c	2019-08-12 22:13:51.885684690 +0800
@@ -0,0 +1,632 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Assembler interface for targets using CGEN. -*- C -*-
+   CGEN: Cpu tools GENerator
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN.
+   - the resultant file is machine generated, cgen-asm.in isn't
+
+   Copyright (C) 1996-2019 Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+#include "opintl.h"
+#include "xregex.h"
+#include "libiberty.h"
+#include "safe-ctype.h"
+
+#undef  min
+#define min(a,b) ((a) < (b) ? (a) : (b))
+#undef  max
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+static const char * parse_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *, const char **, CGEN_FIELDS *);
+
+/* -- assembler routines inserted here.  */
+
+/* -- asm.c */
+
+static const char * MISSING_CLOSING_PARENTHESIS = N_("missing `)'");
+
+#define CGEN_VERBOSE_ASSEMBLER_ERRORS
+
+static const char *
+inner_parse_rel (CGEN_CPU_DESC cd,
+	      const char ** strp,
+	      int opindex,
+	      int opinfo,
+	      enum cgen_parse_operand_result * resultp,
+	      bfd_vma * valuep,
+              int bitsize)
+{
+  return cgen_parse_address (cd, strp, opindex, opinfo, resultp, valuep);
+}
+
+static const char *
+parse_rel16 (CGEN_CPU_DESC cd,
+	      const char ** strp,
+	      int opindex,
+	      int opinfo,
+	      enum cgen_parse_operand_result * resultp,
+	      bfd_vma * valuep)
+{
+  return inner_parse_rel(cd, strp, opindex, opinfo, resultp, valuep, 16);
+}
+
+static const char *
+parse_rel21 (CGEN_CPU_DESC cd,
+	      const char ** strp,
+	      int opindex,
+	      int opinfo,
+	      enum cgen_parse_operand_result * resultp,
+	      bfd_vma * valuep)
+{
+  return inner_parse_rel(cd, strp, opindex, opinfo, resultp, valuep, 21);
+}
+
+static const char *
+parse_simm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
+{
+  const char *errmsg;
+  enum cgen_parse_operand_result result_type;
+  long ret;
+
+  if (**strp == '#')
+    ++*strp;
+
+  if (strncasecmp (*strp, "hi(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
+				   & result_type, & value);
+      if (**strp != ')')
+	errmsg = MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (errmsg == NULL
+	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret >>= 16;
+	  ret &= 0xffff;
+	  ret = (ret ^ 0x8000) - 0x8000;
+	}
+    }
+  else if (strncasecmp (*strp, "lo(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
+				   & result_type, & value);
+      if (**strp != ')')
+	return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+
+      ret = value;
+
+      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+	{
+	  ret &= 0xffff;
+	  ret = (ret ^ 0x8000) - 0x8000;
+	}
+    }
+  else
+    {
+      long value;
+      errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
+      ret = value;
+    }
+
+  if (errmsg == NULL)
+    *valuep = ret;
+
+  return errmsg;
+}
+
+static const char *
+parse_uimm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, unsigned long * valuep)
+{
+  const char *errmsg = parse_simm16(cd, strp, opindex, (long *) valuep);
+
+  if (errmsg == NULL)
+    *valuep &= 0xffff;
+  return errmsg;
+}
+
+/* -- */
+
+const char * ncpu32k_cgen_parse_operand
+  (CGEN_CPU_DESC, int, const char **, CGEN_FIELDS *);
+
+/* Main entry point for operand parsing.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `parse_insn_normal', but keeping it
+   separate makes clear the interface between `parse_insn_normal' and each of
+   the handlers.  */
+
+const char *
+ncpu32k_cgen_parse_operand (CGEN_CPU_DESC cd,
+			   int opindex,
+			   const char ** strp,
+			   CGEN_FIELDS * fields)
+{
+  const char * errmsg = NULL;
+  /* Used by scalar operands that still need to be parsed.  */
+  long junk ATTRIBUTE_UNUSED;
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      errmsg = cgen_parse_keyword (cd, strp, & ncpu32k_cgen_opval_h_gpr, & fields->f_rd);
+      break;
+    case NCPU32K_OPERAND_REL16 :
+      {
+        bfd_vma value = 0;
+        errmsg = parse_rel16 (cd, strp, NCPU32K_OPERAND_REL16, 0, NULL,  & value);
+        fields->f_rel16 = value;
+      }
+      break;
+    case NCPU32K_OPERAND_REL21 :
+      {
+        bfd_vma value = 0;
+        errmsg = parse_rel21 (cd, strp, NCPU32K_OPERAND_REL21, 0, NULL,  & value);
+        fields->f_rel21 = value;
+      }
+      break;
+    case NCPU32K_OPERAND_RS :
+      errmsg = cgen_parse_keyword (cd, strp, & ncpu32k_cgen_opval_h_gpr, & fields->f_rs);
+      break;
+    case NCPU32K_OPERAND_SIMM16 :
+      errmsg = parse_simm16 (cd, strp, NCPU32K_OPERAND_SIMM16, (long *) (& fields->f_simm16));
+      break;
+    case NCPU32K_OPERAND_UIMM16 :
+      errmsg = parse_uimm16 (cd, strp, NCPU32K_OPERAND_UIMM16, (unsigned long *) (& fields->f_uimm16));
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while parsing.\n"), opindex);
+      abort ();
+  }
+
+  return errmsg;
+}
+
+cgen_parse_fn * const ncpu32k_cgen_parse_handlers[] =
+{
+  parse_insn_normal,
+};
+
+void
+ncpu32k_cgen_init_asm (CGEN_CPU_DESC cd)
+{
+  ncpu32k_cgen_init_opcode_table (cd);
+  ncpu32k_cgen_init_ibld_table (cd);
+  cd->parse_handlers = & ncpu32k_cgen_parse_handlers[0];
+  cd->parse_operand = ncpu32k_cgen_parse_operand;
+#ifdef CGEN_ASM_INIT_HOOK
+CGEN_ASM_INIT_HOOK
+#endif
+}
+
+
+
+/* Regex construction routine.
+
+   This translates an opcode syntax string into a regex string,
+   by replacing any non-character syntax element (such as an
+   opcode) with the pattern '.*'
+
+   It then compiles the regex and stores it in the opcode, for
+   later use by ncpu32k_cgen_assemble_insn
+
+   Returns NULL for success, an error message for failure.  */
+
+char *
+ncpu32k_cgen_build_insn_regex (CGEN_INSN *insn)
+{
+  CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
+  const char *mnem = CGEN_INSN_MNEMONIC (insn);
+  char rxbuf[CGEN_MAX_RX_ELEMENTS];
+  char *rx = rxbuf;
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+  int reg_err;
+
+  syn = CGEN_SYNTAX_STRING (CGEN_OPCODE_SYNTAX (opc));
+
+  /* Mnemonics come first in the syntax string.  */
+  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))
+    return _("missing mnemonic in syntax string");
+  ++syn;
+
+  /* Generate a case sensitive regular expression that emulates case
+     insensitive matching in the "C" locale.  We cannot generate a case
+     insensitive regular expression because in Turkish locales, 'i' and 'I'
+     are not equal modulo case conversion.  */
+
+  /* Copy the literal mnemonic out of the insn.  */
+  for (; *mnem; mnem++)
+    {
+      char c = *mnem;
+
+      if (ISALPHA (c))
+	{
+	  *rx++ = '[';
+	  *rx++ = TOLOWER (c);
+	  *rx++ = TOUPPER (c);
+	  *rx++ = ']';
+	}
+      else
+	*rx++ = c;
+    }
+
+  /* Copy any remaining literals from the syntax string into the rx.  */
+  for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
+    {
+      if (CGEN_SYNTAX_CHAR_P (* syn))
+	{
+	  char c = CGEN_SYNTAX_CHAR (* syn);
+
+	  switch (c)
+	    {
+	      /* Escape any regex metacharacters in the syntax.  */
+	    case '.': case '[': case '\\':
+	    case '*': case '^': case '$':
+
+#ifdef CGEN_ESCAPE_EXTENDED_REGEX
+	    case '?': case '{': case '}':
+	    case '(': case ')': case '*':
+	    case '|': case '+': case ']':
+#endif
+	      *rx++ = '\\';
+	      *rx++ = c;
+	      break;
+
+	    default:
+	      if (ISALPHA (c))
+		{
+		  *rx++ = '[';
+		  *rx++ = TOLOWER (c);
+		  *rx++ = TOUPPER (c);
+		  *rx++ = ']';
+		}
+	      else
+		*rx++ = c;
+	      break;
+	    }
+	}
+      else
+	{
+	  /* Replace non-syntax fields with globs.  */
+	  *rx++ = '.';
+	  *rx++ = '*';
+	}
+    }
+
+  /* Trailing whitespace ok.  */
+  * rx++ = '[';
+  * rx++ = ' ';
+  * rx++ = '\t';
+  * rx++ = ']';
+  * rx++ = '*';
+
+  /* But anchor it after that.  */
+  * rx++ = '$';
+  * rx = '\0';
+
+  CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
+  reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
+
+  if (reg_err == 0)
+    return NULL;
+  else
+    {
+      static char msg[80];
+
+      regerror (reg_err, (regex_t *) CGEN_INSN_RX (insn), msg, 80);
+      regfree ((regex_t *) CGEN_INSN_RX (insn));
+      free (CGEN_INSN_RX (insn));
+      (CGEN_INSN_RX (insn)) = NULL;
+      return msg;
+    }
+}
+
+
+/* Default insn parser.
+
+   The syntax string is scanned and operands are parsed and stored in FIELDS.
+   Relocs are queued as we go via other callbacks.
+
+   ??? Note that this is currently an all-or-nothing parser.  If we fail to
+   parse the instruction, we return 0 and the caller will start over from
+   the beginning.  Backtracking will be necessary in parsing subexpressions,
+   but that can be handled there.  Not handling backtracking here may get
+   expensive in the case of the m68k.  Deal with later.
+
+   Returns NULL for success, an error message for failure.  */
+
+static const char *
+parse_insn_normal (CGEN_CPU_DESC cd,
+		   const CGEN_INSN *insn,
+		   const char **strp,
+		   CGEN_FIELDS *fields)
+{
+  /* ??? Runtime added insns not handled yet.  */
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  const char *str = *strp;
+  const char *errmsg;
+  const char *p;
+  const CGEN_SYNTAX_CHAR_TYPE * syn;
+#ifdef CGEN_MNEMONIC_OPERANDS
+  /* FIXME: wip */
+  int past_opcode_p;
+#endif
+
+  /* For now we assume the mnemonic is first (there are no leading operands).
+     We can parse it without needing to set up operand parsing.
+     GAS's input scrubber will ensure mnemonics are lowercase, but we may
+     not be called from GAS.  */
+  p = CGEN_INSN_MNEMONIC (insn);
+  while (*p && TOLOWER (*p) == TOLOWER (*str))
+    ++p, ++str;
+
+  if (* p)
+    return _("unrecognized instruction");
+
+#ifndef CGEN_MNEMONIC_OPERANDS
+  if (* str && ! ISSPACE (* str))
+    return _("unrecognized instruction");
+#endif
+
+  CGEN_INIT_PARSE (cd);
+  cgen_init_parse_operand (cd);
+#ifdef CGEN_MNEMONIC_OPERANDS
+  past_opcode_p = 0;
+#endif
+
+  /* We don't check for (*str != '\0') here because we want to parse
+     any trailing fake arguments in the syntax string.  */
+  syn = CGEN_SYNTAX_STRING (syntax);
+
+  /* Mnemonics come first for now, ensure valid string.  */
+  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))
+    abort ();
+
+  ++syn;
+
+  while (* syn != 0)
+    {
+      /* Non operand chars must match exactly.  */
+      if (CGEN_SYNTAX_CHAR_P (* syn))
+	{
+	  /* FIXME: While we allow for non-GAS callers above, we assume the
+	     first char after the mnemonic part is a space.  */
+	  /* FIXME: We also take inappropriate advantage of the fact that
+	     GAS's input scrubber will remove extraneous blanks.  */
+	  if (TOLOWER (*str) == TOLOWER (CGEN_SYNTAX_CHAR (* syn)))
+	    {
+#ifdef CGEN_MNEMONIC_OPERANDS
+	      if (CGEN_SYNTAX_CHAR(* syn) == ' ')
+		past_opcode_p = 1;
+#endif
+	      ++ syn;
+	      ++ str;
+	    }
+	  else if (*str)
+	    {
+	      /* Syntax char didn't match.  Can't be this insn.  */
+	      static char msg [80];
+
+	      /* xgettext:c-format */
+	      sprintf (msg, _("syntax error (expected char `%c', found `%c')"),
+		       CGEN_SYNTAX_CHAR(*syn), *str);
+	      return msg;
+	    }
+	  else
+	    {
+	      /* Ran out of input.  */
+	      static char msg [80];
+
+	      /* xgettext:c-format */
+	      sprintf (msg, _("syntax error (expected char `%c', found end of instruction)"),
+		       CGEN_SYNTAX_CHAR(*syn));
+	      return msg;
+	    }
+	  continue;
+	}
+
+#ifdef CGEN_MNEMONIC_OPERANDS
+      (void) past_opcode_p;
+#endif
+      /* We have an operand of some sort.  */
+      errmsg = cd->parse_operand (cd, CGEN_SYNTAX_FIELD (*syn), &str, fields);
+      if (errmsg)
+	return errmsg;
+
+      /* Done with this operand, continue with next one.  */
+      ++ syn;
+    }
+
+  /* If we're at the end of the syntax string, we're done.  */
+  if (* syn == 0)
+    {
+      /* FIXME: For the moment we assume a valid `str' can only contain
+	 blanks now.  IE: We needn't try again with a longer version of
+	 the insn and it is assumed that longer versions of insns appear
+	 before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */
+      while (ISSPACE (* str))
+	++ str;
+
+      if (* str != '\0')
+	return _("junk at end of line"); /* FIXME: would like to include `str' */
+
+      return NULL;
+    }
+
+  /* We couldn't parse it.  */
+  return _("unrecognized instruction");
+}
+
+/* Main entry point.
+   This routine is called for each instruction to be assembled.
+   STR points to the insn to be assembled.
+   We assume all necessary tables have been initialized.
+   The assembled instruction, less any fixups, is stored in BUF.
+   Remember that if CGEN_INT_INSN_P then BUF is an int and thus the value
+   still needs to be converted to target byte order, otherwise BUF is an array
+   of bytes in target byte order.
+   The result is a pointer to the insn's entry in the opcode table,
+   or NULL if an error occured (an error message will have already been
+   printed).
+
+   Note that when processing (non-alias) macro-insns,
+   this function recurses.
+
+   ??? It's possible to make this cpu-independent.
+   One would have to deal with a few minor things.
+   At this point in time doing so would be more of a curiosity than useful
+   [for example this file isn't _that_ big], but keeping the possibility in
+   mind helps keep the design clean.  */
+
+const CGEN_INSN *
+ncpu32k_cgen_assemble_insn (CGEN_CPU_DESC cd,
+			   const char *str,
+			   CGEN_FIELDS *fields,
+			   CGEN_INSN_BYTES_PTR buf,
+			   char **errmsg)
+{
+  const char *start;
+  CGEN_INSN_LIST *ilist;
+  const char *parse_errmsg = NULL;
+  const char *insert_errmsg = NULL;
+  int recognized_mnemonic = 0;
+
+  /* Skip leading white space.  */
+  while (ISSPACE (* str))
+    ++ str;
+
+  /* The instructions are stored in hashed lists.
+     Get the first in the list.  */
+  ilist = CGEN_ASM_LOOKUP_INSN (cd, str);
+
+  /* Keep looking until we find a match.  */
+  start = str;
+  for ( ; ilist != NULL ; ilist = CGEN_ASM_NEXT_INSN (ilist))
+    {
+      const CGEN_INSN *insn = ilist->insn;
+      recognized_mnemonic = 1;
+
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
+      /* Not usually needed as unsupported opcodes
+	 shouldn't be in the hash lists.  */
+      /* Is this insn supported by the selected cpu?  */
+      if (! ncpu32k_cgen_insn_supported (cd, insn))
+	continue;
+#endif
+      /* If the RELAXED attribute is set, this is an insn that shouldn't be
+	 chosen immediately.  Instead, it is used during assembler/linker
+	 relaxation if possible.  */
+      if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED) != 0)
+	continue;
+
+      str = start;
+
+      /* Skip this insn if str doesn't look right lexically.  */
+      if (CGEN_INSN_RX (insn) != NULL &&
+	  regexec ((regex_t *) CGEN_INSN_RX (insn), str, 0, NULL, 0) == REG_NOMATCH)
+	continue;
+
+      /* Allow parse/insert handlers to obtain length of insn.  */
+      CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);
+
+      parse_errmsg = CGEN_PARSE_FN (cd, insn) (cd, insn, & str, fields);
+      if (parse_errmsg != NULL)
+	continue;
+
+      /* ??? 0 is passed for `pc'.  */
+      insert_errmsg = CGEN_INSERT_FN (cd, insn) (cd, insn, fields, buf,
+						 (bfd_vma) 0);
+      if (insert_errmsg != NULL)
+        continue;
+
+      /* It is up to the caller to actually output the insn and any
+         queued relocs.  */
+      return insn;
+    }
+
+  {
+    static char errbuf[150];
+    const char *tmp_errmsg;
+#ifdef CGEN_VERBOSE_ASSEMBLER_ERRORS
+#define be_verbose 1
+#else
+#define be_verbose 0
+#endif
+
+    if (be_verbose)
+      {
+	/* If requesting verbose error messages, use insert_errmsg.
+	   Failing that, use parse_errmsg.  */
+	tmp_errmsg = (insert_errmsg ? insert_errmsg :
+		      parse_errmsg ? parse_errmsg :
+		      recognized_mnemonic ?
+		      _("unrecognized form of instruction") :
+		      _("unrecognized instruction"));
+
+	if (strlen (start) > 50)
+	  /* xgettext:c-format */
+	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
+	else
+	  /* xgettext:c-format */
+	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
+      }
+    else
+      {
+	if (strlen (start) > 50)
+	  /* xgettext:c-format */
+	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
+	else
+	  /* xgettext:c-format */
+	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
+      }
+
+    *errmsg = errbuf;
+    return NULL;
+  }
+}
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-desc.c binutils-ncpu32k-2.32/opcodes/ncpu32k-desc.c
--- binutils-2.32/opcodes/ncpu32k-desc.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-desc.c	2019-08-12 18:59:51.677396065 +0800
@@ -0,0 +1,1543 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* CPU data for ncpu32k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include <stdio.h>
+#include <stdarg.h>
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+#include "opintl.h"
+#include "libiberty.h"
+#include "xregex.h"
+
+/* Attributes.  */
+
+static const CGEN_ATTR_ENTRY bool_attr[] =
+{
+  { "#f", 0 },
+  { "#t", 1 },
+  { 0, 0 }
+};
+
+static const CGEN_ATTR_ENTRY MACH_attr[] ATTRIBUTE_UNUSED =
+{
+  { "base", MACH_BASE },
+  { "ncpu32k_mach", MACH_NCPU32K_MACH },
+  { "max", MACH_MAX },
+  { 0, 0 }
+};
+
+static const CGEN_ATTR_ENTRY ISA_attr[] ATTRIBUTE_UNUSED =
+{
+  { "ncpu32k_isa", ISA_NCPU32K_ISA },
+  { "max", ISA_MAX },
+  { 0, 0 }
+};
+
+const CGEN_ATTR_TABLE ncpu32k_cgen_ifield_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "RESERVED", &bool_attr[0], &bool_attr[0] },
+  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
+  { "SIGNED", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE ncpu32k_cgen_hardware_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "CACHE-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "PC", &bool_attr[0], &bool_attr[0] },
+  { "PROFILE", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE ncpu32k_cgen_operand_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
+  { "SIGNED", &bool_attr[0], &bool_attr[0] },
+  { "NEGATIVE", &bool_attr[0], &bool_attr[0] },
+  { "RELAX", &bool_attr[0], &bool_attr[0] },
+  { "SEM-ONLY", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE ncpu32k_cgen_insn_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "ALIAS", &bool_attr[0], &bool_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "UNCOND-CTI", &bool_attr[0], &bool_attr[0] },
+  { "COND-CTI", &bool_attr[0], &bool_attr[0] },
+  { "SKIP-CTI", &bool_attr[0], &bool_attr[0] },
+  { "DELAY-SLOT", &bool_attr[0], &bool_attr[0] },
+  { "RELAXABLE", &bool_attr[0], &bool_attr[0] },
+  { "RELAXED", &bool_attr[0], &bool_attr[0] },
+  { "NO-DIS", &bool_attr[0], &bool_attr[0] },
+  { "PBB", &bool_attr[0], &bool_attr[0] },
+  { "FORCED-CTI", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+/* Instruction set variants.  */
+
+static const CGEN_ISA ncpu32k_cgen_isa_table[] = {
+  { "ncpu32k-isa", 16, 16, 16, 32 },
+  { 0, 0, 0, 0, 0 }
+};
+
+/* Machine variants.  */
+
+static const CGEN_MACH ncpu32k_cgen_mach_table[] = {
+  { "ncpu32k-mach", "ncpu32k", MACH_NCPU32K_MACH, 0 },
+  { 0, 0, 0, 0 }
+};
+
+static CGEN_KEYWORD_ENTRY ncpu32k_cgen_opval_h_frs_entries[] =
+{
+  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
+  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
+  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
+  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
+  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
+  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 },
+  { "nil", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "lnk", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "sp", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "fp", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "v0", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "v1", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "v2", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "v3", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "v4", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "v5", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "rv", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "rvh", 11, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD ncpu32k_cgen_opval_h_frs =
+{
+  & ncpu32k_cgen_opval_h_frs_entries[0],
+  44,
+  0, 0, 0, 0, ""
+};
+
+static CGEN_KEYWORD_ENTRY ncpu32k_cgen_opval_h_frd_entries[] =
+{
+  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
+  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
+  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
+  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
+  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
+  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 },
+  { "nil", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "lnk", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "sp", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "fp", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "v0", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "v1", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "v2", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "v3", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "v4", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "v5", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "rv", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "rvh", 11, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD ncpu32k_cgen_opval_h_frd =
+{
+  & ncpu32k_cgen_opval_h_frd_entries[0],
+  44,
+  0, 0, 0, 0, ""
+};
+
+static CGEN_KEYWORD_ENTRY ncpu32k_cgen_opval_h_gpr_entries[] =
+{
+  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
+  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
+  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
+  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
+  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
+  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 },
+  { "nil", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "lnk", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "sp", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "fp", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "v0", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "v1", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "v2", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "v3", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "v4", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "v5", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "rv", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "rvh", 11, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD ncpu32k_cgen_opval_h_gpr =
+{
+  & ncpu32k_cgen_opval_h_gpr_entries[0],
+  44,
+  0, 0, 0, 0, ""
+};
+
+
+/* The hardware table.  */
+
+#define A(a) (1 << CGEN_HW_##a)
+
+const CGEN_HW_ENTRY ncpu32k_cgen_hw_table[] =
+{
+  { "h-memory", HW_H_MEMORY, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-sint", HW_H_SINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-uint", HW_H_UINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-addr", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-iaddr", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-pc", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PC), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-frs", HW_H_FRS, CGEN_ASM_KEYWORD, (PTR) & ncpu32k_cgen_opval_h_frs, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-frd", HW_H_FRD, CGEN_ASM_KEYWORD, (PTR) & ncpu32k_cgen_opval_h_frd, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-smr", HW_H_SMR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-gpr", HW_H_GPR, CGEN_ASM_KEYWORD, (PTR) & ncpu32k_cgen_opval_h_gpr, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-cpuid", HW_H_CR_CPUID, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-ex", HW_H_CR_EX, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-eb", HW_H_CR_EB, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-epc", HW_H_CR_EPC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-ecsr", HW_H_CR_ECSR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-dpr", HW_H_CR_DPR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-icc", HW_H_CR_ICC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-dcc", HW_H_CR_DCC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-immuc", HW_H_CR_IMMUC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-dmmuc", HW_H_CR_DMMUC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-trmuc", HW_H_CR_TRMUC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-picuc", HW_H_CR_PICUC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-dbguc", HW_H_CR_DBGUC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-fpuc", HW_H_CR_FPUC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-pmuc", HW_H_CR_PMUC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-pmcuc", HW_H_CR_PMCUC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr0", HW_H_CR_GPR0, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr1", HW_H_CR_GPR1, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr2", HW_H_CR_GPR2, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr3", HW_H_CR_GPR3, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr4", HW_H_CR_GPR4, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr5", HW_H_CR_GPR5, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr6", HW_H_CR_GPR6, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr7", HW_H_CR_GPR7, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr8", HW_H_CR_GPR8, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr9", HW_H_CR_GPR9, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr10", HW_H_CR_GPR10, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr11", HW_H_CR_GPR11, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr12", HW_H_CR_GPR12, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr13", HW_H_CR_GPR13, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr14", HW_H_CR_GPR14, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr15", HW_H_CR_GPR15, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr16", HW_H_CR_GPR16, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr17", HW_H_CR_GPR17, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr18", HW_H_CR_GPR18, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr19", HW_H_CR_GPR19, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr20", HW_H_CR_GPR20, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr21", HW_H_CR_GPR21, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr22", HW_H_CR_GPR22, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr23", HW_H_CR_GPR23, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr24", HW_H_CR_GPR24, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr25", HW_H_CR_GPR25, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr26", HW_H_CR_GPR26, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr27", HW_H_CR_GPR27, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr28", HW_H_CR_GPR28, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr29", HW_H_CR_GPR29, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr30", HW_H_CR_GPR30, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr31", HW_H_CR_GPR31, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr32", HW_H_CR_GPR32, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr33", HW_H_CR_GPR33, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr34", HW_H_CR_GPR34, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr35", HW_H_CR_GPR35, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr36", HW_H_CR_GPR36, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr37", HW_H_CR_GPR37, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr38", HW_H_CR_GPR38, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr39", HW_H_CR_GPR39, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr40", HW_H_CR_GPR40, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr41", HW_H_CR_GPR41, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr42", HW_H_CR_GPR42, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr43", HW_H_CR_GPR43, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr44", HW_H_CR_GPR44, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr45", HW_H_CR_GPR45, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr46", HW_H_CR_GPR46, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr47", HW_H_CR_GPR47, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr48", HW_H_CR_GPR48, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr49", HW_H_CR_GPR49, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr50", HW_H_CR_GPR50, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr51", HW_H_CR_GPR51, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr52", HW_H_CR_GPR52, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr53", HW_H_CR_GPR53, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr54", HW_H_CR_GPR54, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr55", HW_H_CR_GPR55, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr56", HW_H_CR_GPR56, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr57", HW_H_CR_GPR57, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr58", HW_H_CR_GPR58, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr59", HW_H_CR_GPR59, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr60", HW_H_CR_GPR60, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr61", HW_H_CR_GPR61, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr62", HW_H_CR_GPR62, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr63", HW_H_CR_GPR63, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr64", HW_H_CR_GPR64, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr65", HW_H_CR_GPR65, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr66", HW_H_CR_GPR66, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr67", HW_H_CR_GPR67, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr68", HW_H_CR_GPR68, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr69", HW_H_CR_GPR69, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr70", HW_H_CR_GPR70, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr71", HW_H_CR_GPR71, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr72", HW_H_CR_GPR72, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr73", HW_H_CR_GPR73, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr74", HW_H_CR_GPR74, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr75", HW_H_CR_GPR75, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr76", HW_H_CR_GPR76, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr77", HW_H_CR_GPR77, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr78", HW_H_CR_GPR78, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr79", HW_H_CR_GPR79, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr80", HW_H_CR_GPR80, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr81", HW_H_CR_GPR81, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr82", HW_H_CR_GPR82, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr83", HW_H_CR_GPR83, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr84", HW_H_CR_GPR84, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr85", HW_H_CR_GPR85, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr86", HW_H_CR_GPR86, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr87", HW_H_CR_GPR87, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr88", HW_H_CR_GPR88, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr89", HW_H_CR_GPR89, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr90", HW_H_CR_GPR90, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr91", HW_H_CR_GPR91, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr92", HW_H_CR_GPR92, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr93", HW_H_CR_GPR93, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr94", HW_H_CR_GPR94, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr95", HW_H_CR_GPR95, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr96", HW_H_CR_GPR96, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr97", HW_H_CR_GPR97, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr98", HW_H_CR_GPR98, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr99", HW_H_CR_GPR99, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr100", HW_H_CR_GPR100, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr101", HW_H_CR_GPR101, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr102", HW_H_CR_GPR102, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr103", HW_H_CR_GPR103, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr104", HW_H_CR_GPR104, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr105", HW_H_CR_GPR105, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr106", HW_H_CR_GPR106, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr107", HW_H_CR_GPR107, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr108", HW_H_CR_GPR108, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr109", HW_H_CR_GPR109, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr110", HW_H_CR_GPR110, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr111", HW_H_CR_GPR111, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr112", HW_H_CR_GPR112, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr113", HW_H_CR_GPR113, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr114", HW_H_CR_GPR114, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr115", HW_H_CR_GPR115, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr116", HW_H_CR_GPR116, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr117", HW_H_CR_GPR117, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr118", HW_H_CR_GPR118, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr119", HW_H_CR_GPR119, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr120", HW_H_CR_GPR120, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr121", HW_H_CR_GPR121, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr122", HW_H_CR_GPR122, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr123", HW_H_CR_GPR123, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr124", HW_H_CR_GPR124, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr125", HW_H_CR_GPR125, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr126", HW_H_CR_GPR126, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr127", HW_H_CR_GPR127, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr128", HW_H_CR_GPR128, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr129", HW_H_CR_GPR129, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr130", HW_H_CR_GPR130, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr131", HW_H_CR_GPR131, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr132", HW_H_CR_GPR132, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr133", HW_H_CR_GPR133, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr134", HW_H_CR_GPR134, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr135", HW_H_CR_GPR135, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr136", HW_H_CR_GPR136, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr137", HW_H_CR_GPR137, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr138", HW_H_CR_GPR138, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr139", HW_H_CR_GPR139, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr140", HW_H_CR_GPR140, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr141", HW_H_CR_GPR141, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr142", HW_H_CR_GPR142, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr143", HW_H_CR_GPR143, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr144", HW_H_CR_GPR144, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr145", HW_H_CR_GPR145, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr146", HW_H_CR_GPR146, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr147", HW_H_CR_GPR147, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr148", HW_H_CR_GPR148, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr149", HW_H_CR_GPR149, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr150", HW_H_CR_GPR150, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr151", HW_H_CR_GPR151, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr152", HW_H_CR_GPR152, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr153", HW_H_CR_GPR153, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr154", HW_H_CR_GPR154, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr155", HW_H_CR_GPR155, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr156", HW_H_CR_GPR156, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr157", HW_H_CR_GPR157, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr158", HW_H_CR_GPR158, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr159", HW_H_CR_GPR159, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr160", HW_H_CR_GPR160, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr161", HW_H_CR_GPR161, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr162", HW_H_CR_GPR162, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr163", HW_H_CR_GPR163, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr164", HW_H_CR_GPR164, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr165", HW_H_CR_GPR165, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr166", HW_H_CR_GPR166, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr167", HW_H_CR_GPR167, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr168", HW_H_CR_GPR168, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr169", HW_H_CR_GPR169, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr170", HW_H_CR_GPR170, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr171", HW_H_CR_GPR171, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr172", HW_H_CR_GPR172, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr173", HW_H_CR_GPR173, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr174", HW_H_CR_GPR174, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr175", HW_H_CR_GPR175, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr176", HW_H_CR_GPR176, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr177", HW_H_CR_GPR177, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr178", HW_H_CR_GPR178, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr179", HW_H_CR_GPR179, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr180", HW_H_CR_GPR180, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr181", HW_H_CR_GPR181, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr182", HW_H_CR_GPR182, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr183", HW_H_CR_GPR183, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr184", HW_H_CR_GPR184, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr185", HW_H_CR_GPR185, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr186", HW_H_CR_GPR186, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr187", HW_H_CR_GPR187, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr188", HW_H_CR_GPR188, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr189", HW_H_CR_GPR189, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr190", HW_H_CR_GPR190, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr191", HW_H_CR_GPR191, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr192", HW_H_CR_GPR192, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr193", HW_H_CR_GPR193, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr194", HW_H_CR_GPR194, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr195", HW_H_CR_GPR195, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr196", HW_H_CR_GPR196, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr197", HW_H_CR_GPR197, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr198", HW_H_CR_GPR198, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr199", HW_H_CR_GPR199, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr200", HW_H_CR_GPR200, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr201", HW_H_CR_GPR201, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr202", HW_H_CR_GPR202, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr203", HW_H_CR_GPR203, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr204", HW_H_CR_GPR204, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr205", HW_H_CR_GPR205, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr206", HW_H_CR_GPR206, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr207", HW_H_CR_GPR207, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr208", HW_H_CR_GPR208, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr209", HW_H_CR_GPR209, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr210", HW_H_CR_GPR210, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr211", HW_H_CR_GPR211, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr212", HW_H_CR_GPR212, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr213", HW_H_CR_GPR213, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr214", HW_H_CR_GPR214, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr215", HW_H_CR_GPR215, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr216", HW_H_CR_GPR216, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr217", HW_H_CR_GPR217, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr218", HW_H_CR_GPR218, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr219", HW_H_CR_GPR219, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr220", HW_H_CR_GPR220, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr221", HW_H_CR_GPR221, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr222", HW_H_CR_GPR222, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr223", HW_H_CR_GPR223, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr224", HW_H_CR_GPR224, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr225", HW_H_CR_GPR225, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr226", HW_H_CR_GPR226, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr227", HW_H_CR_GPR227, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr228", HW_H_CR_GPR228, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr229", HW_H_CR_GPR229, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr230", HW_H_CR_GPR230, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr231", HW_H_CR_GPR231, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr232", HW_H_CR_GPR232, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr233", HW_H_CR_GPR233, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr234", HW_H_CR_GPR234, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr235", HW_H_CR_GPR235, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr236", HW_H_CR_GPR236, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr237", HW_H_CR_GPR237, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr238", HW_H_CR_GPR238, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr239", HW_H_CR_GPR239, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr240", HW_H_CR_GPR240, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr241", HW_H_CR_GPR241, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr242", HW_H_CR_GPR242, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr243", HW_H_CR_GPR243, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr244", HW_H_CR_GPR244, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr245", HW_H_CR_GPR245, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr246", HW_H_CR_GPR246, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr247", HW_H_CR_GPR247, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr248", HW_H_CR_GPR248, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr249", HW_H_CR_GPR249, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr250", HW_H_CR_GPR250, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr251", HW_H_CR_GPR251, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr252", HW_H_CR_GPR252, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr253", HW_H_CR_GPR253, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr254", HW_H_CR_GPR254, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr255", HW_H_CR_GPR255, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr256", HW_H_CR_GPR256, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr257", HW_H_CR_GPR257, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr258", HW_H_CR_GPR258, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr259", HW_H_CR_GPR259, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr260", HW_H_CR_GPR260, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr261", HW_H_CR_GPR261, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr262", HW_H_CR_GPR262, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr263", HW_H_CR_GPR263, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr264", HW_H_CR_GPR264, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr265", HW_H_CR_GPR265, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr266", HW_H_CR_GPR266, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr267", HW_H_CR_GPR267, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr268", HW_H_CR_GPR268, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr269", HW_H_CR_GPR269, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr270", HW_H_CR_GPR270, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr271", HW_H_CR_GPR271, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr272", HW_H_CR_GPR272, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr273", HW_H_CR_GPR273, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr274", HW_H_CR_GPR274, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr275", HW_H_CR_GPR275, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr276", HW_H_CR_GPR276, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr277", HW_H_CR_GPR277, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr278", HW_H_CR_GPR278, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr279", HW_H_CR_GPR279, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr280", HW_H_CR_GPR280, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr281", HW_H_CR_GPR281, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr282", HW_H_CR_GPR282, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr283", HW_H_CR_GPR283, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr284", HW_H_CR_GPR284, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr285", HW_H_CR_GPR285, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr286", HW_H_CR_GPR286, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr287", HW_H_CR_GPR287, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr288", HW_H_CR_GPR288, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr289", HW_H_CR_GPR289, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr290", HW_H_CR_GPR290, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr291", HW_H_CR_GPR291, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr292", HW_H_CR_GPR292, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr293", HW_H_CR_GPR293, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr294", HW_H_CR_GPR294, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr295", HW_H_CR_GPR295, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr296", HW_H_CR_GPR296, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr297", HW_H_CR_GPR297, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr298", HW_H_CR_GPR298, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr299", HW_H_CR_GPR299, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr300", HW_H_CR_GPR300, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr301", HW_H_CR_GPR301, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr302", HW_H_CR_GPR302, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr303", HW_H_CR_GPR303, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr304", HW_H_CR_GPR304, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr305", HW_H_CR_GPR305, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr306", HW_H_CR_GPR306, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr307", HW_H_CR_GPR307, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr308", HW_H_CR_GPR308, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr309", HW_H_CR_GPR309, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr310", HW_H_CR_GPR310, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr311", HW_H_CR_GPR311, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr312", HW_H_CR_GPR312, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr313", HW_H_CR_GPR313, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr314", HW_H_CR_GPR314, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr315", HW_H_CR_GPR315, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr316", HW_H_CR_GPR316, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr317", HW_H_CR_GPR317, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr318", HW_H_CR_GPR318, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr319", HW_H_CR_GPR319, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr320", HW_H_CR_GPR320, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr321", HW_H_CR_GPR321, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr322", HW_H_CR_GPR322, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr323", HW_H_CR_GPR323, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr324", HW_H_CR_GPR324, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr325", HW_H_CR_GPR325, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr326", HW_H_CR_GPR326, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr327", HW_H_CR_GPR327, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr328", HW_H_CR_GPR328, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr329", HW_H_CR_GPR329, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr330", HW_H_CR_GPR330, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr331", HW_H_CR_GPR331, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr332", HW_H_CR_GPR332, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr333", HW_H_CR_GPR333, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr334", HW_H_CR_GPR334, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr335", HW_H_CR_GPR335, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr336", HW_H_CR_GPR336, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr337", HW_H_CR_GPR337, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr338", HW_H_CR_GPR338, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr339", HW_H_CR_GPR339, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr340", HW_H_CR_GPR340, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr341", HW_H_CR_GPR341, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr342", HW_H_CR_GPR342, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr343", HW_H_CR_GPR343, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr344", HW_H_CR_GPR344, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr345", HW_H_CR_GPR345, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr346", HW_H_CR_GPR346, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr347", HW_H_CR_GPR347, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr348", HW_H_CR_GPR348, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr349", HW_H_CR_GPR349, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr350", HW_H_CR_GPR350, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr351", HW_H_CR_GPR351, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr352", HW_H_CR_GPR352, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr353", HW_H_CR_GPR353, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr354", HW_H_CR_GPR354, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr355", HW_H_CR_GPR355, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr356", HW_H_CR_GPR356, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr357", HW_H_CR_GPR357, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr358", HW_H_CR_GPR358, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr359", HW_H_CR_GPR359, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr360", HW_H_CR_GPR360, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr361", HW_H_CR_GPR361, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr362", HW_H_CR_GPR362, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr363", HW_H_CR_GPR363, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr364", HW_H_CR_GPR364, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr365", HW_H_CR_GPR365, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr366", HW_H_CR_GPR366, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr367", HW_H_CR_GPR367, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr368", HW_H_CR_GPR368, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr369", HW_H_CR_GPR369, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr370", HW_H_CR_GPR370, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr371", HW_H_CR_GPR371, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr372", HW_H_CR_GPR372, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr373", HW_H_CR_GPR373, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr374", HW_H_CR_GPR374, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr375", HW_H_CR_GPR375, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr376", HW_H_CR_GPR376, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr377", HW_H_CR_GPR377, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr378", HW_H_CR_GPR378, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr379", HW_H_CR_GPR379, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr380", HW_H_CR_GPR380, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr381", HW_H_CR_GPR381, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr382", HW_H_CR_GPR382, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr383", HW_H_CR_GPR383, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr384", HW_H_CR_GPR384, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr385", HW_H_CR_GPR385, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr386", HW_H_CR_GPR386, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr387", HW_H_CR_GPR387, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr388", HW_H_CR_GPR388, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr389", HW_H_CR_GPR389, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr390", HW_H_CR_GPR390, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr391", HW_H_CR_GPR391, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr392", HW_H_CR_GPR392, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr393", HW_H_CR_GPR393, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr394", HW_H_CR_GPR394, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr395", HW_H_CR_GPR395, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr396", HW_H_CR_GPR396, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr397", HW_H_CR_GPR397, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr398", HW_H_CR_GPR398, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr399", HW_H_CR_GPR399, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr400", HW_H_CR_GPR400, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr401", HW_H_CR_GPR401, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr402", HW_H_CR_GPR402, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr403", HW_H_CR_GPR403, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr404", HW_H_CR_GPR404, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr405", HW_H_CR_GPR405, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr406", HW_H_CR_GPR406, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr407", HW_H_CR_GPR407, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr408", HW_H_CR_GPR408, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr409", HW_H_CR_GPR409, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr410", HW_H_CR_GPR410, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr411", HW_H_CR_GPR411, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr412", HW_H_CR_GPR412, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr413", HW_H_CR_GPR413, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr414", HW_H_CR_GPR414, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr415", HW_H_CR_GPR415, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr416", HW_H_CR_GPR416, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr417", HW_H_CR_GPR417, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr418", HW_H_CR_GPR418, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr419", HW_H_CR_GPR419, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr420", HW_H_CR_GPR420, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr421", HW_H_CR_GPR421, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr422", HW_H_CR_GPR422, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr423", HW_H_CR_GPR423, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr424", HW_H_CR_GPR424, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr425", HW_H_CR_GPR425, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr426", HW_H_CR_GPR426, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr427", HW_H_CR_GPR427, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr428", HW_H_CR_GPR428, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr429", HW_H_CR_GPR429, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr430", HW_H_CR_GPR430, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr431", HW_H_CR_GPR431, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr432", HW_H_CR_GPR432, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr433", HW_H_CR_GPR433, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr434", HW_H_CR_GPR434, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr435", HW_H_CR_GPR435, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr436", HW_H_CR_GPR436, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr437", HW_H_CR_GPR437, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr438", HW_H_CR_GPR438, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr439", HW_H_CR_GPR439, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr440", HW_H_CR_GPR440, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr441", HW_H_CR_GPR441, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr442", HW_H_CR_GPR442, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr443", HW_H_CR_GPR443, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr444", HW_H_CR_GPR444, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr445", HW_H_CR_GPR445, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr446", HW_H_CR_GPR446, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr447", HW_H_CR_GPR447, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr448", HW_H_CR_GPR448, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr449", HW_H_CR_GPR449, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr450", HW_H_CR_GPR450, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr451", HW_H_CR_GPR451, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr452", HW_H_CR_GPR452, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr453", HW_H_CR_GPR453, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr454", HW_H_CR_GPR454, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr455", HW_H_CR_GPR455, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr456", HW_H_CR_GPR456, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr457", HW_H_CR_GPR457, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr458", HW_H_CR_GPR458, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr459", HW_H_CR_GPR459, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr460", HW_H_CR_GPR460, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr461", HW_H_CR_GPR461, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr462", HW_H_CR_GPR462, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr463", HW_H_CR_GPR463, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr464", HW_H_CR_GPR464, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr465", HW_H_CR_GPR465, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr466", HW_H_CR_GPR466, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr467", HW_H_CR_GPR467, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr468", HW_H_CR_GPR468, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr469", HW_H_CR_GPR469, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr470", HW_H_CR_GPR470, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr471", HW_H_CR_GPR471, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr472", HW_H_CR_GPR472, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr473", HW_H_CR_GPR473, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr474", HW_H_CR_GPR474, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr475", HW_H_CR_GPR475, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr476", HW_H_CR_GPR476, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr477", HW_H_CR_GPR477, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr478", HW_H_CR_GPR478, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr479", HW_H_CR_GPR479, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr480", HW_H_CR_GPR480, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr481", HW_H_CR_GPR481, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr482", HW_H_CR_GPR482, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr483", HW_H_CR_GPR483, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr484", HW_H_CR_GPR484, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr485", HW_H_CR_GPR485, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr486", HW_H_CR_GPR486, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr487", HW_H_CR_GPR487, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr488", HW_H_CR_GPR488, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr489", HW_H_CR_GPR489, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr490", HW_H_CR_GPR490, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr491", HW_H_CR_GPR491, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr492", HW_H_CR_GPR492, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr493", HW_H_CR_GPR493, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr494", HW_H_CR_GPR494, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr495", HW_H_CR_GPR495, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr496", HW_H_CR_GPR496, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr497", HW_H_CR_GPR497, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr498", HW_H_CR_GPR498, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr499", HW_H_CR_GPR499, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr500", HW_H_CR_GPR500, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr501", HW_H_CR_GPR501, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr502", HW_H_CR_GPR502, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr503", HW_H_CR_GPR503, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr504", HW_H_CR_GPR504, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr505", HW_H_CR_GPR505, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr506", HW_H_CR_GPR506, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr507", HW_H_CR_GPR507, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr508", HW_H_CR_GPR508, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr509", HW_H_CR_GPR509, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr510", HW_H_CR_GPR510, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-gpr511", HW_H_CR_GPR511, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-csr-psr", HW_H_CSR_PSR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-csr-msr", HW_H_CSR_MSR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-csr-fsr", HW_H_CSR_FSR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-cr-cpuid-ver", HW_H_CR_CPUID_VER, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-cpuid-rev", HW_H_CR_CPUID_REV, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-cpuid-pxb32", HW_H_CR_CPUID_PXB32, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-cpuid-pxb64", HW_H_CR_CPUID_PXB64, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-cpuid-fpx32", HW_H_CR_CPUID_FPX32, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-cpuid-fpx64", HW_H_CR_CPUID_FPX64, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-cpuid-vx64", HW_H_CR_CPUID_VX64, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-ex-ie", HW_H_CR_EX_IE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-ex-oe", HW_H_CR_EX_OE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-ex-ef", HW_H_CR_EX_EF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-dpr-icp", HW_H_CR_DPR_ICP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-dpr-dcp", HW_H_CR_DPR_DCP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-dpr-immup", HW_H_CR_DPR_IMMUP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-dpr-dmmup", HW_H_CR_DPR_DMMUP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-dpr-tmrup", HW_H_CR_DPR_TMRUP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-dpr-picu", HW_H_CR_DPR_PICU, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-dpr-dgbup", HW_H_CR_DPR_DGBUP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-dpr-fpup", HW_H_CR_DPR_FPUP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-dpr-pmup", HW_H_CR_DPR_PMUP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-dpr-pmcup", HW_H_CR_DPR_PMCUP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-cr-fpuc-rm", HW_H_CR_FPUC_RM, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-msr-psr-cf", HW_H_MSR_PSR_CF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-msr-psr-cy", HW_H_MSR_PSR_CY, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-msr-psr-ov", HW_H_MSR_PSR_OV, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-msr-sr-rm", HW_H_MSR_SR_RM, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_NCPU32K_MACH), 0 } } } } },
+  { "h-simm16", HW_H_SIMM16, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-uimm16", HW_H_UIMM16, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { 0, 0, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+/* The instruction field table.  */
+
+#define A(a) (1 << CGEN_IFLD_##a)
+
+const CGEN_IFLD ncpu32k_cgen_ifld_table[] =
+{
+  { NCPU32K_F_NIL, "f-nil", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_ANYOF, "f-anyof", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_OPCODE, "f-opcode", 0, 16, 5, 6, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RD, "f-rd", 0, 16, 10, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RES_RD, "f-res-rd", 0, 16, 10, 5, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RS, "f-rs", 0, 16, 15, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RES_RS, "f-res-rs", 0, 16, 15, 5, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_IMM16, "f-imm16", 16, 16, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_UIMM16, "f-uimm16", 16, 16, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_SIMM16, "f-simm16", 16, 16, 15, 16, { 0|A(SIGN_OPT), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_RES_IMM16, "f-res-imm16", 16, 16, 15, 16, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_REL16, "f-rel16", 16, 16, 15, 16, { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
+  { NCPU32K_F_REL21, "f-rel21", 0, 32, 31, 21, { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
+  { 0, 0, 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+
+/* multi ifield declarations */
+
+
+
+/* multi ifield definitions */
+
+
+/* The operand table.  */
+
+#define A(a) (1 << CGEN_OPERAND_##a)
+#define OPERAND(op) NCPU32K_OPERAND_##op
+
+const CGEN_OPERAND ncpu32k_cgen_operand_table[] =
+{
+/* pc: program counter */
+  { "pc", NCPU32K_OPERAND_PC, HW_H_PC, 0, 0,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_NIL] } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* rs: source operand */
+  { "rs", NCPU32K_OPERAND_RS, HW_H_GPR, 15, 5,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_RS] } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* rd: destination operand */
+  { "rd", NCPU32K_OPERAND_RD, HW_H_GPR, 10, 5,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_RD] } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* simm16: 16-bit signed immediate */
+  { "simm16", NCPU32K_OPERAND_SIMM16, HW_H_SIMM16, 15, 16,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_SIMM16] } },
+    { 0|A(SIGN_OPT), { { { (1<<MACH_BASE), 0 } } } }  },
+/* uimm16: 16-bit unsigned immediate */
+  { "uimm16", NCPU32K_OPERAND_UIMM16, HW_H_UIMM16, 15, 16,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_UIMM16] } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+/* rel16: pc-rel 16 bit address */
+  { "rel16", NCPU32K_OPERAND_REL16, HW_H_IADDR, 15, 16,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_REL16] } },
+    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
+/* rel21: pc-rel 21 bit address */
+  { "rel21", NCPU32K_OPERAND_REL21, HW_H_IADDR, 31, 21,
+    { 0, { (const PTR) &ncpu32k_cgen_ifld_table[NCPU32K_F_REL21] } },
+    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
+/* msr-psr-cy: PSR carry bit */
+  { "msr-psr-cy", NCPU32K_OPERAND_MSR_PSR_CY, HW_H_MSR_PSR_CY, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* msr-psr-ov: PSR overflow bit */
+  { "msr-psr-ov", NCPU32K_OPERAND_MSR_PSR_OV, HW_H_MSR_PSR_OV, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* cr-ex-oe: EX overflow exception enable bit */
+  { "cr-ex-oe", NCPU32K_OPERAND_CR_EX_OE, HW_H_CR_EX_OE, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* sentinel */
+  { 0, 0, 0, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+/* The instruction table.  */
+
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+#define A(a) (1 << CGEN_INSN_##a)
+
+static const CGEN_IBASE ncpu32k_cgen_insn_table[MAX_INSNS] =
+{
+  /* Special null first entry.
+     A `num' value of zero is thus invalid.
+     Also, the special `invalid' insn resides here.  */
+  { 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+/* nop */
+  {
+    NCPU32K_INSN_NOP, "nop", "nop", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mov $rd,$rs */
+  {
+    NCPU32K_INSN_MOV, "mov", "mov", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mov $rd,$uimm16 */
+  {
+    NCPU32K_INSN_MOV_I, "mov.i", "mov", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mov hi($rd),$rs */
+  {
+    NCPU32K_INSN_MOVH, "movh", "mov", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* and $rd,$rs */
+  {
+    NCPU32K_INSN_AND, "and", "and", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* and $rd,$rs,$uimm16 */
+  {
+    NCPU32K_INSN_AND_I, "and.i", "and", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* or $rd,$rs */
+  {
+    NCPU32K_INSN_OR, "or", "or", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* or $rd,$rs,$uimm16 */
+  {
+    NCPU32K_INSN_OR_I, "or.i", "or", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* xor $rd,$rs */
+  {
+    NCPU32K_INSN_XOR, "xor", "xor", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* xor $rd,$rs,$simm16 */
+  {
+    NCPU32K_INSN_XOR_I, "xor.i", "xor", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lsl $rd,$rs */
+  {
+    NCPU32K_INSN_LSL, "lsl", "lsl", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lsl $rd,$rs,${uimm16} */
+  {
+    NCPU32K_INSN_LSL_I, "lsl.i", "lsl", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lsr $rd,$rs */
+  {
+    NCPU32K_INSN_LSR, "lsr", "lsr", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* lsr $rd,$rs,${uimm16} */
+  {
+    NCPU32K_INSN_LSR_I, "lsr.i", "lsr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* asr $rd,$rs */
+  {
+    NCPU32K_INSN_ASR, "asr", "asr", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* asr $rd,$rs,${uimm16} */
+  {
+    NCPU32K_INSN_ASR_I, "asr.i", "asr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* add $rd,$rs */
+  {
+    NCPU32K_INSN_ADD, "add", "add", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* add $rd,$rs,$simm16 */
+  {
+    NCPU32K_INSN_ADD_I, "add.i", "add", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* sub $rd,$rs */
+  {
+    NCPU32K_INSN_SUB, "sub", "sub", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mul $rd,$rs */
+  {
+    NCPU32K_INSN_MUL, "mul", "mul", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mulu $rd,$rs */
+  {
+    NCPU32K_INSN_MULU, "mulu", "mulu", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* div $rd,$rs */
+  {
+    NCPU32K_INSN_DIV, "div", "div", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* divu $rd,$rs */
+  {
+    NCPU32K_INSN_DIVU, "divu", "divu", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mod $rd,$rs */
+  {
+    NCPU32K_INSN_MOD, "mod", "mod", 16,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* mov hi($rd),${uimm16} */
+  {
+    NCPU32K_INSN_MHI, "mhi", "mov", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* rsmr $rd,$rs,${uimm16} */
+  {
+    NCPU32K_INSN_RSMR, "rsmr", "rsmr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* wsmr $rd,$rs,${uimm16} */
+  {
+    NCPU32K_INSN_WSMR, "wsmr", "wsmr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* jmp $rd,$rs */
+  {
+    NCPU32K_INSN_JMP, "jmp", "jmp", 16,
+    { 0|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* jmp $rd,${rel21} */
+  {
+    NCPU32K_INSN_JMP_I, "jmp.i", "jmp", 32,
+    { 0|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* beq $rd,$rs,${rel16} */
+  {
+    NCPU32K_INSN_BEQ, "beq", "beq", 32,
+    { 0|A(COND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bne $rd,$rs,${rel16} */
+  {
+    NCPU32K_INSN_BNE, "bne", "bne", 32,
+    { 0|A(COND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* bgt $rd,$rs,${rel16} */
+  {
+    NCPU32K_INSN_BGT, "bgt", "bgt", 32,
+    { 0|A(COND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ble $rd,$rs,${rel16} */
+  {
+    NCPU32K_INSN_BLE, "ble", "ble", 32,
+    { 0|A(COND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ld $rd,@byte,${simm16}($rs) */
+  {
+    NCPU32K_INSN_LDB, "ldb", "ld", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ldu $rd,@byte,${simm16}($rs) */
+  {
+    NCPU32K_INSN_LDBU, "ldbu", "ldu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ld $rd,@hword,${simm16}($rs) */
+  {
+    NCPU32K_INSN_LDH, "ldh", "ld", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ldu $rd,@hword,${simm16}($rs) */
+  {
+    NCPU32K_INSN_LDHU, "ldhu", "ldu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ldu $rd,@word,${simm16}($rs) */
+  {
+    NCPU32K_INSN_LDWU, "ldwu", "ldu", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* st @byte,${simm16}($rd),$rs */
+  {
+    NCPU32K_INSN_STB, "stb", "st", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* st @hword,${simm16}($rd),$rs */
+  {
+    NCPU32K_INSN_STH, "sth", "st", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* st @word,${simm16}($rd),$rs */
+  {
+    NCPU32K_INSN_STW, "stw", "st", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* exc ${uimm16} */
+  {
+    NCPU32K_INSN_EXC, "exc", "exc", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* barr */
+  {
+    NCPU32K_INSN_BARR, "barr", "barr", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* ret */
+  {
+    NCPU32K_INSN_RET, "ret", "ret", 32,
+    { 0|A(FORCED_CTI), { { { (1<<MACH_BASE), 0 } } } }
+  },
+/* pcrp $rd,${rel21} */
+  {
+    NCPU32K_INSN_PCRP, "pcrp", "pcrp", 32,
+    { 0, { { { (1<<MACH_BASE), 0 } } } }
+  },
+};
+
+#undef OP
+#undef A
+
+/* Initialize anything needed to be done once, before any cpu_open call.  */
+
+static void
+init_tables (void)
+{
+}
+
+static const CGEN_MACH * lookup_mach_via_bfd_name (const CGEN_MACH *, const char *);
+static void build_hw_table      (CGEN_CPU_TABLE *);
+static void build_ifield_table  (CGEN_CPU_TABLE *);
+static void build_operand_table (CGEN_CPU_TABLE *);
+static void build_insn_table    (CGEN_CPU_TABLE *);
+static void ncpu32k_cgen_rebuild_tables (CGEN_CPU_TABLE *);
+
+/* Subroutine of ncpu32k_cgen_cpu_open to look up a mach via its bfd name.  */
+
+static const CGEN_MACH *
+lookup_mach_via_bfd_name (const CGEN_MACH *table, const char *name)
+{
+  while (table->name)
+    {
+      if (strcmp (name, table->bfd_name) == 0)
+	return table;
+      ++table;
+    }
+  return NULL;
+}
+
+/* Subroutine of ncpu32k_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_hw_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  int machs = cd->machs;
+  const CGEN_HW_ENTRY *init = & ncpu32k_cgen_hw_table[0];
+  /* MAX_HW is only an upper bound on the number of selected entries.
+     However each entry is indexed by it's enum so there can be holes in
+     the table.  */
+  const CGEN_HW_ENTRY **selected =
+    (const CGEN_HW_ENTRY **) xmalloc (MAX_HW * sizeof (CGEN_HW_ENTRY *));
+
+  cd->hw_table.init_entries = init;
+  cd->hw_table.entry_size = sizeof (CGEN_HW_ENTRY);
+  memset (selected, 0, MAX_HW * sizeof (CGEN_HW_ENTRY *));
+  /* ??? For now we just use machs to determine which ones we want.  */
+  for (i = 0; init[i].name != NULL; ++i)
+    if (CGEN_HW_ATTR_VALUE (&init[i], CGEN_HW_MACH)
+	& machs)
+      selected[init[i].type] = &init[i];
+  cd->hw_table.entries = selected;
+  cd->hw_table.num_entries = MAX_HW;
+}
+
+/* Subroutine of ncpu32k_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_ifield_table (CGEN_CPU_TABLE *cd)
+{
+  cd->ifld_table = & ncpu32k_cgen_ifld_table[0];
+}
+
+/* Subroutine of ncpu32k_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_operand_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  int machs = cd->machs;
+  const CGEN_OPERAND *init = & ncpu32k_cgen_operand_table[0];
+  /* MAX_OPERANDS is only an upper bound on the number of selected entries.
+     However each entry is indexed by it's enum so there can be holes in
+     the table.  */
+  const CGEN_OPERAND **selected = xmalloc (MAX_OPERANDS * sizeof (* selected));
+
+  cd->operand_table.init_entries = init;
+  cd->operand_table.entry_size = sizeof (CGEN_OPERAND);
+  memset (selected, 0, MAX_OPERANDS * sizeof (CGEN_OPERAND *));
+  /* ??? For now we just use mach to determine which ones we want.  */
+  for (i = 0; init[i].name != NULL; ++i)
+    if (CGEN_OPERAND_ATTR_VALUE (&init[i], CGEN_OPERAND_MACH)
+	& machs)
+      selected[init[i].type] = &init[i];
+  cd->operand_table.entries = selected;
+  cd->operand_table.num_entries = MAX_OPERANDS;
+}
+
+/* Subroutine of ncpu32k_cgen_cpu_open to build the hardware table.
+   ??? This could leave out insns not supported by the specified mach/isa,
+   but that would cause errors like "foo only supported by bar" to become
+   "unknown insn", so for now we include all insns and require the app to
+   do the checking later.
+   ??? On the other hand, parsing of such insns may require their hardware or
+   operand elements to be in the table [which they mightn't be].  */
+
+static void
+build_insn_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  const CGEN_IBASE *ib = & ncpu32k_cgen_insn_table[0];
+  CGEN_INSN *insns = xmalloc (MAX_INSNS * sizeof (CGEN_INSN));
+
+  memset (insns, 0, MAX_INSNS * sizeof (CGEN_INSN));
+  for (i = 0; i < MAX_INSNS; ++i)
+    insns[i].base = &ib[i];
+  cd->insn_table.init_entries = insns;
+  cd->insn_table.entry_size = sizeof (CGEN_IBASE);
+  cd->insn_table.num_init_entries = MAX_INSNS;
+}
+
+/* Subroutine of ncpu32k_cgen_cpu_open to rebuild the tables.  */
+
+static void
+ncpu32k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  CGEN_BITSET *isas = cd->isas;
+  unsigned int machs = cd->machs;
+
+  cd->int_insn_p = CGEN_INT_INSN_P;
+
+  /* Data derived from the isa spec.  */
+#define UNSET (CGEN_SIZE_UNKNOWN + 1)
+  cd->default_insn_bitsize = UNSET;
+  cd->base_insn_bitsize = UNSET;
+  cd->min_insn_bitsize = 65535; /* Some ridiculously big number.  */
+  cd->max_insn_bitsize = 0;
+  for (i = 0; i < MAX_ISAS; ++i)
+    if (cgen_bitset_contains (isas, i))
+      {
+	const CGEN_ISA *isa = & ncpu32k_cgen_isa_table[i];
+
+	/* Default insn sizes of all selected isas must be
+	   equal or we set the result to 0, meaning "unknown".  */
+	if (cd->default_insn_bitsize == UNSET)
+	  cd->default_insn_bitsize = isa->default_insn_bitsize;
+	else if (isa->default_insn_bitsize == cd->default_insn_bitsize)
+	  ; /* This is ok.  */
+	else
+	  cd->default_insn_bitsize = CGEN_SIZE_UNKNOWN;
+
+	/* Base insn sizes of all selected isas must be equal
+	   or we set the result to 0, meaning "unknown".  */
+	if (cd->base_insn_bitsize == UNSET)
+	  cd->base_insn_bitsize = isa->base_insn_bitsize;
+	else if (isa->base_insn_bitsize == cd->base_insn_bitsize)
+	  ; /* This is ok.  */
+	else
+	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
+
+	/* Set min,max insn sizes.  */
+	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	  cd->min_insn_bitsize = isa->min_insn_bitsize;
+	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+      }
+
+  /* Data derived from the mach spec.  */
+  for (i = 0; i < MAX_MACHS; ++i)
+    if (((1 << i) & machs) != 0)
+      {
+	const CGEN_MACH *mach = & ncpu32k_cgen_mach_table[i];
+
+	if (mach->insn_chunk_bitsize != 0)
+	{
+	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	    {
+	      fprintf (stderr, "ncpu32k_cgen_rebuild_tables: conflicting insn-chunk-bitsize values: `%d' vs. `%d'\n",
+		       cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
+	      abort ();
+	    }
+
+ 	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
+	}
+      }
+
+  /* Determine which hw elements are used by MACH.  */
+  build_hw_table (cd);
+
+  /* Build the ifield table.  */
+  build_ifield_table (cd);
+
+  /* Determine which operands are used by MACH/ISA.  */
+  build_operand_table (cd);
+
+  /* Build the instruction table.  */
+  build_insn_table (cd);
+}
+
+/* Initialize a cpu table and return a descriptor.
+   It's much like opening a file, and must be the first function called.
+   The arguments are a set of (type/value) pairs, terminated with
+   CGEN_CPU_OPEN_END.
+
+   Currently supported values:
+   CGEN_CPU_OPEN_ISAS:    bitmap of values in enum isa_attr
+   CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr
+   CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name
+   CGEN_CPU_OPEN_ENDIAN:  specify endian choice
+   CGEN_CPU_OPEN_END:     terminates arguments
+
+   ??? Simultaneous multiple isas might not make sense, but it's not (yet)
+   precluded.  */
+
+CGEN_CPU_DESC
+ncpu32k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
+{
+  CGEN_CPU_TABLE *cd = (CGEN_CPU_TABLE *) xmalloc (sizeof (CGEN_CPU_TABLE));
+  static int init_p;
+  CGEN_BITSET *isas = 0;  /* 0 = "unspecified" */
+  unsigned int machs = 0; /* 0 = "unspecified" */
+  enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;
+  va_list ap;
+
+  if (! init_p)
+    {
+      init_tables ();
+      init_p = 1;
+    }
+
+  memset (cd, 0, sizeof (*cd));
+
+  va_start (ap, arg_type);
+  while (arg_type != CGEN_CPU_OPEN_END)
+    {
+      switch (arg_type)
+	{
+	case CGEN_CPU_OPEN_ISAS :
+	  isas = va_arg (ap, CGEN_BITSET *);
+	  break;
+	case CGEN_CPU_OPEN_MACHS :
+	  machs = va_arg (ap, unsigned int);
+	  break;
+	case CGEN_CPU_OPEN_BFDMACH :
+	  {
+	    const char *name = va_arg (ap, const char *);
+	    const CGEN_MACH *mach =
+	      lookup_mach_via_bfd_name (ncpu32k_cgen_mach_table, name);
+
+	    if (mach != NULL)
+	      machs |= 1 << mach->num;
+	    break;
+	  }
+	case CGEN_CPU_OPEN_ENDIAN :
+	  endian = va_arg (ap, enum cgen_endian);
+	  break;
+	default :
+	  fprintf (stderr, "ncpu32k_cgen_cpu_open: unsupported argument `%d'\n",
+		   arg_type);
+	  abort (); /* ??? return NULL? */
+	}
+      arg_type = va_arg (ap, enum cgen_cpu_open_arg);
+    }
+  va_end (ap);
+
+  /* Mach unspecified means "all".  */
+  if (machs == 0)
+    machs = (1 << MAX_MACHS) - 1;
+  /* Base mach is always selected.  */
+  machs |= 1;
+  if (endian == CGEN_ENDIAN_UNKNOWN)
+    {
+      /* ??? If target has only one, could have a default.  */
+      fprintf (stderr, "ncpu32k_cgen_cpu_open: no endianness specified\n");
+      abort ();
+    }
+
+  cd->isas = cgen_bitset_copy (isas);
+  cd->machs = machs;
+  cd->endian = endian;
+  /* FIXME: for the sparc case we can determine insn-endianness statically.
+     The worry here is where both data and insn endian can be independently
+     chosen, in which case this function will need another argument.
+     Actually, will want to allow for more arguments in the future anyway.  */
+  cd->insn_endian = endian;
+
+  /* Table (re)builder.  */
+  cd->rebuild_tables = ncpu32k_cgen_rebuild_tables;
+  ncpu32k_cgen_rebuild_tables (cd);
+
+  /* Default to not allowing signed overflow.  */
+  cd->signed_overflow_ok_p = 0;
+
+  return (CGEN_CPU_DESC) cd;
+}
+
+/* Cover fn to ncpu32k_cgen_cpu_open to handle the simple case of 1 isa, 1 mach.
+   MACH_NAME is the bfd name of the mach.  */
+
+CGEN_CPU_DESC
+ncpu32k_cgen_cpu_open_1 (const char *mach_name, enum cgen_endian endian)
+{
+  return ncpu32k_cgen_cpu_open (CGEN_CPU_OPEN_BFDMACH, mach_name,
+			       CGEN_CPU_OPEN_ENDIAN, endian,
+			       CGEN_CPU_OPEN_END);
+}
+
+/* Close a cpu table.
+   ??? This can live in a machine independent file, but there's currently
+   no place to put this file (there's no libcgen).  libopcodes is the wrong
+   place as some simulator ports use this but they don't use libopcodes.  */
+
+void
+ncpu32k_cgen_cpu_close (CGEN_CPU_DESC cd)
+{
+  unsigned int i;
+  const CGEN_INSN *insns;
+
+  if (cd->macro_insn_table.init_entries)
+    {
+      insns = cd->macro_insn_table.init_entries;
+      for (i = 0; i < cd->macro_insn_table.num_init_entries; ++i, ++insns)
+	if (CGEN_INSN_RX ((insns)))
+	  regfree (CGEN_INSN_RX (insns));
+    }
+
+  if (cd->insn_table.init_entries)
+    {
+      insns = cd->insn_table.init_entries;
+      for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
+	if (CGEN_INSN_RX (insns))
+	  regfree (CGEN_INSN_RX (insns));
+    }
+
+  if (cd->macro_insn_table.init_entries)
+    free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
+
+  if (cd->insn_table.init_entries)
+    free ((CGEN_INSN *) cd->insn_table.init_entries);
+
+  if (cd->hw_table.entries)
+    free ((CGEN_HW_ENTRY *) cd->hw_table.entries);
+
+  if (cd->operand_table.entries)
+    free ((CGEN_HW_ENTRY *) cd->operand_table.entries);
+
+  free (cd);
+}
+
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-desc.h binutils-ncpu32k-2.32/opcodes/ncpu32k-desc.h
--- binutils-2.32/opcodes/ncpu32k-desc.h	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-desc.h	2019-08-12 18:41:23.405368585 +0800
@@ -0,0 +1,567 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* CPU data header for ncpu32k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef NCPU32K_CPU_H
+#define NCPU32K_CPU_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CGEN_ARCH ncpu32k
+
+/* Given symbol S, return ncpu32k_cgen_<S>.  */
+#define CGEN_SYM(s) ncpu32k##_cgen_##s
+
+
+/* Selected cpu families.  */
+#define HAVE_CPU_NCPU32K
+
+#define CGEN_INSN_LSB0_P 1
+
+/* Minimum size of any insn (in bytes).  */
+#define CGEN_MIN_INSN_SIZE 2
+
+/* Maximum size of any insn (in bytes).  */
+#define CGEN_MAX_INSN_SIZE 4
+
+#define CGEN_INT_INSN_P 1
+
+/* Maximum number of syntax elements in an instruction.  */
+#define CGEN_ACTUAL_MAX_SYNTAX_ELEMENTS 19
+
+/* CGEN_MNEMONIC_OPERANDS is defined if mnemonics have operands.
+   e.g. In "b,a foo" the ",a" is an operand.  If mnemonics have operands
+   we can't hash on everything up to the space.  */
+#define CGEN_MNEMONIC_OPERANDS
+
+/* Maximum number of fields in an instruction.  */
+#define CGEN_ACTUAL_MAX_IFMT_OPERANDS 4
+
+/* Enums.  */
+
+/* Enum declaration for Exception numbers.  */
+typedef enum except_number {
+  EXCEPT_ERST = 1, EXCEPT_EBUS = 2, EXCEPT_EINSN = 3, EXCEPT_EEXC = 4
+ , EXCEPT_EIPF = 5, EXCEPT_EDPF = 6, EXCEPT_EITLB = 7, EXCEPT_EDTLB = 8
+ , EXCEPT_EIRQ = 9, EXCEPT_EOVERFLOW = 10, EXCEPT_EFPU = 11, EXCEPT_EDALIGN = 12
+} EXCEPT_NUMBER;
+
+/* Enum declaration for CPU status management register groups.  */
+typedef enum smr_groups {
+  SMR_ENTRY_CR, SMR_ENTRY_CSR
+} SMR_GROUPS;
+
+/* Enum declaration for CPU status management register indicies.  */
+typedef enum smr_reg_indices {
+  SMR_INDEX_CR_CPUID = 0, SMR_INDEX_CR_EX = 1, SMR_INDEX_CR_EB = 2, SMR_INDEX_CR_EPC = 3
+ , SMR_INDEX_CR_ECSR = 4, SMR_INDEX_CR_DPR = 5, SMR_INDEX_CR_ICC = 6, SMR_INDEX_CR_DCC = 7
+ , SMR_INDEX_CR_IMMUC = 8, SMR_INDEX_CR_DMMUC = 9, SMR_INDEX_CR_TRMUC = 10, SMR_INDEX_CR_PICUC = 11
+ , SMR_INDEX_CR_DBGUC = 12, SMR_INDEX_CR_FPUC = 13, SMR_INDEX_CR_PMUC = 14, SMR_INDEX_CR_PMCUC = 15
+ , SMR_INDEX_CR_GPR0 = 1024, SMR_INDEX_CR_GPR1 = 1025, SMR_INDEX_CR_GPR2 = 1026, SMR_INDEX_CR_GPR3 = 1027
+ , SMR_INDEX_CR_GPR4 = 1028, SMR_INDEX_CR_GPR5 = 1029, SMR_INDEX_CR_GPR6 = 1030, SMR_INDEX_CR_GPR7 = 1031
+ , SMR_INDEX_CR_GPR8 = 1032, SMR_INDEX_CR_GPR9 = 1033, SMR_INDEX_CR_GPR10 = 1034, SMR_INDEX_CR_GPR11 = 1035
+ , SMR_INDEX_CR_GPR12 = 1036, SMR_INDEX_CR_GPR13 = 1037, SMR_INDEX_CR_GPR14 = 1038, SMR_INDEX_CR_GPR15 = 1039
+ , SMR_INDEX_CR_GPR16 = 1040, SMR_INDEX_CR_GPR17 = 1041, SMR_INDEX_CR_GPR18 = 1042, SMR_INDEX_CR_GPR19 = 1043
+ , SMR_INDEX_CR_GPR20 = 1044, SMR_INDEX_CR_GPR21 = 1045, SMR_INDEX_CR_GPR22 = 1046, SMR_INDEX_CR_GPR23 = 1047
+ , SMR_INDEX_CR_GPR24 = 1048, SMR_INDEX_CR_GPR25 = 1049, SMR_INDEX_CR_GPR26 = 1050, SMR_INDEX_CR_GPR27 = 1051
+ , SMR_INDEX_CR_GPR28 = 1052, SMR_INDEX_CR_GPR29 = 1053, SMR_INDEX_CR_GPR30 = 1054, SMR_INDEX_CR_GPR31 = 1055
+ , SMR_INDEX_CR_GPR32 = 1056, SMR_INDEX_CR_GPR33 = 1057, SMR_INDEX_CR_GPR34 = 1058, SMR_INDEX_CR_GPR35 = 1059
+ , SMR_INDEX_CR_GPR36 = 1060, SMR_INDEX_CR_GPR37 = 1061, SMR_INDEX_CR_GPR38 = 1062, SMR_INDEX_CR_GPR39 = 1063
+ , SMR_INDEX_CR_GPR40 = 1064, SMR_INDEX_CR_GPR41 = 1065, SMR_INDEX_CR_GPR42 = 1066, SMR_INDEX_CR_GPR43 = 1067
+ , SMR_INDEX_CR_GPR44 = 1068, SMR_INDEX_CR_GPR45 = 1069, SMR_INDEX_CR_GPR46 = 1070, SMR_INDEX_CR_GPR47 = 1071
+ , SMR_INDEX_CR_GPR48 = 1072, SMR_INDEX_CR_GPR49 = 1073, SMR_INDEX_CR_GPR50 = 1074, SMR_INDEX_CR_GPR51 = 1075
+ , SMR_INDEX_CR_GPR52 = 1076, SMR_INDEX_CR_GPR53 = 1077, SMR_INDEX_CR_GPR54 = 1078, SMR_INDEX_CR_GPR55 = 1079
+ , SMR_INDEX_CR_GPR56 = 1080, SMR_INDEX_CR_GPR57 = 1081, SMR_INDEX_CR_GPR58 = 1082, SMR_INDEX_CR_GPR59 = 1083
+ , SMR_INDEX_CR_GPR60 = 1084, SMR_INDEX_CR_GPR61 = 1085, SMR_INDEX_CR_GPR62 = 1086, SMR_INDEX_CR_GPR63 = 1087
+ , SMR_INDEX_CR_GPR64 = 1088, SMR_INDEX_CR_GPR65 = 1089, SMR_INDEX_CR_GPR66 = 1090, SMR_INDEX_CR_GPR67 = 1091
+ , SMR_INDEX_CR_GPR68 = 1092, SMR_INDEX_CR_GPR69 = 1093, SMR_INDEX_CR_GPR70 = 1094, SMR_INDEX_CR_GPR71 = 1095
+ , SMR_INDEX_CR_GPR72 = 1096, SMR_INDEX_CR_GPR73 = 1097, SMR_INDEX_CR_GPR74 = 1098, SMR_INDEX_CR_GPR75 = 1099
+ , SMR_INDEX_CR_GPR76 = 1100, SMR_INDEX_CR_GPR77 = 1101, SMR_INDEX_CR_GPR78 = 1102, SMR_INDEX_CR_GPR79 = 1103
+ , SMR_INDEX_CR_GPR80 = 1104, SMR_INDEX_CR_GPR81 = 1105, SMR_INDEX_CR_GPR82 = 1106, SMR_INDEX_CR_GPR83 = 1107
+ , SMR_INDEX_CR_GPR84 = 1108, SMR_INDEX_CR_GPR85 = 1109, SMR_INDEX_CR_GPR86 = 1110, SMR_INDEX_CR_GPR87 = 1111
+ , SMR_INDEX_CR_GPR88 = 1112, SMR_INDEX_CR_GPR89 = 1113, SMR_INDEX_CR_GPR90 = 1114, SMR_INDEX_CR_GPR91 = 1115
+ , SMR_INDEX_CR_GPR92 = 1116, SMR_INDEX_CR_GPR93 = 1117, SMR_INDEX_CR_GPR94 = 1118, SMR_INDEX_CR_GPR95 = 1119
+ , SMR_INDEX_CR_GPR96 = 1120, SMR_INDEX_CR_GPR97 = 1121, SMR_INDEX_CR_GPR98 = 1122, SMR_INDEX_CR_GPR99 = 1123
+ , SMR_INDEX_CR_GPR100 = 1124, SMR_INDEX_CR_GPR101 = 1125, SMR_INDEX_CR_GPR102 = 1126, SMR_INDEX_CR_GPR103 = 1127
+ , SMR_INDEX_CR_GPR104 = 1128, SMR_INDEX_CR_GPR105 = 1129, SMR_INDEX_CR_GPR106 = 1130, SMR_INDEX_CR_GPR107 = 1131
+ , SMR_INDEX_CR_GPR108 = 1132, SMR_INDEX_CR_GPR109 = 1133, SMR_INDEX_CR_GPR110 = 1134, SMR_INDEX_CR_GPR111 = 1135
+ , SMR_INDEX_CR_GPR112 = 1136, SMR_INDEX_CR_GPR113 = 1137, SMR_INDEX_CR_GPR114 = 1138, SMR_INDEX_CR_GPR115 = 1139
+ , SMR_INDEX_CR_GPR116 = 1140, SMR_INDEX_CR_GPR117 = 1141, SMR_INDEX_CR_GPR118 = 1142, SMR_INDEX_CR_GPR119 = 1143
+ , SMR_INDEX_CR_GPR120 = 1144, SMR_INDEX_CR_GPR121 = 1145, SMR_INDEX_CR_GPR122 = 1146, SMR_INDEX_CR_GPR123 = 1147
+ , SMR_INDEX_CR_GPR124 = 1148, SMR_INDEX_CR_GPR125 = 1149, SMR_INDEX_CR_GPR126 = 1150, SMR_INDEX_CR_GPR127 = 1151
+ , SMR_INDEX_CR_GPR128 = 1152, SMR_INDEX_CR_GPR129 = 1153, SMR_INDEX_CR_GPR130 = 1154, SMR_INDEX_CR_GPR131 = 1155
+ , SMR_INDEX_CR_GPR132 = 1156, SMR_INDEX_CR_GPR133 = 1157, SMR_INDEX_CR_GPR134 = 1158, SMR_INDEX_CR_GPR135 = 1159
+ , SMR_INDEX_CR_GPR136 = 1160, SMR_INDEX_CR_GPR137 = 1161, SMR_INDEX_CR_GPR138 = 1162, SMR_INDEX_CR_GPR139 = 1163
+ , SMR_INDEX_CR_GPR140 = 1164, SMR_INDEX_CR_GPR141 = 1165, SMR_INDEX_CR_GPR142 = 1166, SMR_INDEX_CR_GPR143 = 1167
+ , SMR_INDEX_CR_GPR144 = 1168, SMR_INDEX_CR_GPR145 = 1169, SMR_INDEX_CR_GPR146 = 1170, SMR_INDEX_CR_GPR147 = 1171
+ , SMR_INDEX_CR_GPR148 = 1172, SMR_INDEX_CR_GPR149 = 1173, SMR_INDEX_CR_GPR150 = 1174, SMR_INDEX_CR_GPR151 = 1175
+ , SMR_INDEX_CR_GPR152 = 1176, SMR_INDEX_CR_GPR153 = 1177, SMR_INDEX_CR_GPR154 = 1178, SMR_INDEX_CR_GPR155 = 1179
+ , SMR_INDEX_CR_GPR156 = 1180, SMR_INDEX_CR_GPR157 = 1181, SMR_INDEX_CR_GPR158 = 1182, SMR_INDEX_CR_GPR159 = 1183
+ , SMR_INDEX_CR_GPR160 = 1184, SMR_INDEX_CR_GPR161 = 1185, SMR_INDEX_CR_GPR162 = 1186, SMR_INDEX_CR_GPR163 = 1187
+ , SMR_INDEX_CR_GPR164 = 1188, SMR_INDEX_CR_GPR165 = 1189, SMR_INDEX_CR_GPR166 = 1190, SMR_INDEX_CR_GPR167 = 1191
+ , SMR_INDEX_CR_GPR168 = 1192, SMR_INDEX_CR_GPR169 = 1193, SMR_INDEX_CR_GPR170 = 1194, SMR_INDEX_CR_GPR171 = 1195
+ , SMR_INDEX_CR_GPR172 = 1196, SMR_INDEX_CR_GPR173 = 1197, SMR_INDEX_CR_GPR174 = 1198, SMR_INDEX_CR_GPR175 = 1199
+ , SMR_INDEX_CR_GPR176 = 1200, SMR_INDEX_CR_GPR177 = 1201, SMR_INDEX_CR_GPR178 = 1202, SMR_INDEX_CR_GPR179 = 1203
+ , SMR_INDEX_CR_GPR180 = 1204, SMR_INDEX_CR_GPR181 = 1205, SMR_INDEX_CR_GPR182 = 1206, SMR_INDEX_CR_GPR183 = 1207
+ , SMR_INDEX_CR_GPR184 = 1208, SMR_INDEX_CR_GPR185 = 1209, SMR_INDEX_CR_GPR186 = 1210, SMR_INDEX_CR_GPR187 = 1211
+ , SMR_INDEX_CR_GPR188 = 1212, SMR_INDEX_CR_GPR189 = 1213, SMR_INDEX_CR_GPR190 = 1214, SMR_INDEX_CR_GPR191 = 1215
+ , SMR_INDEX_CR_GPR192 = 1216, SMR_INDEX_CR_GPR193 = 1217, SMR_INDEX_CR_GPR194 = 1218, SMR_INDEX_CR_GPR195 = 1219
+ , SMR_INDEX_CR_GPR196 = 1220, SMR_INDEX_CR_GPR197 = 1221, SMR_INDEX_CR_GPR198 = 1222, SMR_INDEX_CR_GPR199 = 1223
+ , SMR_INDEX_CR_GPR200 = 1224, SMR_INDEX_CR_GPR201 = 1225, SMR_INDEX_CR_GPR202 = 1226, SMR_INDEX_CR_GPR203 = 1227
+ , SMR_INDEX_CR_GPR204 = 1228, SMR_INDEX_CR_GPR205 = 1229, SMR_INDEX_CR_GPR206 = 1230, SMR_INDEX_CR_GPR207 = 1231
+ , SMR_INDEX_CR_GPR208 = 1232, SMR_INDEX_CR_GPR209 = 1233, SMR_INDEX_CR_GPR210 = 1234, SMR_INDEX_CR_GPR211 = 1235
+ , SMR_INDEX_CR_GPR212 = 1236, SMR_INDEX_CR_GPR213 = 1237, SMR_INDEX_CR_GPR214 = 1238, SMR_INDEX_CR_GPR215 = 1239
+ , SMR_INDEX_CR_GPR216 = 1240, SMR_INDEX_CR_GPR217 = 1241, SMR_INDEX_CR_GPR218 = 1242, SMR_INDEX_CR_GPR219 = 1243
+ , SMR_INDEX_CR_GPR220 = 1244, SMR_INDEX_CR_GPR221 = 1245, SMR_INDEX_CR_GPR222 = 1246, SMR_INDEX_CR_GPR223 = 1247
+ , SMR_INDEX_CR_GPR224 = 1248, SMR_INDEX_CR_GPR225 = 1249, SMR_INDEX_CR_GPR226 = 1250, SMR_INDEX_CR_GPR227 = 1251
+ , SMR_INDEX_CR_GPR228 = 1252, SMR_INDEX_CR_GPR229 = 1253, SMR_INDEX_CR_GPR230 = 1254, SMR_INDEX_CR_GPR231 = 1255
+ , SMR_INDEX_CR_GPR232 = 1256, SMR_INDEX_CR_GPR233 = 1257, SMR_INDEX_CR_GPR234 = 1258, SMR_INDEX_CR_GPR235 = 1259
+ , SMR_INDEX_CR_GPR236 = 1260, SMR_INDEX_CR_GPR237 = 1261, SMR_INDEX_CR_GPR238 = 1262, SMR_INDEX_CR_GPR239 = 1263
+ , SMR_INDEX_CR_GPR240 = 1264, SMR_INDEX_CR_GPR241 = 1265, SMR_INDEX_CR_GPR242 = 1266, SMR_INDEX_CR_GPR243 = 1267
+ , SMR_INDEX_CR_GPR244 = 1268, SMR_INDEX_CR_GPR245 = 1269, SMR_INDEX_CR_GPR246 = 1270, SMR_INDEX_CR_GPR247 = 1271
+ , SMR_INDEX_CR_GPR248 = 1272, SMR_INDEX_CR_GPR249 = 1273, SMR_INDEX_CR_GPR250 = 1274, SMR_INDEX_CR_GPR251 = 1275
+ , SMR_INDEX_CR_GPR252 = 1276, SMR_INDEX_CR_GPR253 = 1277, SMR_INDEX_CR_GPR254 = 1278, SMR_INDEX_CR_GPR255 = 1279
+ , SMR_INDEX_CR_GPR256 = 1280, SMR_INDEX_CR_GPR257 = 1281, SMR_INDEX_CR_GPR258 = 1282, SMR_INDEX_CR_GPR259 = 1283
+ , SMR_INDEX_CR_GPR260 = 1284, SMR_INDEX_CR_GPR261 = 1285, SMR_INDEX_CR_GPR262 = 1286, SMR_INDEX_CR_GPR263 = 1287
+ , SMR_INDEX_CR_GPR264 = 1288, SMR_INDEX_CR_GPR265 = 1289, SMR_INDEX_CR_GPR266 = 1290, SMR_INDEX_CR_GPR267 = 1291
+ , SMR_INDEX_CR_GPR268 = 1292, SMR_INDEX_CR_GPR269 = 1293, SMR_INDEX_CR_GPR270 = 1294, SMR_INDEX_CR_GPR271 = 1295
+ , SMR_INDEX_CR_GPR272 = 1296, SMR_INDEX_CR_GPR273 = 1297, SMR_INDEX_CR_GPR274 = 1298, SMR_INDEX_CR_GPR275 = 1299
+ , SMR_INDEX_CR_GPR276 = 1300, SMR_INDEX_CR_GPR277 = 1301, SMR_INDEX_CR_GPR278 = 1302, SMR_INDEX_CR_GPR279 = 1303
+ , SMR_INDEX_CR_GPR280 = 1304, SMR_INDEX_CR_GPR281 = 1305, SMR_INDEX_CR_GPR282 = 1306, SMR_INDEX_CR_GPR283 = 1307
+ , SMR_INDEX_CR_GPR284 = 1308, SMR_INDEX_CR_GPR285 = 1309, SMR_INDEX_CR_GPR286 = 1310, SMR_INDEX_CR_GPR287 = 1311
+ , SMR_INDEX_CR_GPR288 = 1312, SMR_INDEX_CR_GPR289 = 1313, SMR_INDEX_CR_GPR290 = 1314, SMR_INDEX_CR_GPR291 = 1315
+ , SMR_INDEX_CR_GPR292 = 1316, SMR_INDEX_CR_GPR293 = 1317, SMR_INDEX_CR_GPR294 = 1318, SMR_INDEX_CR_GPR295 = 1319
+ , SMR_INDEX_CR_GPR296 = 1320, SMR_INDEX_CR_GPR297 = 1321, SMR_INDEX_CR_GPR298 = 1322, SMR_INDEX_CR_GPR299 = 1323
+ , SMR_INDEX_CR_GPR300 = 1324, SMR_INDEX_CR_GPR301 = 1325, SMR_INDEX_CR_GPR302 = 1326, SMR_INDEX_CR_GPR303 = 1327
+ , SMR_INDEX_CR_GPR304 = 1328, SMR_INDEX_CR_GPR305 = 1329, SMR_INDEX_CR_GPR306 = 1330, SMR_INDEX_CR_GPR307 = 1331
+ , SMR_INDEX_CR_GPR308 = 1332, SMR_INDEX_CR_GPR309 = 1333, SMR_INDEX_CR_GPR310 = 1334, SMR_INDEX_CR_GPR311 = 1335
+ , SMR_INDEX_CR_GPR312 = 1336, SMR_INDEX_CR_GPR313 = 1337, SMR_INDEX_CR_GPR314 = 1338, SMR_INDEX_CR_GPR315 = 1339
+ , SMR_INDEX_CR_GPR316 = 1340, SMR_INDEX_CR_GPR317 = 1341, SMR_INDEX_CR_GPR318 = 1342, SMR_INDEX_CR_GPR319 = 1343
+ , SMR_INDEX_CR_GPR320 = 1344, SMR_INDEX_CR_GPR321 = 1345, SMR_INDEX_CR_GPR322 = 1346, SMR_INDEX_CR_GPR323 = 1347
+ , SMR_INDEX_CR_GPR324 = 1348, SMR_INDEX_CR_GPR325 = 1349, SMR_INDEX_CR_GPR326 = 1350, SMR_INDEX_CR_GPR327 = 1351
+ , SMR_INDEX_CR_GPR328 = 1352, SMR_INDEX_CR_GPR329 = 1353, SMR_INDEX_CR_GPR330 = 1354, SMR_INDEX_CR_GPR331 = 1355
+ , SMR_INDEX_CR_GPR332 = 1356, SMR_INDEX_CR_GPR333 = 1357, SMR_INDEX_CR_GPR334 = 1358, SMR_INDEX_CR_GPR335 = 1359
+ , SMR_INDEX_CR_GPR336 = 1360, SMR_INDEX_CR_GPR337 = 1361, SMR_INDEX_CR_GPR338 = 1362, SMR_INDEX_CR_GPR339 = 1363
+ , SMR_INDEX_CR_GPR340 = 1364, SMR_INDEX_CR_GPR341 = 1365, SMR_INDEX_CR_GPR342 = 1366, SMR_INDEX_CR_GPR343 = 1367
+ , SMR_INDEX_CR_GPR344 = 1368, SMR_INDEX_CR_GPR345 = 1369, SMR_INDEX_CR_GPR346 = 1370, SMR_INDEX_CR_GPR347 = 1371
+ , SMR_INDEX_CR_GPR348 = 1372, SMR_INDEX_CR_GPR349 = 1373, SMR_INDEX_CR_GPR350 = 1374, SMR_INDEX_CR_GPR351 = 1375
+ , SMR_INDEX_CR_GPR352 = 1376, SMR_INDEX_CR_GPR353 = 1377, SMR_INDEX_CR_GPR354 = 1378, SMR_INDEX_CR_GPR355 = 1379
+ , SMR_INDEX_CR_GPR356 = 1380, SMR_INDEX_CR_GPR357 = 1381, SMR_INDEX_CR_GPR358 = 1382, SMR_INDEX_CR_GPR359 = 1383
+ , SMR_INDEX_CR_GPR360 = 1384, SMR_INDEX_CR_GPR361 = 1385, SMR_INDEX_CR_GPR362 = 1386, SMR_INDEX_CR_GPR363 = 1387
+ , SMR_INDEX_CR_GPR364 = 1388, SMR_INDEX_CR_GPR365 = 1389, SMR_INDEX_CR_GPR366 = 1390, SMR_INDEX_CR_GPR367 = 1391
+ , SMR_INDEX_CR_GPR368 = 1392, SMR_INDEX_CR_GPR369 = 1393, SMR_INDEX_CR_GPR370 = 1394, SMR_INDEX_CR_GPR371 = 1395
+ , SMR_INDEX_CR_GPR372 = 1396, SMR_INDEX_CR_GPR373 = 1397, SMR_INDEX_CR_GPR374 = 1398, SMR_INDEX_CR_GPR375 = 1399
+ , SMR_INDEX_CR_GPR376 = 1400, SMR_INDEX_CR_GPR377 = 1401, SMR_INDEX_CR_GPR378 = 1402, SMR_INDEX_CR_GPR379 = 1403
+ , SMR_INDEX_CR_GPR380 = 1404, SMR_INDEX_CR_GPR381 = 1405, SMR_INDEX_CR_GPR382 = 1406, SMR_INDEX_CR_GPR383 = 1407
+ , SMR_INDEX_CR_GPR384 = 1408, SMR_INDEX_CR_GPR385 = 1409, SMR_INDEX_CR_GPR386 = 1410, SMR_INDEX_CR_GPR387 = 1411
+ , SMR_INDEX_CR_GPR388 = 1412, SMR_INDEX_CR_GPR389 = 1413, SMR_INDEX_CR_GPR390 = 1414, SMR_INDEX_CR_GPR391 = 1415
+ , SMR_INDEX_CR_GPR392 = 1416, SMR_INDEX_CR_GPR393 = 1417, SMR_INDEX_CR_GPR394 = 1418, SMR_INDEX_CR_GPR395 = 1419
+ , SMR_INDEX_CR_GPR396 = 1420, SMR_INDEX_CR_GPR397 = 1421, SMR_INDEX_CR_GPR398 = 1422, SMR_INDEX_CR_GPR399 = 1423
+ , SMR_INDEX_CR_GPR400 = 1424, SMR_INDEX_CR_GPR401 = 1425, SMR_INDEX_CR_GPR402 = 1426, SMR_INDEX_CR_GPR403 = 1427
+ , SMR_INDEX_CR_GPR404 = 1428, SMR_INDEX_CR_GPR405 = 1429, SMR_INDEX_CR_GPR406 = 1430, SMR_INDEX_CR_GPR407 = 1431
+ , SMR_INDEX_CR_GPR408 = 1432, SMR_INDEX_CR_GPR409 = 1433, SMR_INDEX_CR_GPR410 = 1434, SMR_INDEX_CR_GPR411 = 1435
+ , SMR_INDEX_CR_GPR412 = 1436, SMR_INDEX_CR_GPR413 = 1437, SMR_INDEX_CR_GPR414 = 1438, SMR_INDEX_CR_GPR415 = 1439
+ , SMR_INDEX_CR_GPR416 = 1440, SMR_INDEX_CR_GPR417 = 1441, SMR_INDEX_CR_GPR418 = 1442, SMR_INDEX_CR_GPR419 = 1443
+ , SMR_INDEX_CR_GPR420 = 1444, SMR_INDEX_CR_GPR421 = 1445, SMR_INDEX_CR_GPR422 = 1446, SMR_INDEX_CR_GPR423 = 1447
+ , SMR_INDEX_CR_GPR424 = 1448, SMR_INDEX_CR_GPR425 = 1449, SMR_INDEX_CR_GPR426 = 1450, SMR_INDEX_CR_GPR427 = 1451
+ , SMR_INDEX_CR_GPR428 = 1452, SMR_INDEX_CR_GPR429 = 1453, SMR_INDEX_CR_GPR430 = 1454, SMR_INDEX_CR_GPR431 = 1455
+ , SMR_INDEX_CR_GPR432 = 1456, SMR_INDEX_CR_GPR433 = 1457, SMR_INDEX_CR_GPR434 = 1458, SMR_INDEX_CR_GPR435 = 1459
+ , SMR_INDEX_CR_GPR436 = 1460, SMR_INDEX_CR_GPR437 = 1461, SMR_INDEX_CR_GPR438 = 1462, SMR_INDEX_CR_GPR439 = 1463
+ , SMR_INDEX_CR_GPR440 = 1464, SMR_INDEX_CR_GPR441 = 1465, SMR_INDEX_CR_GPR442 = 1466, SMR_INDEX_CR_GPR443 = 1467
+ , SMR_INDEX_CR_GPR444 = 1468, SMR_INDEX_CR_GPR445 = 1469, SMR_INDEX_CR_GPR446 = 1470, SMR_INDEX_CR_GPR447 = 1471
+ , SMR_INDEX_CR_GPR448 = 1472, SMR_INDEX_CR_GPR449 = 1473, SMR_INDEX_CR_GPR450 = 1474, SMR_INDEX_CR_GPR451 = 1475
+ , SMR_INDEX_CR_GPR452 = 1476, SMR_INDEX_CR_GPR453 = 1477, SMR_INDEX_CR_GPR454 = 1478, SMR_INDEX_CR_GPR455 = 1479
+ , SMR_INDEX_CR_GPR456 = 1480, SMR_INDEX_CR_GPR457 = 1481, SMR_INDEX_CR_GPR458 = 1482, SMR_INDEX_CR_GPR459 = 1483
+ , SMR_INDEX_CR_GPR460 = 1484, SMR_INDEX_CR_GPR461 = 1485, SMR_INDEX_CR_GPR462 = 1486, SMR_INDEX_CR_GPR463 = 1487
+ , SMR_INDEX_CR_GPR464 = 1488, SMR_INDEX_CR_GPR465 = 1489, SMR_INDEX_CR_GPR466 = 1490, SMR_INDEX_CR_GPR467 = 1491
+ , SMR_INDEX_CR_GPR468 = 1492, SMR_INDEX_CR_GPR469 = 1493, SMR_INDEX_CR_GPR470 = 1494, SMR_INDEX_CR_GPR471 = 1495
+ , SMR_INDEX_CR_GPR472 = 1496, SMR_INDEX_CR_GPR473 = 1497, SMR_INDEX_CR_GPR474 = 1498, SMR_INDEX_CR_GPR475 = 1499
+ , SMR_INDEX_CR_GPR476 = 1500, SMR_INDEX_CR_GPR477 = 1501, SMR_INDEX_CR_GPR478 = 1502, SMR_INDEX_CR_GPR479 = 1503
+ , SMR_INDEX_CR_GPR480 = 1504, SMR_INDEX_CR_GPR481 = 1505, SMR_INDEX_CR_GPR482 = 1506, SMR_INDEX_CR_GPR483 = 1507
+ , SMR_INDEX_CR_GPR484 = 1508, SMR_INDEX_CR_GPR485 = 1509, SMR_INDEX_CR_GPR486 = 1510, SMR_INDEX_CR_GPR487 = 1511
+ , SMR_INDEX_CR_GPR488 = 1512, SMR_INDEX_CR_GPR489 = 1513, SMR_INDEX_CR_GPR490 = 1514, SMR_INDEX_CR_GPR491 = 1515
+ , SMR_INDEX_CR_GPR492 = 1516, SMR_INDEX_CR_GPR493 = 1517, SMR_INDEX_CR_GPR494 = 1518, SMR_INDEX_CR_GPR495 = 1519
+ , SMR_INDEX_CR_GPR496 = 1520, SMR_INDEX_CR_GPR497 = 1521, SMR_INDEX_CR_GPR498 = 1522, SMR_INDEX_CR_GPR499 = 1523
+ , SMR_INDEX_CR_GPR500 = 1524, SMR_INDEX_CR_GPR501 = 1525, SMR_INDEX_CR_GPR502 = 1526, SMR_INDEX_CR_GPR503 = 1527
+ , SMR_INDEX_CR_GPR504 = 1528, SMR_INDEX_CR_GPR505 = 1529, SMR_INDEX_CR_GPR506 = 1530, SMR_INDEX_CR_GPR507 = 1531
+ , SMR_INDEX_CR_GPR508 = 1532, SMR_INDEX_CR_GPR509 = 1533, SMR_INDEX_CR_GPR510 = 1534, SMR_INDEX_CR_GPR511 = 1535
+ , SMR_INDEX_CSR_PSR = 0, SMR_INDEX_CSR_MSR = 1, SMR_INDEX_CSR_FSR = 2
+} SMR_REG_INDICES;
+
+/* Enum declaration for SMR field msb positions.  */
+typedef enum smr_field_msbs {
+  SMR_FIELD_MSB_CR_CPUID_VER = 8, SMR_FIELD_MSB_CR_CPUID_REV = 14, SMR_FIELD_MSB_CR_CPUID_PXB32 = 15, SMR_FIELD_MSB_CR_CPUID_PXB64 = 16
+ , SMR_FIELD_MSB_CR_CPUID_FPX32 = 17, SMR_FIELD_MSB_CR_CPUID_FPX64 = 18, SMR_FIELD_MSB_CR_CPUID_VX64 = 19, SMR_FIELD_MSB_CR_EX_IE = 0
+ , SMR_FIELD_MSB_CR_EX_OE = 1, SMR_FIELD_MSB_CR_EX_EF = 2, SMR_FIELD_MSB_CR_DPR_ICP = 0, SMR_FIELD_MSB_CR_DPR_DCP = 1
+ , SMR_FIELD_MSB_CR_DPR_IMMUP = 2, SMR_FIELD_MSB_CR_DPR_DMMUP = 3, SMR_FIELD_MSB_CR_DPR_TMRUP = 4, SMR_FIELD_MSB_CR_DPR_PICU = 5
+ , SMR_FIELD_MSB_CR_DPR_DGBUP = 6, SMR_FIELD_MSB_CR_DPR_FPUP = 7, SMR_FIELD_MSB_CR_DPR_PMUP = 8, SMR_FIELD_MSB_CR_DPR_PMCUP = 9
+ , SMR_FIELD_MSB_CR_FPUC_RM = 1, SMR_FIELD_MSB_MSR_PSR_CF = 0, SMR_FIELD_MSB_MSR_PSR_CY = 1, SMR_FIELD_MSB_MSR_PSR_OV = 2
+ , SMR_FIELD_MSB_MSR_SR_RM = 0
+} SMR_FIELD_MSBS;
+
+/* Enum declaration for SMR field lsb positions.  */
+typedef enum smr_field_lsbs {
+  SMR_FIELD_SIZE_CR_CPUID_VER = 0, SMR_FIELD_SIZE_CR_CPUID_REV = 9, SMR_FIELD_SIZE_CR_CPUID_PXB32 = 15, SMR_FIELD_SIZE_CR_CPUID_PXB64 = 16
+ , SMR_FIELD_SIZE_CR_CPUID_FPX32 = 17, SMR_FIELD_SIZE_CR_CPUID_FPX64 = 18, SMR_FIELD_SIZE_CR_CPUID_VX64 = 19, SMR_FIELD_SIZE_CR_EX_IE = 0
+ , SMR_FIELD_SIZE_CR_EX_OE = 1, SMR_FIELD_SIZE_CR_EX_EF = 2, SMR_FIELD_SIZE_CR_DPR_ICP = 0, SMR_FIELD_SIZE_CR_DPR_DCP = 1
+ , SMR_FIELD_SIZE_CR_DPR_IMMUP = 2, SMR_FIELD_SIZE_CR_DPR_DMMUP = 3, SMR_FIELD_SIZE_CR_DPR_TMRUP = 4, SMR_FIELD_SIZE_CR_DPR_PICU = 5
+ , SMR_FIELD_SIZE_CR_DPR_DGBUP = 6, SMR_FIELD_SIZE_CR_DPR_FPUP = 7, SMR_FIELD_SIZE_CR_DPR_PMUP = 8, SMR_FIELD_SIZE_CR_DPR_PMCUP = 9
+ , SMR_FIELD_SIZE_CR_FPUC_RM = 0, SMR_FIELD_SIZE_MSR_PSR_CF = 0, SMR_FIELD_SIZE_MSR_PSR_CY = 1, SMR_FIELD_SIZE_MSR_PSR_OV = 2
+ , SMR_FIELD_SIZE_MSR_SR_RM = 0
+} SMR_FIELD_LSBS;
+
+/* Enum declaration for SMR field masks.  */
+typedef enum smr_field_masks {
+  SMR_FIELD_MASK_CR_CPUID_VER = 511, SMR_FIELD_MASK_CR_CPUID_REV = 32256, SMR_FIELD_MASK_CR_CPUID_PXB32 = 32768, SMR_FIELD_MASK_CR_CPUID_PXB64 = 65536
+ , SMR_FIELD_MASK_CR_CPUID_FPX32 = 131072, SMR_FIELD_MASK_CR_CPUID_FPX64 = 262144, SMR_FIELD_MASK_CR_CPUID_VX64 = 524288, SMR_FIELD_MASK_CR_EX_IE = 1
+ , SMR_FIELD_MASK_CR_EX_OE = 2, SMR_FIELD_MASK_CR_EX_EF = 4, SMR_FIELD_MASK_CR_DPR_ICP = 1, SMR_FIELD_MASK_CR_DPR_DCP = 2
+ , SMR_FIELD_MASK_CR_DPR_IMMUP = 4, SMR_FIELD_MASK_CR_DPR_DMMUP = 8, SMR_FIELD_MASK_CR_DPR_TMRUP = 16, SMR_FIELD_MASK_CR_DPR_PICU = 32
+ , SMR_FIELD_MASK_CR_DPR_DGBUP = 64, SMR_FIELD_MASK_CR_DPR_FPUP = 128, SMR_FIELD_MASK_CR_DPR_PMUP = 256, SMR_FIELD_MASK_CR_DPR_PMCUP = 512
+ , SMR_FIELD_MASK_CR_FPUC_RM = 3, SMR_FIELD_MASK_MSR_PSR_CF = 1, SMR_FIELD_MASK_MSR_PSR_CY = 2, SMR_FIELD_MASK_MSR_PSR_OV = 4
+ , SMR_FIELD_MASK_MSR_SR_RM = 1
+} SMR_FIELD_MASKS;
+
+/* Enum declaration for <opcode> insn opcodes.  */
+typedef enum insn_opcode {
+  OPC_AND, OPC_AND_I, OPC_OR, OPC_OR_I
+ , OPC_XOR, OPC_XOR_I, OPC_LSL, OPC_LSL_I
+ , OPC_LSR, OPC_LSR_I, OPC_JMP, OPC_JMP_I
+ , OPC_BEQ, OPC_BNE, OPC_BGT, OPC_BLE
+ , OPC_LDWU, OPC_STW, OPC_BARR, OPC_EXC
+ , OPC_RET, OPC_WSMR, OPC_RSMR, OPC_ASR
+ , OPC_ASR_I, OPC_ADD, OPC_ADD_I, OPC_SUB
+ , OPC_MUL, OPC_MULU, OPC_DIV, OPC_DIVU
+ , OPC_MOD, OPC_LDB, OPC_LDBU, OPC_LDH
+ , OPC_LDHU, OPC_STB, OPC_STH, OPC_MHI
+ , OPC_FADD, OPC_FSUB, OPC_FMUL, OPC_FDIV
+ , OPC_FCMPEQ, OPC_FCMPGT, OPC_FMOV, OPC_PCRP
+} INSN_OPCODE;
+
+/* Attributes.  */
+
+/* Enum declaration for machine type selection.  */
+typedef enum mach_attr {
+  MACH_BASE, MACH_NCPU32K_MACH, MACH_MAX
+} MACH_ATTR;
+
+/* Enum declaration for instruction set selection.  */
+typedef enum isa_attr {
+  ISA_NCPU32K_ISA, ISA_MAX
+} ISA_ATTR;
+
+/* Number of architecture variants.  */
+#define MAX_ISAS  1
+#define MAX_MACHS ((int) MACH_MAX)
+
+/* Ifield support.  */
+
+/* Ifield attribute indices.  */
+
+/* Enum declaration for cgen_ifld attrs.  */
+typedef enum cgen_ifld_attr {
+  CGEN_IFLD_VIRTUAL, CGEN_IFLD_PCREL_ADDR, CGEN_IFLD_ABS_ADDR, CGEN_IFLD_RESERVED
+ , CGEN_IFLD_SIGN_OPT, CGEN_IFLD_SIGNED, CGEN_IFLD_END_BOOLS, CGEN_IFLD_START_NBOOLS = 31
+ , CGEN_IFLD_MACH, CGEN_IFLD_END_NBOOLS
+} CGEN_IFLD_ATTR;
+
+/* Number of non-boolean elements in cgen_ifld_attr.  */
+#define CGEN_IFLD_NBOOL_ATTRS (CGEN_IFLD_END_NBOOLS - CGEN_IFLD_START_NBOOLS - 1)
+
+/* cgen_ifld attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_IFLD_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_IFLD_MACH-CGEN_IFLD_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_IFLD_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_PCREL_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_PCREL_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_ABS_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_ABS_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_RESERVED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_RESERVED)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_SIGN_OPT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_SIGN_OPT)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_SIGNED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_SIGNED)) != 0)
+
+/* Enum declaration for ncpu32k ifield types.  */
+typedef enum ifield_type {
+  NCPU32K_F_NIL, NCPU32K_F_ANYOF, NCPU32K_F_OPCODE, NCPU32K_F_RD
+ , NCPU32K_F_RES_RD, NCPU32K_F_RS, NCPU32K_F_RES_RS, NCPU32K_F_IMM16
+ , NCPU32K_F_UIMM16, NCPU32K_F_SIMM16, NCPU32K_F_RES_IMM16, NCPU32K_F_REL16
+ , NCPU32K_F_REL21, NCPU32K_F_MAX
+} IFIELD_TYPE;
+
+#define MAX_IFLD ((int) NCPU32K_F_MAX)
+
+/* Hardware attribute indices.  */
+
+/* Enum declaration for cgen_hw attrs.  */
+typedef enum cgen_hw_attr {
+  CGEN_HW_VIRTUAL, CGEN_HW_CACHE_ADDR, CGEN_HW_PC, CGEN_HW_PROFILE
+ , CGEN_HW_END_BOOLS, CGEN_HW_START_NBOOLS = 31, CGEN_HW_MACH, CGEN_HW_END_NBOOLS
+} CGEN_HW_ATTR;
+
+/* Number of non-boolean elements in cgen_hw_attr.  */
+#define CGEN_HW_NBOOL_ATTRS (CGEN_HW_END_NBOOLS - CGEN_HW_START_NBOOLS - 1)
+
+/* cgen_hw attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_HW_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_HW_MACH-CGEN_HW_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_HW_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_HW_CACHE_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_CACHE_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_HW_PC_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_PC)) != 0)
+#define CGEN_ATTR_CGEN_HW_PROFILE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_PROFILE)) != 0)
+
+/* Enum declaration for ncpu32k hardware types.  */
+typedef enum cgen_hw_type {
+  HW_H_MEMORY, HW_H_SINT, HW_H_UINT, HW_H_ADDR
+ , HW_H_IADDR, HW_H_PC, HW_H_FRS, HW_H_FRD
+ , HW_H_SMR, HW_H_GPR, HW_H_CR_CPUID, HW_H_CR_EX
+ , HW_H_CR_EB, HW_H_CR_EPC, HW_H_CR_ECSR, HW_H_CR_DPR
+ , HW_H_CR_ICC, HW_H_CR_DCC, HW_H_CR_IMMUC, HW_H_CR_DMMUC
+ , HW_H_CR_TRMUC, HW_H_CR_PICUC, HW_H_CR_DBGUC, HW_H_CR_FPUC
+ , HW_H_CR_PMUC, HW_H_CR_PMCUC, HW_H_CR_GPR0, HW_H_CR_GPR1
+ , HW_H_CR_GPR2, HW_H_CR_GPR3, HW_H_CR_GPR4, HW_H_CR_GPR5
+ , HW_H_CR_GPR6, HW_H_CR_GPR7, HW_H_CR_GPR8, HW_H_CR_GPR9
+ , HW_H_CR_GPR10, HW_H_CR_GPR11, HW_H_CR_GPR12, HW_H_CR_GPR13
+ , HW_H_CR_GPR14, HW_H_CR_GPR15, HW_H_CR_GPR16, HW_H_CR_GPR17
+ , HW_H_CR_GPR18, HW_H_CR_GPR19, HW_H_CR_GPR20, HW_H_CR_GPR21
+ , HW_H_CR_GPR22, HW_H_CR_GPR23, HW_H_CR_GPR24, HW_H_CR_GPR25
+ , HW_H_CR_GPR26, HW_H_CR_GPR27, HW_H_CR_GPR28, HW_H_CR_GPR29
+ , HW_H_CR_GPR30, HW_H_CR_GPR31, HW_H_CR_GPR32, HW_H_CR_GPR33
+ , HW_H_CR_GPR34, HW_H_CR_GPR35, HW_H_CR_GPR36, HW_H_CR_GPR37
+ , HW_H_CR_GPR38, HW_H_CR_GPR39, HW_H_CR_GPR40, HW_H_CR_GPR41
+ , HW_H_CR_GPR42, HW_H_CR_GPR43, HW_H_CR_GPR44, HW_H_CR_GPR45
+ , HW_H_CR_GPR46, HW_H_CR_GPR47, HW_H_CR_GPR48, HW_H_CR_GPR49
+ , HW_H_CR_GPR50, HW_H_CR_GPR51, HW_H_CR_GPR52, HW_H_CR_GPR53
+ , HW_H_CR_GPR54, HW_H_CR_GPR55, HW_H_CR_GPR56, HW_H_CR_GPR57
+ , HW_H_CR_GPR58, HW_H_CR_GPR59, HW_H_CR_GPR60, HW_H_CR_GPR61
+ , HW_H_CR_GPR62, HW_H_CR_GPR63, HW_H_CR_GPR64, HW_H_CR_GPR65
+ , HW_H_CR_GPR66, HW_H_CR_GPR67, HW_H_CR_GPR68, HW_H_CR_GPR69
+ , HW_H_CR_GPR70, HW_H_CR_GPR71, HW_H_CR_GPR72, HW_H_CR_GPR73
+ , HW_H_CR_GPR74, HW_H_CR_GPR75, HW_H_CR_GPR76, HW_H_CR_GPR77
+ , HW_H_CR_GPR78, HW_H_CR_GPR79, HW_H_CR_GPR80, HW_H_CR_GPR81
+ , HW_H_CR_GPR82, HW_H_CR_GPR83, HW_H_CR_GPR84, HW_H_CR_GPR85
+ , HW_H_CR_GPR86, HW_H_CR_GPR87, HW_H_CR_GPR88, HW_H_CR_GPR89
+ , HW_H_CR_GPR90, HW_H_CR_GPR91, HW_H_CR_GPR92, HW_H_CR_GPR93
+ , HW_H_CR_GPR94, HW_H_CR_GPR95, HW_H_CR_GPR96, HW_H_CR_GPR97
+ , HW_H_CR_GPR98, HW_H_CR_GPR99, HW_H_CR_GPR100, HW_H_CR_GPR101
+ , HW_H_CR_GPR102, HW_H_CR_GPR103, HW_H_CR_GPR104, HW_H_CR_GPR105
+ , HW_H_CR_GPR106, HW_H_CR_GPR107, HW_H_CR_GPR108, HW_H_CR_GPR109
+ , HW_H_CR_GPR110, HW_H_CR_GPR111, HW_H_CR_GPR112, HW_H_CR_GPR113
+ , HW_H_CR_GPR114, HW_H_CR_GPR115, HW_H_CR_GPR116, HW_H_CR_GPR117
+ , HW_H_CR_GPR118, HW_H_CR_GPR119, HW_H_CR_GPR120, HW_H_CR_GPR121
+ , HW_H_CR_GPR122, HW_H_CR_GPR123, HW_H_CR_GPR124, HW_H_CR_GPR125
+ , HW_H_CR_GPR126, HW_H_CR_GPR127, HW_H_CR_GPR128, HW_H_CR_GPR129
+ , HW_H_CR_GPR130, HW_H_CR_GPR131, HW_H_CR_GPR132, HW_H_CR_GPR133
+ , HW_H_CR_GPR134, HW_H_CR_GPR135, HW_H_CR_GPR136, HW_H_CR_GPR137
+ , HW_H_CR_GPR138, HW_H_CR_GPR139, HW_H_CR_GPR140, HW_H_CR_GPR141
+ , HW_H_CR_GPR142, HW_H_CR_GPR143, HW_H_CR_GPR144, HW_H_CR_GPR145
+ , HW_H_CR_GPR146, HW_H_CR_GPR147, HW_H_CR_GPR148, HW_H_CR_GPR149
+ , HW_H_CR_GPR150, HW_H_CR_GPR151, HW_H_CR_GPR152, HW_H_CR_GPR153
+ , HW_H_CR_GPR154, HW_H_CR_GPR155, HW_H_CR_GPR156, HW_H_CR_GPR157
+ , HW_H_CR_GPR158, HW_H_CR_GPR159, HW_H_CR_GPR160, HW_H_CR_GPR161
+ , HW_H_CR_GPR162, HW_H_CR_GPR163, HW_H_CR_GPR164, HW_H_CR_GPR165
+ , HW_H_CR_GPR166, HW_H_CR_GPR167, HW_H_CR_GPR168, HW_H_CR_GPR169
+ , HW_H_CR_GPR170, HW_H_CR_GPR171, HW_H_CR_GPR172, HW_H_CR_GPR173
+ , HW_H_CR_GPR174, HW_H_CR_GPR175, HW_H_CR_GPR176, HW_H_CR_GPR177
+ , HW_H_CR_GPR178, HW_H_CR_GPR179, HW_H_CR_GPR180, HW_H_CR_GPR181
+ , HW_H_CR_GPR182, HW_H_CR_GPR183, HW_H_CR_GPR184, HW_H_CR_GPR185
+ , HW_H_CR_GPR186, HW_H_CR_GPR187, HW_H_CR_GPR188, HW_H_CR_GPR189
+ , HW_H_CR_GPR190, HW_H_CR_GPR191, HW_H_CR_GPR192, HW_H_CR_GPR193
+ , HW_H_CR_GPR194, HW_H_CR_GPR195, HW_H_CR_GPR196, HW_H_CR_GPR197
+ , HW_H_CR_GPR198, HW_H_CR_GPR199, HW_H_CR_GPR200, HW_H_CR_GPR201
+ , HW_H_CR_GPR202, HW_H_CR_GPR203, HW_H_CR_GPR204, HW_H_CR_GPR205
+ , HW_H_CR_GPR206, HW_H_CR_GPR207, HW_H_CR_GPR208, HW_H_CR_GPR209
+ , HW_H_CR_GPR210, HW_H_CR_GPR211, HW_H_CR_GPR212, HW_H_CR_GPR213
+ , HW_H_CR_GPR214, HW_H_CR_GPR215, HW_H_CR_GPR216, HW_H_CR_GPR217
+ , HW_H_CR_GPR218, HW_H_CR_GPR219, HW_H_CR_GPR220, HW_H_CR_GPR221
+ , HW_H_CR_GPR222, HW_H_CR_GPR223, HW_H_CR_GPR224, HW_H_CR_GPR225
+ , HW_H_CR_GPR226, HW_H_CR_GPR227, HW_H_CR_GPR228, HW_H_CR_GPR229
+ , HW_H_CR_GPR230, HW_H_CR_GPR231, HW_H_CR_GPR232, HW_H_CR_GPR233
+ , HW_H_CR_GPR234, HW_H_CR_GPR235, HW_H_CR_GPR236, HW_H_CR_GPR237
+ , HW_H_CR_GPR238, HW_H_CR_GPR239, HW_H_CR_GPR240, HW_H_CR_GPR241
+ , HW_H_CR_GPR242, HW_H_CR_GPR243, HW_H_CR_GPR244, HW_H_CR_GPR245
+ , HW_H_CR_GPR246, HW_H_CR_GPR247, HW_H_CR_GPR248, HW_H_CR_GPR249
+ , HW_H_CR_GPR250, HW_H_CR_GPR251, HW_H_CR_GPR252, HW_H_CR_GPR253
+ , HW_H_CR_GPR254, HW_H_CR_GPR255, HW_H_CR_GPR256, HW_H_CR_GPR257
+ , HW_H_CR_GPR258, HW_H_CR_GPR259, HW_H_CR_GPR260, HW_H_CR_GPR261
+ , HW_H_CR_GPR262, HW_H_CR_GPR263, HW_H_CR_GPR264, HW_H_CR_GPR265
+ , HW_H_CR_GPR266, HW_H_CR_GPR267, HW_H_CR_GPR268, HW_H_CR_GPR269
+ , HW_H_CR_GPR270, HW_H_CR_GPR271, HW_H_CR_GPR272, HW_H_CR_GPR273
+ , HW_H_CR_GPR274, HW_H_CR_GPR275, HW_H_CR_GPR276, HW_H_CR_GPR277
+ , HW_H_CR_GPR278, HW_H_CR_GPR279, HW_H_CR_GPR280, HW_H_CR_GPR281
+ , HW_H_CR_GPR282, HW_H_CR_GPR283, HW_H_CR_GPR284, HW_H_CR_GPR285
+ , HW_H_CR_GPR286, HW_H_CR_GPR287, HW_H_CR_GPR288, HW_H_CR_GPR289
+ , HW_H_CR_GPR290, HW_H_CR_GPR291, HW_H_CR_GPR292, HW_H_CR_GPR293
+ , HW_H_CR_GPR294, HW_H_CR_GPR295, HW_H_CR_GPR296, HW_H_CR_GPR297
+ , HW_H_CR_GPR298, HW_H_CR_GPR299, HW_H_CR_GPR300, HW_H_CR_GPR301
+ , HW_H_CR_GPR302, HW_H_CR_GPR303, HW_H_CR_GPR304, HW_H_CR_GPR305
+ , HW_H_CR_GPR306, HW_H_CR_GPR307, HW_H_CR_GPR308, HW_H_CR_GPR309
+ , HW_H_CR_GPR310, HW_H_CR_GPR311, HW_H_CR_GPR312, HW_H_CR_GPR313
+ , HW_H_CR_GPR314, HW_H_CR_GPR315, HW_H_CR_GPR316, HW_H_CR_GPR317
+ , HW_H_CR_GPR318, HW_H_CR_GPR319, HW_H_CR_GPR320, HW_H_CR_GPR321
+ , HW_H_CR_GPR322, HW_H_CR_GPR323, HW_H_CR_GPR324, HW_H_CR_GPR325
+ , HW_H_CR_GPR326, HW_H_CR_GPR327, HW_H_CR_GPR328, HW_H_CR_GPR329
+ , HW_H_CR_GPR330, HW_H_CR_GPR331, HW_H_CR_GPR332, HW_H_CR_GPR333
+ , HW_H_CR_GPR334, HW_H_CR_GPR335, HW_H_CR_GPR336, HW_H_CR_GPR337
+ , HW_H_CR_GPR338, HW_H_CR_GPR339, HW_H_CR_GPR340, HW_H_CR_GPR341
+ , HW_H_CR_GPR342, HW_H_CR_GPR343, HW_H_CR_GPR344, HW_H_CR_GPR345
+ , HW_H_CR_GPR346, HW_H_CR_GPR347, HW_H_CR_GPR348, HW_H_CR_GPR349
+ , HW_H_CR_GPR350, HW_H_CR_GPR351, HW_H_CR_GPR352, HW_H_CR_GPR353
+ , HW_H_CR_GPR354, HW_H_CR_GPR355, HW_H_CR_GPR356, HW_H_CR_GPR357
+ , HW_H_CR_GPR358, HW_H_CR_GPR359, HW_H_CR_GPR360, HW_H_CR_GPR361
+ , HW_H_CR_GPR362, HW_H_CR_GPR363, HW_H_CR_GPR364, HW_H_CR_GPR365
+ , HW_H_CR_GPR366, HW_H_CR_GPR367, HW_H_CR_GPR368, HW_H_CR_GPR369
+ , HW_H_CR_GPR370, HW_H_CR_GPR371, HW_H_CR_GPR372, HW_H_CR_GPR373
+ , HW_H_CR_GPR374, HW_H_CR_GPR375, HW_H_CR_GPR376, HW_H_CR_GPR377
+ , HW_H_CR_GPR378, HW_H_CR_GPR379, HW_H_CR_GPR380, HW_H_CR_GPR381
+ , HW_H_CR_GPR382, HW_H_CR_GPR383, HW_H_CR_GPR384, HW_H_CR_GPR385
+ , HW_H_CR_GPR386, HW_H_CR_GPR387, HW_H_CR_GPR388, HW_H_CR_GPR389
+ , HW_H_CR_GPR390, HW_H_CR_GPR391, HW_H_CR_GPR392, HW_H_CR_GPR393
+ , HW_H_CR_GPR394, HW_H_CR_GPR395, HW_H_CR_GPR396, HW_H_CR_GPR397
+ , HW_H_CR_GPR398, HW_H_CR_GPR399, HW_H_CR_GPR400, HW_H_CR_GPR401
+ , HW_H_CR_GPR402, HW_H_CR_GPR403, HW_H_CR_GPR404, HW_H_CR_GPR405
+ , HW_H_CR_GPR406, HW_H_CR_GPR407, HW_H_CR_GPR408, HW_H_CR_GPR409
+ , HW_H_CR_GPR410, HW_H_CR_GPR411, HW_H_CR_GPR412, HW_H_CR_GPR413
+ , HW_H_CR_GPR414, HW_H_CR_GPR415, HW_H_CR_GPR416, HW_H_CR_GPR417
+ , HW_H_CR_GPR418, HW_H_CR_GPR419, HW_H_CR_GPR420, HW_H_CR_GPR421
+ , HW_H_CR_GPR422, HW_H_CR_GPR423, HW_H_CR_GPR424, HW_H_CR_GPR425
+ , HW_H_CR_GPR426, HW_H_CR_GPR427, HW_H_CR_GPR428, HW_H_CR_GPR429
+ , HW_H_CR_GPR430, HW_H_CR_GPR431, HW_H_CR_GPR432, HW_H_CR_GPR433
+ , HW_H_CR_GPR434, HW_H_CR_GPR435, HW_H_CR_GPR436, HW_H_CR_GPR437
+ , HW_H_CR_GPR438, HW_H_CR_GPR439, HW_H_CR_GPR440, HW_H_CR_GPR441
+ , HW_H_CR_GPR442, HW_H_CR_GPR443, HW_H_CR_GPR444, HW_H_CR_GPR445
+ , HW_H_CR_GPR446, HW_H_CR_GPR447, HW_H_CR_GPR448, HW_H_CR_GPR449
+ , HW_H_CR_GPR450, HW_H_CR_GPR451, HW_H_CR_GPR452, HW_H_CR_GPR453
+ , HW_H_CR_GPR454, HW_H_CR_GPR455, HW_H_CR_GPR456, HW_H_CR_GPR457
+ , HW_H_CR_GPR458, HW_H_CR_GPR459, HW_H_CR_GPR460, HW_H_CR_GPR461
+ , HW_H_CR_GPR462, HW_H_CR_GPR463, HW_H_CR_GPR464, HW_H_CR_GPR465
+ , HW_H_CR_GPR466, HW_H_CR_GPR467, HW_H_CR_GPR468, HW_H_CR_GPR469
+ , HW_H_CR_GPR470, HW_H_CR_GPR471, HW_H_CR_GPR472, HW_H_CR_GPR473
+ , HW_H_CR_GPR474, HW_H_CR_GPR475, HW_H_CR_GPR476, HW_H_CR_GPR477
+ , HW_H_CR_GPR478, HW_H_CR_GPR479, HW_H_CR_GPR480, HW_H_CR_GPR481
+ , HW_H_CR_GPR482, HW_H_CR_GPR483, HW_H_CR_GPR484, HW_H_CR_GPR485
+ , HW_H_CR_GPR486, HW_H_CR_GPR487, HW_H_CR_GPR488, HW_H_CR_GPR489
+ , HW_H_CR_GPR490, HW_H_CR_GPR491, HW_H_CR_GPR492, HW_H_CR_GPR493
+ , HW_H_CR_GPR494, HW_H_CR_GPR495, HW_H_CR_GPR496, HW_H_CR_GPR497
+ , HW_H_CR_GPR498, HW_H_CR_GPR499, HW_H_CR_GPR500, HW_H_CR_GPR501
+ , HW_H_CR_GPR502, HW_H_CR_GPR503, HW_H_CR_GPR504, HW_H_CR_GPR505
+ , HW_H_CR_GPR506, HW_H_CR_GPR507, HW_H_CR_GPR508, HW_H_CR_GPR509
+ , HW_H_CR_GPR510, HW_H_CR_GPR511, HW_H_CSR_PSR, HW_H_CSR_MSR
+ , HW_H_CSR_FSR, HW_H_CR_CPUID_VER, HW_H_CR_CPUID_REV, HW_H_CR_CPUID_PXB32
+ , HW_H_CR_CPUID_PXB64, HW_H_CR_CPUID_FPX32, HW_H_CR_CPUID_FPX64, HW_H_CR_CPUID_VX64
+ , HW_H_CR_EX_IE, HW_H_CR_EX_OE, HW_H_CR_EX_EF, HW_H_CR_DPR_ICP
+ , HW_H_CR_DPR_DCP, HW_H_CR_DPR_IMMUP, HW_H_CR_DPR_DMMUP, HW_H_CR_DPR_TMRUP
+ , HW_H_CR_DPR_PICU, HW_H_CR_DPR_DGBUP, HW_H_CR_DPR_FPUP, HW_H_CR_DPR_PMUP
+ , HW_H_CR_DPR_PMCUP, HW_H_CR_FPUC_RM, HW_H_MSR_PSR_CF, HW_H_MSR_PSR_CY
+ , HW_H_MSR_PSR_OV, HW_H_MSR_SR_RM, HW_H_SIMM16, HW_H_UIMM16
+ , HW_MAX
+} CGEN_HW_TYPE;
+
+#define MAX_HW ((int) HW_MAX)
+
+/* Operand attribute indices.  */
+
+/* Enum declaration for cgen_operand attrs.  */
+typedef enum cgen_operand_attr {
+  CGEN_OPERAND_VIRTUAL, CGEN_OPERAND_PCREL_ADDR, CGEN_OPERAND_ABS_ADDR, CGEN_OPERAND_SIGN_OPT
+ , CGEN_OPERAND_SIGNED, CGEN_OPERAND_NEGATIVE, CGEN_OPERAND_RELAX, CGEN_OPERAND_SEM_ONLY
+ , CGEN_OPERAND_END_BOOLS, CGEN_OPERAND_START_NBOOLS = 31, CGEN_OPERAND_MACH, CGEN_OPERAND_END_NBOOLS
+} CGEN_OPERAND_ATTR;
+
+/* Number of non-boolean elements in cgen_operand_attr.  */
+#define CGEN_OPERAND_NBOOL_ATTRS (CGEN_OPERAND_END_NBOOLS - CGEN_OPERAND_START_NBOOLS - 1)
+
+/* cgen_operand attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_OPERAND_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_OPERAND_MACH-CGEN_OPERAND_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_OPERAND_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_PCREL_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_PCREL_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_ABS_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_ABS_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SIGN_OPT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SIGN_OPT)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SIGNED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SIGNED)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_NEGATIVE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_NEGATIVE)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_RELAX_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_RELAX)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SEM_ONLY_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SEM_ONLY)) != 0)
+
+/* Enum declaration for ncpu32k operand types.  */
+typedef enum cgen_operand_type {
+  NCPU32K_OPERAND_PC, NCPU32K_OPERAND_RS, NCPU32K_OPERAND_RD, NCPU32K_OPERAND_SIMM16
+ , NCPU32K_OPERAND_UIMM16, NCPU32K_OPERAND_REL16, NCPU32K_OPERAND_REL21, NCPU32K_OPERAND_MSR_PSR_CY
+ , NCPU32K_OPERAND_MSR_PSR_OV, NCPU32K_OPERAND_CR_EX_OE, NCPU32K_OPERAND_MAX
+} CGEN_OPERAND_TYPE;
+
+/* Number of operands types.  */
+#define MAX_OPERANDS 10
+
+/* Maximum number of operands referenced by any insn.  */
+#define MAX_OPERAND_INSTANCES 8
+
+/* Insn attribute indices.  */
+
+/* Enum declaration for cgen_insn attrs.  */
+typedef enum cgen_insn_attr {
+  CGEN_INSN_ALIAS, CGEN_INSN_VIRTUAL, CGEN_INSN_UNCOND_CTI, CGEN_INSN_COND_CTI
+ , CGEN_INSN_SKIP_CTI, CGEN_INSN_DELAY_SLOT, CGEN_INSN_RELAXABLE, CGEN_INSN_RELAXED
+ , CGEN_INSN_NO_DIS, CGEN_INSN_PBB, CGEN_INSN_FORCED_CTI, CGEN_INSN_END_BOOLS
+ , CGEN_INSN_START_NBOOLS = 31, CGEN_INSN_MACH, CGEN_INSN_END_NBOOLS
+} CGEN_INSN_ATTR;
+
+/* Number of non-boolean elements in cgen_insn_attr.  */
+#define CGEN_INSN_NBOOL_ATTRS (CGEN_INSN_END_NBOOLS - CGEN_INSN_START_NBOOLS - 1)
+
+/* cgen_insn attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_INSN_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_INSN_MACH-CGEN_INSN_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_INSN_ALIAS_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_ALIAS)) != 0)
+#define CGEN_ATTR_CGEN_INSN_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_INSN_UNCOND_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_UNCOND_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_COND_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_COND_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_SKIP_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_SKIP_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_DELAY_SLOT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_DELAY_SLOT)) != 0)
+#define CGEN_ATTR_CGEN_INSN_RELAXABLE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_RELAXABLE)) != 0)
+#define CGEN_ATTR_CGEN_INSN_RELAXED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_RELAXED)) != 0)
+#define CGEN_ATTR_CGEN_INSN_NO_DIS_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_NO_DIS)) != 0)
+#define CGEN_ATTR_CGEN_INSN_PBB_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_PBB)) != 0)
+#define CGEN_ATTR_CGEN_INSN_FORCED_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_FORCED_CTI)) != 0)
+
+/* cgen.h uses things we just defined.  */
+#include "opcode/cgen.h"
+
+extern const struct cgen_ifld ncpu32k_cgen_ifld_table[];
+
+/* Attributes.  */
+extern const CGEN_ATTR_TABLE ncpu32k_cgen_hardware_attr_table[];
+extern const CGEN_ATTR_TABLE ncpu32k_cgen_ifield_attr_table[];
+extern const CGEN_ATTR_TABLE ncpu32k_cgen_operand_attr_table[];
+extern const CGEN_ATTR_TABLE ncpu32k_cgen_insn_attr_table[];
+
+/* Hardware decls.  */
+
+extern CGEN_KEYWORD ncpu32k_cgen_opval_h_frs;
+extern CGEN_KEYWORD ncpu32k_cgen_opval_h_frd;
+extern CGEN_KEYWORD ncpu32k_cgen_opval_h_gpr;
+
+extern const CGEN_HW_ENTRY ncpu32k_cgen_hw_table[];
+
+
+
+   #ifdef __cplusplus
+   }
+   #endif
+
+#endif /* NCPU32K_CPU_H */
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-dis.c binutils-ncpu32k-2.32/opcodes/ncpu32k-dis.c
--- binutils-2.32/opcodes/ncpu32k-dis.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-dis.c	2019-08-12 18:41:23.465368586 +0800
@@ -0,0 +1,535 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Disassembler interface for targets using CGEN. -*- C -*-
+   CGEN: Cpu tools GENerator
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN.
+   - the resultant file is machine generated, cgen-dis.in isn't
+
+   Copyright (C) 1996-2019 Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "disassemble.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "libiberty.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+#include "opintl.h"
+
+/* Default text to print if an instruction isn't recognized.  */
+#define UNKNOWN_INSN_MSG _("*unknown*")
+
+static void print_normal
+  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+static void print_address
+  (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
+static void print_keyword
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+static void print_insn_normal
+  (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
+static int print_insn
+  (CGEN_CPU_DESC, bfd_vma,  disassemble_info *, bfd_byte *, unsigned);
+static int default_print_insn
+  (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
+static int read_insn
+  (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
+   unsigned long *);
+
+/* -- disassembler routines inserted here.  */
+
+
+void ncpu32k_cgen_print_operand
+  (CGEN_CPU_DESC, int, PTR, CGEN_FIELDS *, void const *, bfd_vma, int);
+
+/* Main entry point for printing operands.
+   XINFO is a `void *' and not a `disassemble_info *' to not put a requirement
+   of dis-asm.h on cgen.h.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `print_insn_normal', but keeping it
+   separate makes clear the interface between `print_insn_normal' and each of
+   the handlers.  */
+
+void
+ncpu32k_cgen_print_operand (CGEN_CPU_DESC cd,
+			   int opindex,
+			   void * xinfo,
+			   CGEN_FIELDS *fields,
+			   void const *attrs ATTRIBUTE_UNUSED,
+			   bfd_vma pc,
+			   int length)
+{
+  disassemble_info *info = (disassemble_info *) xinfo;
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      print_keyword (cd, info, & ncpu32k_cgen_opval_h_gpr, fields->f_rd, 0);
+      break;
+    case NCPU32K_OPERAND_REL16 :
+      print_address (cd, info, fields->f_rel16, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
+      break;
+    case NCPU32K_OPERAND_REL21 :
+      print_address (cd, info, fields->f_rel21, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
+      break;
+    case NCPU32K_OPERAND_RS :
+      print_keyword (cd, info, & ncpu32k_cgen_opval_h_gpr, fields->f_rs, 0);
+      break;
+    case NCPU32K_OPERAND_SIMM16 :
+      print_normal (cd, info, fields->f_simm16, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_SIGN_OPT), pc, length);
+      break;
+    case NCPU32K_OPERAND_UIMM16 :
+      print_normal (cd, info, fields->f_uimm16, 0, pc, length);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while printing insn.\n"),
+	       opindex);
+    abort ();
+  }
+}
+
+cgen_print_fn * const ncpu32k_cgen_print_handlers[] =
+{
+  print_insn_normal,
+};
+
+
+void
+ncpu32k_cgen_init_dis (CGEN_CPU_DESC cd)
+{
+  ncpu32k_cgen_init_opcode_table (cd);
+  ncpu32k_cgen_init_ibld_table (cd);
+  cd->print_handlers = & ncpu32k_cgen_print_handlers[0];
+  cd->print_operand = ncpu32k_cgen_print_operand;
+}
+
+
+/* Default print handler.  */
+
+static void
+print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	      void *dis_info,
+	      long value,
+	      unsigned int attrs,
+	      bfd_vma pc ATTRIBUTE_UNUSED,
+	      int length ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+
+  /* Print the operand as directed by the attributes.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
+    ; /* nothing to do */
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
+    (*info->fprintf_func) (info->stream, "%ld", value);
+  else
+    (*info->fprintf_func) (info->stream, "0x%lx", value);
+}
+
+/* Default address handler.  */
+
+static void
+print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	       void *dis_info,
+	       bfd_vma value,
+	       unsigned int attrs,
+	       bfd_vma pc ATTRIBUTE_UNUSED,
+	       int length ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+
+  /* Print the operand as directed by the attributes.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
+    ; /* Nothing to do.  */
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_PCREL_ADDR))
+    (*info->print_address_func) (value, info);
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
+    (*info->print_address_func) (value, info);
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
+    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+  else
+    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+}
+
+/* Keyword print handler.  */
+
+static void
+print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	       void *dis_info,
+	       CGEN_KEYWORD *keyword_table,
+	       long value,
+	       unsigned int attrs ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+  const CGEN_KEYWORD_ENTRY *ke;
+
+  ke = cgen_keyword_lookup_value (keyword_table, value);
+  if (ke != NULL)
+    (*info->fprintf_func) (info->stream, "%s", ke->name);
+  else
+    (*info->fprintf_func) (info->stream, "???");
+}
+
+/* Default insn printer.
+
+   DIS_INFO is defined as `void *' so the disassembler needn't know anything
+   about disassemble_info.  */
+
+static void
+print_insn_normal (CGEN_CPU_DESC cd,
+		   void *dis_info,
+		   const CGEN_INSN *insn,
+		   CGEN_FIELDS *fields,
+		   bfd_vma pc,
+		   int length)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  disassemble_info *info = (disassemble_info *) dis_info;
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+
+  CGEN_INIT_PRINT (cd);
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
+    {
+      if (CGEN_SYNTAX_MNEMONIC_P (*syn))
+	{
+	  (*info->fprintf_func) (info->stream, "%s", CGEN_INSN_MNEMONIC (insn));
+	  continue;
+	}
+      if (CGEN_SYNTAX_CHAR_P (*syn))
+	{
+	  (*info->fprintf_func) (info->stream, "%c", CGEN_SYNTAX_CHAR (*syn));
+	  continue;
+	}
+
+      /* We have an operand.  */
+      ncpu32k_cgen_print_operand (cd, CGEN_SYNTAX_FIELD (*syn), info,
+				 fields, CGEN_INSN_ATTRS (insn), pc, length);
+    }
+}
+
+/* Subroutine of print_insn. Reads an insn into the given buffers and updates
+   the extract info.
+   Returns 0 if all is well, non-zero otherwise.  */
+
+static int
+read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	   bfd_vma pc,
+	   disassemble_info *info,
+	   bfd_byte *buf,
+	   int buflen,
+	   CGEN_EXTRACT_INFO *ex_info,
+	   unsigned long *insn_value)
+{
+  int status = (*info->read_memory_func) (pc, buf, buflen, info);
+
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, pc, info);
+      return -1;
+    }
+
+  ex_info->dis_info = info;
+  ex_info->valid = (1 << buflen) - 1;
+  ex_info->insn_bytes = buf;
+
+  *insn_value = bfd_get_bits (buf, buflen * 8, info->endian == BFD_ENDIAN_BIG);
+  return 0;
+}
+
+/* Utility to print an insn.
+   BUF is the base part of the insn, target byte order, BUFLEN bytes long.
+   The result is the size of the insn in bytes or zero for an unknown insn
+   or -1 if an error occurs fetching data (memory_error_func will have
+   been called).  */
+
+static int
+print_insn (CGEN_CPU_DESC cd,
+	    bfd_vma pc,
+	    disassemble_info *info,
+	    bfd_byte *buf,
+	    unsigned int buflen)
+{
+  CGEN_INSN_INT insn_value;
+  const CGEN_INSN_LIST *insn_list;
+  CGEN_EXTRACT_INFO ex_info;
+  int basesize;
+
+  /* Extract base part of instruction, just in case CGEN_DIS_* uses it. */
+  basesize = cd->base_insn_bitsize < buflen * 8 ?
+                                     cd->base_insn_bitsize : buflen * 8;
+  insn_value = cgen_get_insn_value (cd, buf, basesize);
+
+
+  /* Fill in ex_info fields like read_insn would.  Don't actually call
+     read_insn, since the incoming buffer is already read (and possibly
+     modified a la m32r).  */
+  ex_info.valid = (1 << buflen) - 1;
+  ex_info.dis_info = info;
+  ex_info.insn_bytes = buf;
+
+  /* The instructions are stored in hash lists.
+     Pick the first one and keep trying until we find the right one.  */
+
+  insn_list = CGEN_DIS_LOOKUP_INSN (cd, (char *) buf, insn_value);
+  while (insn_list != NULL)
+    {
+      const CGEN_INSN *insn = insn_list->insn;
+      CGEN_FIELDS fields;
+      int length;
+      unsigned long insn_value_cropped;
+
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED
+      /* Not needed as insn shouldn't be in hash lists if not supported.  */
+      /* Supported by this cpu?  */
+      if (! ncpu32k_cgen_insn_supported (cd, insn))
+        {
+          insn_list = CGEN_DIS_NEXT_INSN (insn_list);
+	  continue;
+        }
+#endif
+
+      /* Basic bit mask must be correct.  */
+      /* ??? May wish to allow target to defer this check until the extract
+	 handler.  */
+
+      /* Base size may exceed this instruction's size.  Extract the
+         relevant part from the buffer. */
+      if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn),
+					   info->endian == BFD_ENDIAN_BIG);
+      else
+	insn_value_cropped = insn_value;
+
+      if ((insn_value_cropped & CGEN_INSN_BASE_MASK (insn))
+	  == CGEN_INSN_BASE_VALUE (insn))
+	{
+	  /* Printing is handled in two passes.  The first pass parses the
+	     machine insn and extracts the fields.  The second pass prints
+	     them.  */
+
+	  /* Make sure the entire insn is loaded into insn_value, if it
+	     can fit.  */
+	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	    {
+	      unsigned long full_insn_value;
+	      int rc = read_insn (cd, pc, info, buf,
+				  CGEN_INSN_BITSIZE (insn) / 8,
+				  & ex_info, & full_insn_value);
+	      if (rc != 0)
+		return rc;
+	      length = CGEN_EXTRACT_FN (cd, insn)
+		(cd, insn, &ex_info, full_insn_value, &fields, pc);
+	    }
+	  else
+	    length = CGEN_EXTRACT_FN (cd, insn)
+	      (cd, insn, &ex_info, insn_value_cropped, &fields, pc);
+
+	  /* Length < 0 -> error.  */
+	  if (length < 0)
+	    return length;
+	  if (length > 0)
+	    {
+	      CGEN_PRINT_FN (cd, insn) (cd, info, insn, &fields, pc, length);
+	      /* Length is in bits, result is in bytes.  */
+	      return length / 8;
+	    }
+	}
+
+      insn_list = CGEN_DIS_NEXT_INSN (insn_list);
+    }
+
+  return 0;
+}
+
+/* Default value for CGEN_PRINT_INSN.
+   The result is the size of the insn in bytes or zero for an unknown insn
+   or -1 if an error occured fetching bytes.  */
+
+#ifndef CGEN_PRINT_INSN
+#define CGEN_PRINT_INSN default_print_insn
+#endif
+
+static int
+default_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
+{
+  bfd_byte buf[CGEN_MAX_INSN_SIZE];
+  int buflen;
+  int status;
+
+  /* Attempt to read the base part of the insn.  */
+  buflen = cd->base_insn_bitsize / 8;
+  status = (*info->read_memory_func) (pc, buf, buflen, info);
+
+  /* Try again with the minimum part, if min < base.  */
+  if (status != 0 && (cd->min_insn_bitsize < cd->base_insn_bitsize))
+    {
+      buflen = cd->min_insn_bitsize / 8;
+      status = (*info->read_memory_func) (pc, buf, buflen, info);
+    }
+
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, pc, info);
+      return -1;
+    }
+
+  return print_insn (cd, pc, info, buf, buflen);
+}
+
+/* Main entry point.
+   Print one instruction from PC on INFO->STREAM.
+   Return the size of the instruction (in bytes).  */
+
+typedef struct cpu_desc_list
+{
+  struct cpu_desc_list *next;
+  CGEN_BITSET *isa;
+  int mach;
+  int endian;
+  CGEN_CPU_DESC cd;
+} cpu_desc_list;
+
+int
+print_insn_ncpu32k (bfd_vma pc, disassemble_info *info)
+{
+  static cpu_desc_list *cd_list = 0;
+  cpu_desc_list *cl = 0;
+  static CGEN_CPU_DESC cd = 0;
+  static CGEN_BITSET *prev_isa;
+  static int prev_mach;
+  static int prev_endian;
+  int length;
+  CGEN_BITSET *isa;
+  int mach;
+  int endian = (info->endian == BFD_ENDIAN_BIG
+		? CGEN_ENDIAN_BIG
+		: CGEN_ENDIAN_LITTLE);
+  enum bfd_architecture arch;
+
+  /* ??? gdb will set mach but leave the architecture as "unknown" */
+#ifndef CGEN_BFD_ARCH
+#define CGEN_BFD_ARCH bfd_arch_ncpu32k
+#endif
+  arch = info->arch;
+  if (arch == bfd_arch_unknown)
+    arch = CGEN_BFD_ARCH;
+
+  /* There's no standard way to compute the machine or isa number
+     so we leave it to the target.  */
+#ifdef CGEN_COMPUTE_MACH
+  mach = CGEN_COMPUTE_MACH (info);
+#else
+  mach = info->mach;
+#endif
+
+#ifdef CGEN_COMPUTE_ISA
+  {
+    static CGEN_BITSET *permanent_isa;
+
+    if (!permanent_isa)
+      permanent_isa = cgen_bitset_create (MAX_ISAS);
+    isa = permanent_isa;
+    cgen_bitset_clear (isa);
+    cgen_bitset_add (isa, CGEN_COMPUTE_ISA (info));
+  }
+#else
+  isa = info->insn_sets;
+#endif
+
+  /* If we've switched cpu's, try to find a handle we've used before */
+  if (cd
+      && (cgen_bitset_compare (isa, prev_isa) != 0
+	  || mach != prev_mach
+	  || endian != prev_endian))
+    {
+      cd = 0;
+      for (cl = cd_list; cl; cl = cl->next)
+	{
+	  if (cgen_bitset_compare (cl->isa, isa) == 0 &&
+	      cl->mach == mach &&
+	      cl->endian == endian)
+	    {
+	      cd = cl->cd;
+ 	      prev_isa = cd->isas;
+	      break;
+	    }
+	}
+    }
+
+  /* If we haven't initialized yet, initialize the opcode table.  */
+  if (! cd)
+    {
+      const bfd_arch_info_type *arch_type = bfd_lookup_arch (arch, mach);
+      const char *mach_name;
+
+      if (!arch_type)
+	abort ();
+      mach_name = arch_type->printable_name;
+
+      prev_isa = cgen_bitset_copy (isa);
+      prev_mach = mach;
+      prev_endian = endian;
+      cd = ncpu32k_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,
+				 CGEN_CPU_OPEN_BFDMACH, mach_name,
+				 CGEN_CPU_OPEN_ENDIAN, prev_endian,
+				 CGEN_CPU_OPEN_END);
+      if (!cd)
+	abort ();
+
+      /* Save this away for future reference.  */
+      cl = xmalloc (sizeof (struct cpu_desc_list));
+      cl->cd = cd;
+      cl->isa = prev_isa;
+      cl->mach = mach;
+      cl->endian = endian;
+      cl->next = cd_list;
+      cd_list = cl;
+
+      ncpu32k_cgen_init_dis (cd);
+    }
+
+  /* We try to have as much common code as possible.
+     But at this point some targets need to take over.  */
+  /* ??? Some targets may need a hook elsewhere.  Try to avoid this,
+     but if not possible try to move this hook elsewhere rather than
+     have two hooks.  */
+  length = CGEN_PRINT_INSN (cd, pc, info);
+  if (length > 0)
+    return length;
+  if (length < 0)
+    return -1;
+
+  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
+  return cd->default_insn_bitsize / 8;
+}
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-ibld.c binutils-ncpu32k-2.32/opcodes/ncpu32k-ibld.c
--- binutils-2.32/opcodes/ncpu32k-ibld.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-ibld.c	2019-08-12 18:41:23.445368586 +0800
@@ -0,0 +1,871 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Instruction building/extraction support for ncpu32k. -*- C -*-
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN: Cpu tools GENerator.
+   - the resultant file is machine generated, cgen-ibld.in isn't
+
+   Copyright (C) 1996-2019 Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "dis-asm.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+#include "cgen/basic-modes.h"
+#include "opintl.h"
+#include "safe-ctype.h"
+
+#undef  min
+#define min(a,b) ((a) < (b) ? (a) : (b))
+#undef  max
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+/* Used by the ifield rtx function.  */
+#define FLD(f) (fields->f)
+
+static const char * insert_normal
+  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+   unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
+static const char * insert_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *,
+   CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);
+static int extract_normal
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
+   unsigned int, unsigned int, unsigned int, unsigned int,
+   unsigned int, unsigned int, bfd_vma, long *);
+static int extract_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
+   CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
+#if CGEN_INT_INSN_P
+static void put_insn_int_value
+  (CGEN_CPU_DESC, CGEN_INSN_BYTES_PTR, int, int, CGEN_INSN_INT);
+#endif
+#if ! CGEN_INT_INSN_P
+static CGEN_INLINE void insert_1
+  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+static CGEN_INLINE int fill_cache
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
+static CGEN_INLINE long extract_1
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
+#endif
+
+/* Operand insertion.  */
+
+#if ! CGEN_INT_INSN_P
+
+/* Subroutine of insert_normal.  */
+
+static CGEN_INLINE void
+insert_1 (CGEN_CPU_DESC cd,
+	  unsigned long value,
+	  int start,
+	  int length,
+	  int word_length,
+	  unsigned char *bufp)
+{
+  unsigned long x,mask;
+  int shift;
+
+  x = cgen_get_insn_value (cd, bufp, word_length);
+
+  /* Written this way to avoid undefined behaviour.  */
+  mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  if (CGEN_INSN_LSB0_P)
+    shift = (start + 1) - length;
+  else
+    shift = (word_length - (start + length));
+  x = (x & ~(mask << shift)) | ((value & mask) << shift);
+
+  cgen_put_insn_value (cd, bufp, word_length, (bfd_vma) x);
+}
+
+#endif /* ! CGEN_INT_INSN_P */
+
+/* Default insertion routine.
+
+   ATTRS is a mask of the boolean attributes.
+   WORD_OFFSET is the offset in bits from the start of the insn of the value.
+   WORD_LENGTH is the length of the word in bits in which the value resides.
+   START is the starting bit number in the word, architecture origin.
+   LENGTH is the length of VALUE in bits.
+   TOTAL_LENGTH is the total length of the insn in bits.
+
+   The result is an error message or NULL if success.  */
+
+/* ??? This duplicates functionality with bfd's howto table and
+   bfd_install_relocation.  */
+/* ??? This doesn't handle bfd_vma's.  Create another function when
+   necessary.  */
+
+static const char *
+insert_normal (CGEN_CPU_DESC cd,
+	       long value,
+	       unsigned int attrs,
+	       unsigned int word_offset,
+	       unsigned int start,
+	       unsigned int length,
+	       unsigned int word_length,
+	       unsigned int total_length,
+	       CGEN_INSN_BYTES_PTR buffer)
+{
+  static char errbuf[100];
+  /* Written this way to avoid undefined behaviour.  */
+  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+  /* If LENGTH is zero, this operand doesn't contribute to the value.  */
+  if (length == 0)
+    return NULL;
+
+  if (word_length > 8 * sizeof (CGEN_INSN_INT))
+    abort ();
+
+  /* For architectures with insns smaller than the base-insn-bitsize,
+     word_length may be too big.  */
+  if (cd->min_insn_bitsize < cd->base_insn_bitsize)
+    {
+      if (word_offset == 0
+	  && word_length > total_length)
+	word_length = total_length;
+    }
+
+  /* Ensure VALUE will fit.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
+    {
+      long minval = - (1L << (length - 1));
+      unsigned long maxval = mask;
+
+      if ((value > 0 && (unsigned long) value > maxval)
+	  || value < minval)
+	{
+	  /* xgettext:c-format */
+	  sprintf (errbuf,
+		   _("operand out of range (%ld not between %ld and %lu)"),
+		   value, minval, maxval);
+	  return errbuf;
+	}
+    }
+  else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
+    {
+      unsigned long maxval = mask;
+      unsigned long val = (unsigned long) value;
+
+      /* For hosts with a word size > 32 check to see if value has been sign
+	 extended beyond 32 bits.  If so then ignore these higher sign bits
+	 as the user is attempting to store a 32-bit signed value into an
+	 unsigned 32-bit field which is allowed.  */
+      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+	val &= 0xFFFFFFFF;
+
+      if (val > maxval)
+	{
+	  /* xgettext:c-format */
+	  sprintf (errbuf,
+		   _("operand out of range (0x%lx not between 0 and 0x%lx)"),
+		   val, maxval);
+	  return errbuf;
+	}
+    }
+  else
+    {
+      if (! cgen_signed_overflow_ok_p (cd))
+	{
+	  long minval = - (1L << (length - 1));
+	  long maxval =   (1L << (length - 1)) - 1;
+
+	  if (value < minval || value > maxval)
+	    {
+	      sprintf
+		/* xgettext:c-format */
+		(errbuf, _("operand out of range (%ld not between %ld and %ld)"),
+		 value, minval, maxval);
+	      return errbuf;
+	    }
+	}
+    }
+
+#if CGEN_INT_INSN_P
+
+  {
+    int shift_within_word, shift_to_word, shift;
+
+    /* How to shift the value to BIT0 of the word.  */
+    shift_to_word = total_length - (word_offset + word_length);
+
+    /* How to shift the value to the field within the word.  */
+    if (CGEN_INSN_LSB0_P)
+      shift_within_word = start + 1 - length;
+    else
+      shift_within_word = word_length - start - length;
+
+    /* The total SHIFT, then mask in the value.  */
+    shift = shift_to_word + shift_within_word;
+    *buffer = (*buffer & ~(mask << shift)) | ((value & mask) << shift);
+  }
+
+#else /* ! CGEN_INT_INSN_P */
+
+  {
+    unsigned char *bufp = (unsigned char *) buffer + word_offset / 8;
+
+    insert_1 (cd, value, start, length, word_length, bufp);
+  }
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  return NULL;
+}
+
+/* Default insn builder (insert handler).
+   The instruction is recorded in CGEN_INT_INSN_P byte order (meaning
+   that if CGEN_INSN_BYTES_PTR is an int * and thus, the value is
+   recorded in host byte order, otherwise BUFFER is an array of bytes
+   and the value is recorded in target byte order).
+   The result is an error message or NULL if success.  */
+
+static const char *
+insert_insn_normal (CGEN_CPU_DESC cd,
+		    const CGEN_INSN * insn,
+		    CGEN_FIELDS * fields,
+		    CGEN_INSN_BYTES_PTR buffer,
+		    bfd_vma pc)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  unsigned long value;
+  const CGEN_SYNTAX_CHAR_TYPE * syn;
+
+  CGEN_INIT_INSERT (cd);
+  value = CGEN_INSN_BASE_VALUE (insn);
+
+  /* If we're recording insns as numbers (rather than a string of bytes),
+     target byte order handling is deferred until later.  */
+
+#if CGEN_INT_INSN_P
+
+  put_insn_int_value (cd, buffer, cd->base_insn_bitsize,
+		      CGEN_FIELDS_BITSIZE (fields), value);
+
+#else
+
+  cgen_put_insn_value (cd, buffer, min ((unsigned) cd->base_insn_bitsize,
+					(unsigned) CGEN_FIELDS_BITSIZE (fields)),
+		       value);
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  /* ??? It would be better to scan the format's fields.
+     Still need to be able to insert a value based on the operand though;
+     e.g. storing a branch displacement that got resolved later.
+     Needs more thought first.  */
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); * syn; ++ syn)
+    {
+      const char *errmsg;
+
+      if (CGEN_SYNTAX_CHAR_P (* syn))
+	continue;
+
+      errmsg = (* cd->insert_operand) (cd, CGEN_SYNTAX_FIELD (*syn),
+				       fields, buffer, pc);
+      if (errmsg)
+	return errmsg;
+    }
+
+  return NULL;
+}
+
+#if CGEN_INT_INSN_P
+/* Cover function to store an insn value into an integral insn.  Must go here
+   because it needs <prefix>-desc.h for CGEN_INT_INSN_P.  */
+
+static void
+put_insn_int_value (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+		    CGEN_INSN_BYTES_PTR buf,
+		    int length,
+		    int insn_length,
+		    CGEN_INSN_INT value)
+{
+  /* For architectures with insns smaller than the base-insn-bitsize,
+     length may be too big.  */
+  if (length > insn_length)
+    *buf = value;
+  else
+    {
+      int shift = insn_length - length;
+      /* Written this way to avoid undefined behaviour.  */
+      CGEN_INSN_INT mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+      *buf = (*buf & ~(mask << shift)) | ((value & mask) << shift);
+    }
+}
+#endif
+
+/* Operand extraction.  */
+
+#if ! CGEN_INT_INSN_P
+
+/* Subroutine of extract_normal.
+   Ensure sufficient bytes are cached in EX_INFO.
+   OFFSET is the offset in bytes from the start of the insn of the value.
+   BYTES is the length of the needed value.
+   Returns 1 for success, 0 for failure.  */
+
+static CGEN_INLINE int
+fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	    CGEN_EXTRACT_INFO *ex_info,
+	    int offset,
+	    int bytes,
+	    bfd_vma pc)
+{
+  /* It's doubtful that the middle part has already been fetched so
+     we don't optimize that case.  kiss.  */
+  unsigned int mask;
+  disassemble_info *info = (disassemble_info *) ex_info->dis_info;
+
+  /* First do a quick check.  */
+  mask = (1 << bytes) - 1;
+  if (((ex_info->valid >> offset) & mask) == mask)
+    return 1;
+
+  /* Search for the first byte we need to read.  */
+  for (mask = 1 << offset; bytes > 0; --bytes, ++offset, mask <<= 1)
+    if (! (mask & ex_info->valid))
+      break;
+
+  if (bytes)
+    {
+      int status;
+
+      pc += offset;
+      status = (*info->read_memory_func)
+	(pc, ex_info->insn_bytes + offset, bytes, info);
+
+      if (status != 0)
+	{
+	  (*info->memory_error_func) (status, pc, info);
+	  return 0;
+	}
+
+      ex_info->valid |= ((1 << bytes) - 1) << offset;
+    }
+
+  return 1;
+}
+
+/* Subroutine of extract_normal.  */
+
+static CGEN_INLINE long
+extract_1 (CGEN_CPU_DESC cd,
+	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
+	   int start,
+	   int length,
+	   int word_length,
+	   unsigned char *bufp,
+	   bfd_vma pc ATTRIBUTE_UNUSED)
+{
+  unsigned long x;
+  int shift;
+
+  x = cgen_get_insn_value (cd, bufp, word_length);
+
+  if (CGEN_INSN_LSB0_P)
+    shift = (start + 1) - length;
+  else
+    shift = (word_length - (start + length));
+  return x >> shift;
+}
+
+#endif /* ! CGEN_INT_INSN_P */
+
+/* Default extraction routine.
+
+   INSN_VALUE is the first base_insn_bitsize bits of the insn in host order,
+   or sometimes less for cases like the m32r where the base insn size is 32
+   but some insns are 16 bits.
+   ATTRS is a mask of the boolean attributes.  We only need `SIGNED',
+   but for generality we take a bitmask of all of them.
+   WORD_OFFSET is the offset in bits from the start of the insn of the value.
+   WORD_LENGTH is the length of the word in bits in which the value resides.
+   START is the starting bit number in the word, architecture origin.
+   LENGTH is the length of VALUE in bits.
+   TOTAL_LENGTH is the total length of the insn in bits.
+
+   Returns 1 for success, 0 for failure.  */
+
+/* ??? The return code isn't properly used.  wip.  */
+
+/* ??? This doesn't handle bfd_vma's.  Create another function when
+   necessary.  */
+
+static int
+extract_normal (CGEN_CPU_DESC cd,
+#if ! CGEN_INT_INSN_P
+		CGEN_EXTRACT_INFO *ex_info,
+#else
+		CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
+#endif
+		CGEN_INSN_INT insn_value,
+		unsigned int attrs,
+		unsigned int word_offset,
+		unsigned int start,
+		unsigned int length,
+		unsigned int word_length,
+		unsigned int total_length,
+#if ! CGEN_INT_INSN_P
+		bfd_vma pc,
+#else
+		bfd_vma pc ATTRIBUTE_UNUSED,
+#endif
+		long *valuep)
+{
+  long value, mask;
+
+  /* If LENGTH is zero, this operand doesn't contribute to the value
+     so give it a standard value of zero.  */
+  if (length == 0)
+    {
+      *valuep = 0;
+      return 1;
+    }
+
+  if (word_length > 8 * sizeof (CGEN_INSN_INT))
+    abort ();
+
+  /* For architectures with insns smaller than the insn-base-bitsize,
+     word_length may be too big.  */
+  if (cd->min_insn_bitsize < cd->base_insn_bitsize)
+    {
+      if (word_offset + word_length > total_length)
+	word_length = total_length - word_offset;
+    }
+
+  /* Does the value reside in INSN_VALUE, and at the right alignment?  */
+
+  if (CGEN_INT_INSN_P || (word_offset == 0 && word_length == total_length))
+    {
+      if (CGEN_INSN_LSB0_P)
+	value = insn_value >> ((word_offset + start + 1) - length);
+      else
+	value = insn_value >> (total_length - ( word_offset + start + length));
+    }
+
+#if ! CGEN_INT_INSN_P
+
+  else
+    {
+      unsigned char *bufp = ex_info->insn_bytes + word_offset / 8;
+
+      if (word_length > 8 * sizeof (CGEN_INSN_INT))
+	abort ();
+
+      if (fill_cache (cd, ex_info, word_offset / 8, word_length / 8, pc) == 0)
+	return 0;
+
+      value = extract_1 (cd, ex_info, start, length, word_length, bufp, pc);
+    }
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  /* Written this way to avoid undefined behaviour.  */
+  mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+  value &= mask;
+  /* sign extend? */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED)
+      && (value & (1L << (length - 1))))
+    value |= ~mask;
+
+  *valuep = value;
+
+  return 1;
+}
+
+/* Default insn extractor.
+
+   INSN_VALUE is the first base_insn_bitsize bits, translated to host order.
+   The extracted fields are stored in FIELDS.
+   EX_INFO is used to handle reading variable length insns.
+   Return the length of the insn in bits, or 0 if no match,
+   or -1 if an error occurs fetching data (memory_error_func will have
+   been called).  */
+
+static int
+extract_insn_normal (CGEN_CPU_DESC cd,
+		     const CGEN_INSN *insn,
+		     CGEN_EXTRACT_INFO *ex_info,
+		     CGEN_INSN_INT insn_value,
+		     CGEN_FIELDS *fields,
+		     bfd_vma pc)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+
+  CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);
+
+  CGEN_INIT_EXTRACT (cd);
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
+    {
+      int length;
+
+      if (CGEN_SYNTAX_CHAR_P (*syn))
+	continue;
+
+      length = (* cd->extract_operand) (cd, CGEN_SYNTAX_FIELD (*syn),
+					ex_info, insn_value, fields, pc);
+      if (length <= 0)
+	return length;
+    }
+
+  /* We recognized and successfully extracted this insn.  */
+  return CGEN_INSN_BITSIZE (insn);
+}
+
+/* Machine generated code added here.  */
+
+const char * ncpu32k_cgen_insert_operand
+  (CGEN_CPU_DESC, int, CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);
+
+/* Main entry point for operand insertion.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `parse_insn_normal', but keeping it
+   separate makes clear the interface between `parse_insn_normal' and each of
+   the handlers.  It's also needed by GAS to insert operands that couldn't be
+   resolved during parsing.  */
+
+const char *
+ncpu32k_cgen_insert_operand (CGEN_CPU_DESC cd,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     CGEN_INSN_BYTES_PTR buffer,
+			     bfd_vma pc ATTRIBUTE_UNUSED)
+{
+  const char * errmsg = NULL;
+  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      errmsg = insert_normal (cd, fields->f_rd, 0, 0, 10, 5, 16, total_length, buffer);
+      break;
+    case NCPU32K_OPERAND_REL16 :
+      {
+        long value = fields->f_rel16;
+        value = ((SI) (((value) - (pc))) >> (1));
+        errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 16, 15, 16, 16, total_length, buffer);
+      }
+      break;
+    case NCPU32K_OPERAND_REL21 :
+      {
+        long value = fields->f_rel21;
+        value = ((SI) (((value) - (pc))) >> (1));
+        errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 31, 21, 32, total_length, buffer);
+      }
+      break;
+    case NCPU32K_OPERAND_RS :
+      errmsg = insert_normal (cd, fields->f_rs, 0, 0, 15, 5, 16, total_length, buffer);
+      break;
+    case NCPU32K_OPERAND_SIMM16 :
+      errmsg = insert_normal (cd, fields->f_simm16, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_SIGN_OPT), 16, 15, 16, 16, total_length, buffer);
+      break;
+    case NCPU32K_OPERAND_UIMM16 :
+      errmsg = insert_normal (cd, fields->f_uimm16, 0, 16, 15, 16, 16, total_length, buffer);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while building insn.\n"),
+	       opindex);
+      abort ();
+  }
+
+  return errmsg;
+}
+
+int ncpu32k_cgen_extract_operand
+  (CGEN_CPU_DESC, int, CGEN_EXTRACT_INFO *, CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
+
+/* Main entry point for operand extraction.
+   The result is <= 0 for error, >0 for success.
+   ??? Actual values aren't well defined right now.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `print_insn_normal', but keeping it
+   separate makes clear the interface between `print_insn_normal' and each of
+   the handlers.  */
+
+int
+ncpu32k_cgen_extract_operand (CGEN_CPU_DESC cd,
+			     int opindex,
+			     CGEN_EXTRACT_INFO *ex_info,
+			     CGEN_INSN_INT insn_value,
+			     CGEN_FIELDS * fields,
+			     bfd_vma pc)
+{
+  /* Assume success (for those operands that are nops).  */
+  int length = 1;
+  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 10, 5, 16, total_length, pc, & fields->f_rd);
+      break;
+    case NCPU32K_OPERAND_REL16 :
+      {
+        long value;
+        length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 16, 15, 16, 16, total_length, pc, & value);
+        value = ((((value) << (1))) + (pc));
+        fields->f_rel16 = value;
+      }
+      break;
+    case NCPU32K_OPERAND_REL21 :
+      {
+        long value;
+        length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 31, 21, 32, total_length, pc, & value);
+        value = ((((value) << (1))) + (pc));
+        fields->f_rel21 = value;
+      }
+      break;
+    case NCPU32K_OPERAND_RS :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 5, 16, total_length, pc, & fields->f_rs);
+      break;
+    case NCPU32K_OPERAND_SIMM16 :
+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_SIGN_OPT), 16, 15, 16, 16, total_length, pc, & fields->f_simm16);
+      break;
+    case NCPU32K_OPERAND_UIMM16 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 16, 15, 16, 16, total_length, pc, & fields->f_uimm16);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while decoding insn.\n"),
+	       opindex);
+      abort ();
+    }
+
+  return length;
+}
+
+cgen_insert_fn * const ncpu32k_cgen_insert_handlers[] =
+{
+  insert_insn_normal,
+};
+
+cgen_extract_fn * const ncpu32k_cgen_extract_handlers[] =
+{
+  extract_insn_normal,
+};
+
+int ncpu32k_cgen_get_int_operand     (CGEN_CPU_DESC, int, const CGEN_FIELDS *);
+bfd_vma ncpu32k_cgen_get_vma_operand (CGEN_CPU_DESC, int, const CGEN_FIELDS *);
+
+/* Getting values from cgen_fields is handled by a collection of functions.
+   They are distinguished by the type of the VALUE argument they return.
+   TODO: floating point, inlining support, remove cases where result type
+   not appropriate.  */
+
+int
+ncpu32k_cgen_get_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     const CGEN_FIELDS * fields)
+{
+  int value;
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      value = fields->f_rd;
+      break;
+    case NCPU32K_OPERAND_REL16 :
+      value = fields->f_rel16;
+      break;
+    case NCPU32K_OPERAND_REL21 :
+      value = fields->f_rel21;
+      break;
+    case NCPU32K_OPERAND_RS :
+      value = fields->f_rs;
+      break;
+    case NCPU32K_OPERAND_SIMM16 :
+      value = fields->f_simm16;
+      break;
+    case NCPU32K_OPERAND_UIMM16 :
+      value = fields->f_uimm16;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while getting int operand.\n"),
+		       opindex);
+      abort ();
+  }
+
+  return value;
+}
+
+bfd_vma
+ncpu32k_cgen_get_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     const CGEN_FIELDS * fields)
+{
+  bfd_vma value;
+
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      value = fields->f_rd;
+      break;
+    case NCPU32K_OPERAND_REL16 :
+      value = fields->f_rel16;
+      break;
+    case NCPU32K_OPERAND_REL21 :
+      value = fields->f_rel21;
+      break;
+    case NCPU32K_OPERAND_RS :
+      value = fields->f_rs;
+      break;
+    case NCPU32K_OPERAND_SIMM16 :
+      value = fields->f_simm16;
+      break;
+    case NCPU32K_OPERAND_UIMM16 :
+      value = fields->f_uimm16;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while getting vma operand.\n"),
+		       opindex);
+      abort ();
+  }
+
+  return value;
+}
+
+void ncpu32k_cgen_set_int_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, int);
+void ncpu32k_cgen_set_vma_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, bfd_vma);
+
+/* Stuffing values in cgen_fields is handled by a collection of functions.
+   They are distinguished by the type of the VALUE argument they accept.
+   TODO: floating point, inlining support, remove cases where argument type
+   not appropriate.  */
+
+void
+ncpu32k_cgen_set_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     int value)
+{
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      fields->f_rd = value;
+      break;
+    case NCPU32K_OPERAND_REL16 :
+      fields->f_rel16 = value;
+      break;
+    case NCPU32K_OPERAND_REL21 :
+      fields->f_rel21 = value;
+      break;
+    case NCPU32K_OPERAND_RS :
+      fields->f_rs = value;
+      break;
+    case NCPU32K_OPERAND_SIMM16 :
+      fields->f_simm16 = value;
+      break;
+    case NCPU32K_OPERAND_UIMM16 :
+      fields->f_uimm16 = value;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while setting int operand.\n"),
+		       opindex);
+      abort ();
+  }
+}
+
+void
+ncpu32k_cgen_set_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     bfd_vma value)
+{
+  switch (opindex)
+    {
+    case NCPU32K_OPERAND_RD :
+      fields->f_rd = value;
+      break;
+    case NCPU32K_OPERAND_REL16 :
+      fields->f_rel16 = value;
+      break;
+    case NCPU32K_OPERAND_REL21 :
+      fields->f_rel21 = value;
+      break;
+    case NCPU32K_OPERAND_RS :
+      fields->f_rs = value;
+      break;
+    case NCPU32K_OPERAND_SIMM16 :
+      fields->f_simm16 = value;
+      break;
+    case NCPU32K_OPERAND_UIMM16 :
+      fields->f_uimm16 = value;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while setting vma operand.\n"),
+		       opindex);
+      abort ();
+  }
+}
+
+/* Function to call before using the instruction builder tables.  */
+
+void
+ncpu32k_cgen_init_ibld_table (CGEN_CPU_DESC cd)
+{
+  cd->insert_handlers = & ncpu32k_cgen_insert_handlers[0];
+  cd->extract_handlers = & ncpu32k_cgen_extract_handlers[0];
+
+  cd->insert_operand = ncpu32k_cgen_insert_operand;
+  cd->extract_operand = ncpu32k_cgen_extract_operand;
+
+  cd->get_int_operand = ncpu32k_cgen_get_int_operand;
+  cd->set_int_operand = ncpu32k_cgen_set_int_operand;
+  cd->get_vma_operand = ncpu32k_cgen_get_vma_operand;
+  cd->set_vma_operand = ncpu32k_cgen_set_vma_operand;
+}
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-opc.c binutils-ncpu32k-2.32/opcodes/ncpu32k-opc.c
--- binutils-2.32/opcodes/ncpu32k-opc.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-opc.c	2019-08-12 18:41:23.429368585 +0800
@@ -0,0 +1,530 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Instruction opcode table for ncpu32k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+#include "libiberty.h"
+
+/* -- opc.c */
+/* -- */
+/* The hash functions are recorded here to help keep assembler code out of
+   the disassembler and vice versa.  */
+
+static int asm_hash_insn_p        (const CGEN_INSN *);
+static unsigned int asm_hash_insn (const char *);
+static int dis_hash_insn_p        (const CGEN_INSN *);
+static unsigned int dis_hash_insn (const char *, CGEN_INSN_INT);
+
+/* Instruction formats.  */
+
+#define F(f) & ncpu32k_cgen_ifld_table[NCPU32K_##f]
+static const CGEN_IFMT ifmt_empty ATTRIBUTE_UNUSED = {
+  0, 0, 0x0, { { 0 } }
+};
+
+static const CGEN_IFMT ifmt_nop ATTRIBUTE_UNUSED = {
+  16, 16, 0xffff, { { F (F_RES_RS) }, { F (F_RES_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_mov ATTRIBUTE_UNUSED = {
+  16, 32, 0x3f, { { F (F_RS) }, { F (F_RES_IMM16) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_mov_i ATTRIBUTE_UNUSED = {
+  16, 32, 0xf83f, { { F (F_RES_RS) }, { F (F_UIMM16) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_and ATTRIBUTE_UNUSED = {
+  16, 16, 0x3f, { { F (F_RS) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_and_i ATTRIBUTE_UNUSED = {
+  16, 32, 0x3f, { { F (F_RS) }, { F (F_UIMM16) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_xor_i ATTRIBUTE_UNUSED = {
+  16, 32, 0x3f, { { F (F_RS) }, { F (F_SIMM16) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_jmp_i ATTRIBUTE_UNUSED = {
+  16, 32, 0x3f, { { F (F_REL21) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_bgt ATTRIBUTE_UNUSED = {
+  16, 32, 0x3f, { { F (F_RS) }, { F (F_REL16) }, { F (F_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_exc ATTRIBUTE_UNUSED = {
+  16, 32, 0xffff, { { F (F_RES_RS) }, { F (F_UIMM16) }, { F (F_RES_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_barr ATTRIBUTE_UNUSED = {
+  16, 32, 0xffff, { { F (F_RES_RS) }, { F (F_RES_IMM16) }, { F (F_RES_RD) }, { F (F_OPCODE) }, { 0 } }
+};
+
+#undef F
+
+#define A(a) (1 << CGEN_INSN_##a)
+#define OPERAND(op) NCPU32K_OPERAND_##op
+#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+
+/* The instruction table.  */
+
+static const CGEN_OPCODE ncpu32k_cgen_insn_opcode_table[MAX_INSNS] =
+{
+  /* Special null first entry.
+     A `num' value of zero is thus invalid.
+     Also, the special `invalid' insn resides here.  */
+  { { 0, 0, 0, 0 }, {{0}}, 0, {0}},
+/* nop */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_nop, { 0x2 }
+  },
+/* mov $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_mov, { 0x3 }
+  },
+/* mov $rd,$uimm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (UIMM16), 0 } },
+    & ifmt_mov_i, { 0x3 }
+  },
+/* mov hi($rd),$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', 'h', 'i', '(', OP (RD), ')', ',', OP (RS), 0 } },
+    & ifmt_mov, { 0x16 }
+  },
+/* and $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x0 }
+  },
+/* and $rd,$rs,$uimm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (UIMM16), 0 } },
+    & ifmt_and_i, { 0x1 }
+  },
+/* or $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x2 }
+  },
+/* or $rd,$rs,$uimm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (UIMM16), 0 } },
+    & ifmt_and_i, { 0x3 }
+  },
+/* xor $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x4 }
+  },
+/* xor $rd,$rs,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (SIMM16), 0 } },
+    & ifmt_xor_i, { 0x5 }
+  },
+/* lsl $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x6 }
+  },
+/* lsl $rd,$rs,${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (UIMM16), 0 } },
+    & ifmt_and_i, { 0x7 }
+  },
+/* lsr $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x8 }
+  },
+/* lsr $rd,$rs,${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (UIMM16), 0 } },
+    & ifmt_and_i, { 0x9 }
+  },
+/* asr $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x17 }
+  },
+/* asr $rd,$rs,${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (UIMM16), 0 } },
+    & ifmt_and_i, { 0x18 }
+  },
+/* add $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x19 }
+  },
+/* add $rd,$rs,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (SIMM16), 0 } },
+    & ifmt_xor_i, { 0x1a }
+  },
+/* sub $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x1b }
+  },
+/* mul $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x1c }
+  },
+/* mulu $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x1d }
+  },
+/* div $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x1e }
+  },
+/* divu $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x1f }
+  },
+/* mod $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0x20 }
+  },
+/* mov hi($rd),${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', 'h', 'i', '(', OP (RD), ')', ',', OP (UIMM16), 0 } },
+    & ifmt_mov_i, { 0x27 }
+  },
+/* rsmr $rd,$rs,${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (UIMM16), 0 } },
+    & ifmt_and_i, { 0x16 }
+  },
+/* wsmr $rd,$rs,${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (UIMM16), 0 } },
+    & ifmt_and_i, { 0x15 }
+  },
+/* jmp $rd,$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), 0 } },
+    & ifmt_and, { 0xa }
+  },
+/* jmp $rd,${rel21} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (REL21), 0 } },
+    & ifmt_jmp_i, { 0xb }
+  },
+/* beq $rd,$rs,${rel16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (REL16), 0 } },
+    & ifmt_xor_i, { 0xc }
+  },
+/* bne $rd,$rs,${rel16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (REL16), 0 } },
+    & ifmt_xor_i, { 0xd }
+  },
+/* bgt $rd,$rs,${rel16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (REL16), 0 } },
+    & ifmt_bgt, { 0xe }
+  },
+/* ble $rd,$rs,${rel16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RS), ',', OP (REL16), 0 } },
+    & ifmt_bgt, { 0xf }
+  },
+/* ld $rd,@byte,${simm16}($rs) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', '@', 'b', 'y', 't', 'e', ',', OP (SIMM16), '(', OP (RS), ')', 0 } },
+    & ifmt_xor_i, { 0x21 }
+  },
+/* ldu $rd,@byte,${simm16}($rs) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', '@', 'b', 'y', 't', 'e', ',', OP (SIMM16), '(', OP (RS), ')', 0 } },
+    & ifmt_xor_i, { 0x22 }
+  },
+/* ld $rd,@hword,${simm16}($rs) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', '@', 'h', 'w', 'o', 'r', 'd', ',', OP (SIMM16), '(', OP (RS), ')', 0 } },
+    & ifmt_xor_i, { 0x23 }
+  },
+/* ldu $rd,@hword,${simm16}($rs) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', '@', 'h', 'w', 'o', 'r', 'd', ',', OP (SIMM16), '(', OP (RS), ')', 0 } },
+    & ifmt_xor_i, { 0x24 }
+  },
+/* ldu $rd,@word,${simm16}($rs) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', '@', 'w', 'o', 'r', 'd', ',', OP (SIMM16), '(', OP (RS), ')', 0 } },
+    & ifmt_xor_i, { 0x10 }
+  },
+/* st @byte,${simm16}($rd),$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', '@', 'b', 'y', 't', 'e', ',', OP (SIMM16), '(', OP (RD), ')', ',', OP (RS), 0 } },
+    & ifmt_xor_i, { 0x25 }
+  },
+/* st @hword,${simm16}($rd),$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', '@', 'h', 'w', 'o', 'r', 'd', ',', OP (SIMM16), '(', OP (RD), ')', ',', OP (RS), 0 } },
+    & ifmt_xor_i, { 0x26 }
+  },
+/* st @word,${simm16}($rd),$rs */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', '@', 'w', 'o', 'r', 'd', ',', OP (SIMM16), '(', OP (RD), ')', ',', OP (RS), 0 } },
+    & ifmt_xor_i, { 0x11 }
+  },
+/* exc ${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (UIMM16), 0 } },
+    & ifmt_exc, { 0x13 }
+  },
+/* barr */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_barr, { 0x12 }
+  },
+/* ret */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_barr, { 0x14 }
+  },
+/* pcrp $rd,${rel21} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (REL21), 0 } },
+    & ifmt_jmp_i, { 0x2f }
+  },
+};
+
+#undef A
+#undef OPERAND
+#undef MNEM
+#undef OP
+
+/* Formats for ALIAS macro-insns.  */
+
+#define F(f) & ncpu32k_cgen_ifld_table[NCPU32K_##f]
+#undef F
+
+/* Each non-simple macro entry points to an array of expansion possibilities.  */
+
+#define A(a) (1 << CGEN_INSN_##a)
+#define OPERAND(op) NCPU32K_OPERAND_##op
+#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+
+/* The macro instruction table.  */
+
+static const CGEN_IBASE ncpu32k_cgen_macro_insn_table[] =
+{
+};
+
+/* The macro instruction opcode table.  */
+
+static const CGEN_OPCODE ncpu32k_cgen_macro_insn_opcode_table[] =
+{
+};
+
+#undef A
+#undef OPERAND
+#undef MNEM
+#undef OP
+
+#ifndef CGEN_ASM_HASH_P
+#define CGEN_ASM_HASH_P(insn) 1
+#endif
+
+#ifndef CGEN_DIS_HASH_P
+#define CGEN_DIS_HASH_P(insn) 1
+#endif
+
+/* Return non-zero if INSN is to be added to the hash table.
+   Targets are free to override CGEN_{ASM,DIS}_HASH_P in the .opc file.  */
+
+static int
+asm_hash_insn_p (const CGEN_INSN *insn ATTRIBUTE_UNUSED)
+{
+  return CGEN_ASM_HASH_P (insn);
+}
+
+static int
+dis_hash_insn_p (const CGEN_INSN *insn)
+{
+  /* If building the hash table and the NO-DIS attribute is present,
+     ignore.  */
+  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_NO_DIS))
+    return 0;
+  return CGEN_DIS_HASH_P (insn);
+}
+
+#ifndef CGEN_ASM_HASH
+#define CGEN_ASM_HASH_SIZE 127
+#ifdef CGEN_MNEMONIC_OPERANDS
+#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE)
+#else
+#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE) /*FIXME*/
+#endif
+#endif
+
+/* It doesn't make much sense to provide a default here,
+   but while this is under development we do.
+   BUFFER is a pointer to the bytes of the insn, target order.
+   VALUE is the first base_insn_bitsize bits as an int in host order.  */
+
+#ifndef CGEN_DIS_HASH
+#define CGEN_DIS_HASH_SIZE 256
+#define CGEN_DIS_HASH(buf, value) (*(unsigned char *) (buf))
+#endif
+
+/* The result is the hash value of the insn.
+   Targets are free to override CGEN_{ASM,DIS}_HASH in the .opc file.  */
+
+static unsigned int
+asm_hash_insn (const char *mnem)
+{
+  return CGEN_ASM_HASH (mnem);
+}
+
+/* BUF is a pointer to the bytes of the insn, target order.
+   VALUE is the first base_insn_bitsize bits as an int in host order.  */
+
+static unsigned int
+dis_hash_insn (const char *buf ATTRIBUTE_UNUSED,
+		     CGEN_INSN_INT value ATTRIBUTE_UNUSED)
+{
+  return CGEN_DIS_HASH (buf, value);
+}
+
+/* Set the recorded length of the insn in the CGEN_FIELDS struct.  */
+
+static void
+set_fields_bitsize (CGEN_FIELDS *fields, int size)
+{
+  CGEN_FIELDS_BITSIZE (fields) = size;
+}
+
+/* Function to call before using the operand instance table.
+   This plugs the opcode entries and macro instructions into the cpu table.  */
+
+void
+ncpu32k_cgen_init_opcode_table (CGEN_CPU_DESC cd)
+{
+  int i;
+  int num_macros = (sizeof (ncpu32k_cgen_macro_insn_table) /
+		    sizeof (ncpu32k_cgen_macro_insn_table[0]));
+  const CGEN_IBASE *ib = & ncpu32k_cgen_macro_insn_table[0];
+  const CGEN_OPCODE *oc = & ncpu32k_cgen_macro_insn_opcode_table[0];
+  CGEN_INSN *insns = xmalloc (num_macros * sizeof (CGEN_INSN));
+
+  /* This test has been added to avoid a warning generated
+     if memset is called with a third argument of value zero.  */
+  if (num_macros >= 1)
+    memset (insns, 0, num_macros * sizeof (CGEN_INSN));
+  for (i = 0; i < num_macros; ++i)
+    {
+      insns[i].base = &ib[i];
+      insns[i].opcode = &oc[i];
+      ncpu32k_cgen_build_insn_regex (& insns[i]);
+    }
+  cd->macro_insn_table.init_entries = insns;
+  cd->macro_insn_table.entry_size = sizeof (CGEN_IBASE);
+  cd->macro_insn_table.num_init_entries = num_macros;
+
+  oc = & ncpu32k_cgen_insn_opcode_table[0];
+  insns = (CGEN_INSN *) cd->insn_table.init_entries;
+  for (i = 0; i < MAX_INSNS; ++i)
+    {
+      insns[i].opcode = &oc[i];
+      ncpu32k_cgen_build_insn_regex (& insns[i]);
+    }
+
+  cd->sizeof_fields = sizeof (CGEN_FIELDS);
+  cd->set_fields_bitsize = set_fields_bitsize;
+
+  cd->asm_hash_p = asm_hash_insn_p;
+  cd->asm_hash = asm_hash_insn;
+  cd->asm_hash_size = CGEN_ASM_HASH_SIZE;
+
+  cd->dis_hash_p = dis_hash_insn_p;
+  cd->dis_hash = dis_hash_insn;
+  cd->dis_hash_size = CGEN_DIS_HASH_SIZE;
+}
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-opc.h binutils-ncpu32k-2.32/opcodes/ncpu32k-opc.h
--- binutils-2.32/opcodes/ncpu32k-opc.h	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-opc.h	2019-08-12 18:41:23.421368585 +0800
@@ -0,0 +1,100 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Instruction opcode header for ncpu32k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef NCPU32K_OPC_H
+#define NCPU32K_OPC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* -- opc.h */
+
+#undef  CGEN_DIS_HASH_SIZE
+#define CGEN_DIS_HASH_SIZE 256
+#undef  CGEN_DIS_HASH
+#define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] & 0x3f) // opcode[5..0]
+
+/* -- */
+/* Enum declaration for ncpu32k instruction types.  */
+typedef enum cgen_insn_type {
+  NCPU32K_INSN_INVALID, NCPU32K_INSN_NOP, NCPU32K_INSN_MOV, NCPU32K_INSN_MOV_I
+ , NCPU32K_INSN_MOVH, NCPU32K_INSN_AND, NCPU32K_INSN_AND_I, NCPU32K_INSN_OR
+ , NCPU32K_INSN_OR_I, NCPU32K_INSN_XOR, NCPU32K_INSN_XOR_I, NCPU32K_INSN_LSL
+ , NCPU32K_INSN_LSL_I, NCPU32K_INSN_LSR, NCPU32K_INSN_LSR_I, NCPU32K_INSN_ASR
+ , NCPU32K_INSN_ASR_I, NCPU32K_INSN_ADD, NCPU32K_INSN_ADD_I, NCPU32K_INSN_SUB
+ , NCPU32K_INSN_MUL, NCPU32K_INSN_MULU, NCPU32K_INSN_DIV, NCPU32K_INSN_DIVU
+ , NCPU32K_INSN_MOD, NCPU32K_INSN_MHI, NCPU32K_INSN_RSMR, NCPU32K_INSN_WSMR
+ , NCPU32K_INSN_JMP, NCPU32K_INSN_JMP_I, NCPU32K_INSN_BEQ, NCPU32K_INSN_BNE
+ , NCPU32K_INSN_BGT, NCPU32K_INSN_BLE, NCPU32K_INSN_LDB, NCPU32K_INSN_LDBU
+ , NCPU32K_INSN_LDH, NCPU32K_INSN_LDHU, NCPU32K_INSN_LDWU, NCPU32K_INSN_STB
+ , NCPU32K_INSN_STH, NCPU32K_INSN_STW, NCPU32K_INSN_EXC, NCPU32K_INSN_BARR
+ , NCPU32K_INSN_RET, NCPU32K_INSN_PCRP
+} CGEN_INSN_TYPE;
+
+/* Index of `invalid' insn place holder.  */
+#define CGEN_INSN_INVALID NCPU32K_INSN_INVALID
+
+/* Total number of insns in table.  */
+#define MAX_INSNS ((int) NCPU32K_INSN_PCRP + 1)
+
+/* This struct records data prior to insertion or after extraction.  */
+struct cgen_fields
+{
+  int length;
+  long f_nil;
+  long f_anyof;
+  long f_opcode;
+  long f_rd;
+  long f_res_rd;
+  long f_rs;
+  long f_res_rs;
+  long f_imm16;
+  long f_uimm16;
+  long f_simm16;
+  long f_res_imm16;
+  long f_rel16;
+  long f_rel21;
+};
+
+#define CGEN_INIT_PARSE(od) \
+{\
+}
+#define CGEN_INIT_INSERT(od) \
+{\
+}
+#define CGEN_INIT_EXTRACT(od) \
+{\
+}
+#define CGEN_INIT_PRINT(od) \
+{\
+}
+
+
+   #ifdef __cplusplus
+   }
+   #endif
+
+#endif /* NCPU32K_OPC_H */
diff -Nur -x cgen -x build -x .cproject -x .project -x .settings binutils-2.32/opcodes/ncpu32k-opinst.c binutils-ncpu32k-2.32/opcodes/ncpu32k-opinst.c
--- binutils-2.32/opcodes/ncpu32k-opinst.c	1970-01-01 08:00:00.000000000 +0800
+++ binutils-ncpu32k-2.32/opcodes/ncpu32k-opinst.c	2019-08-12 18:41:23.437368585 +0800
@@ -0,0 +1,307 @@
+/* DO NOT EDIT!  -*- buffer-read-only: t -*- vi:set ro:  */
+/* Semantic operand instances for ncpu32k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "ncpu32k-desc.h"
+#include "ncpu32k-opc.h"
+
+/* Operand references.  */
+
+#define OP_ENT(op) NCPU32K_OPERAND_##op
+#define INPUT CGEN_OPINST_INPUT
+#define OUTPUT CGEN_OPINST_OUTPUT
+#define END CGEN_OPINST_END
+#define COND_REF CGEN_OPINST_COND_REF
+
+static const CGEN_OPINST sfmt_empty_ops[] ATTRIBUTE_UNUSED = {
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_nop_ops[] ATTRIBUTE_UNUSED = {
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_mov_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_mov_i_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_and_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_and_i_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "uimm16", HW_H_UIMM16, CGEN_MODE_UINT, OP_ENT (UIMM16), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_xor_i_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_add_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "cr_ex_oe", HW_H_CR_EX_OE, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "msr_psr_ov", HW_H_MSR_PSR_OV, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, COND_REF },
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { OUTPUT, "msr_psr_cy", HW_H_MSR_PSR_CY, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "msr_psr_ov", HW_H_MSR_PSR_OV, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_add_i_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "cr_ex_oe", HW_H_CR_EX_OE, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "msr_psr_ov", HW_H_MSR_PSR_OV, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, COND_REF },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "msr_psr_cy", HW_H_MSR_PSR_CY, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "msr_psr_ov", HW_H_MSR_PSR_OV, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_div_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "cr_ex_oe", HW_H_CR_EX_OE, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "msr_psr_cy", HW_H_MSR_PSR_CY, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, COND_REF },
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, COND_REF },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { OUTPUT, "msr_psr_cy", HW_H_MSR_PSR_CY, CGEN_MODE_USI, 0, 0, COND_REF },
+  { OUTPUT, "msr_psr_ov", HW_H_MSR_PSR_OV, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, COND_REF },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_mhi_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "uimm16", HW_H_UIMM16, CGEN_MODE_UINT, OP_ENT (UIMM16), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_wsmr_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "uimm16", HW_H_UIMM16, CGEN_MODE_UINT, OP_ENT (UIMM16), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_jmp_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { OUTPUT, "h_gpr_USI_rd", HW_H_GPR, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_jmp_i_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rel21", HW_H_IADDR, CGEN_MODE_USI, OP_ENT (REL21), 0, 0 },
+  { OUTPUT, "h_gpr_USI_rd", HW_H_GPR, CGEN_MODE_USI, 0, 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_beq_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rel16", HW_H_IADDR, CGEN_MODE_USI, OP_ENT (REL16), 0, COND_REF },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, COND_REF },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_bgt_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rel16", HW_H_IADDR, CGEN_MODE_USI, OP_ENT (REL16), 0, COND_REF },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, COND_REF },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldb_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_QI_c_call__AI_@cpu@_get_load_store_addr_rs_ext__SI_simm16_1", HW_H_MEMORY, CGEN_MODE_QI, 0, 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldbu_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_UQI_c_call__AI_@cpu@_get_load_store_addr_rs_ext__SI_simm16_1", HW_H_MEMORY, CGEN_MODE_UQI, 0, 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldh_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_HI_c_call__AI_@cpu@_get_load_store_addr_rs_ext__SI_simm16_2", HW_H_MEMORY, CGEN_MODE_HI, 0, 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldhu_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_UHI_c_call__AI_@cpu@_get_load_store_addr_rs_ext__SI_simm16_2", HW_H_MEMORY, CGEN_MODE_UHI, 0, 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_ldwu_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_SI_c_call__AI_@cpu@_get_load_store_addr_rs_ext__SI_simm16_4", HW_H_MEMORY, CGEN_MODE_SI, 0, 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_stb_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "h_memory_UQI_addr", HW_H_MEMORY, CGEN_MODE_UQI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_sth_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "h_memory_UHI_addr", HW_H_MEMORY, CGEN_MODE_UHI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_stw_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { INPUT, "rs", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RS), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "h_memory_USI_addr", HW_H_MEMORY, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_exc_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_pcrp_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rel21", HW_H_IADDR, CGEN_MODE_USI, OP_ENT (REL21), 0, 0 },
+  { OUTPUT, "rd", HW_H_GPR, CGEN_MODE_USI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+#undef OP_ENT
+#undef INPUT
+#undef OUTPUT
+#undef END
+#undef COND_REF
+
+/* Operand instance lookup table.  */
+
+static const CGEN_OPINST *ncpu32k_cgen_opinst_table[MAX_INSNS] = {
+  0,
+  & sfmt_nop_ops[0],
+  & sfmt_mov_ops[0],
+  & sfmt_mov_i_ops[0],
+  & sfmt_mov_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_xor_i_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_and_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_add_i_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_add_ops[0],
+  & sfmt_div_ops[0],
+  & sfmt_div_ops[0],
+  & sfmt_div_ops[0],
+  & sfmt_mhi_ops[0],
+  & sfmt_and_i_ops[0],
+  & sfmt_wsmr_ops[0],
+  & sfmt_jmp_ops[0],
+  & sfmt_jmp_i_ops[0],
+  & sfmt_beq_ops[0],
+  & sfmt_beq_ops[0],
+  & sfmt_bgt_ops[0],
+  & sfmt_bgt_ops[0],
+  & sfmt_ldb_ops[0],
+  & sfmt_ldbu_ops[0],
+  & sfmt_ldh_ops[0],
+  & sfmt_ldhu_ops[0],
+  & sfmt_ldwu_ops[0],
+  & sfmt_stb_ops[0],
+  & sfmt_sth_ops[0],
+  & sfmt_stw_ops[0],
+  & sfmt_exc_ops[0],
+  & sfmt_nop_ops[0],
+  & sfmt_nop_ops[0],
+  & sfmt_pcrp_ops[0],
+};
+
+/* Function to call before using the operand instance table.  */
+
+void
+ncpu32k_cgen_init_opinst_table (CGEN_CPU_DESC cd)
+{
+  int i;
+  const CGEN_OPINST **oi = & ncpu32k_cgen_opinst_table[0];
+  CGEN_INSN *insns = (CGEN_INSN *) cd->insn_table.init_entries;
+  for (i = 0; i < MAX_INSNS; ++i)
+    insns[i].opinst = oi[i];
+}
